---
title: Background
description: Convey meaning through `background-color`.
aliases:
  - "/docs/utilities/background/"
toc: true
---

import { getConfig } from '@libs/config'
import { getData } from '@libs/data'
import { allTokens } from '@libs/sass-variables'

<Callout type="info" name="warning-color-assistive-technologies" />

## Background color

Background utilities like `.bg-*` are generated from our `$ouds-backgrounds` Sass map and respond to color modes.

Similar to the contextual text color classes, set the background of an element to any contextual class. Some background utilities will set the text color for you, some will not.

Utilities that set the text color: `.bg-surface-brand-primary`, `.bg-surface-brand-secondary`, `.bg-surface-brand-tertiary`, `.bg-surface-status-accent-emphasized`, `.bg-surface-status-accent-muted`, `.bg-surface-status-positive-emphasized`, `.bg-surface-status-positive-muted`, `.bg-surface-status-negative-emphasized`, `.bg-surface-status-negative-muted`, `.bg-surface-status-warning-emphasized`, `.bg-surface-status-warning-muted`, `.bg-surface-status-info-emphasized`, `.bg-surface-status-info-muted`, `.bg-always-black`, `.bg-always-white`.

All the other background utilities **will not set `color`**, depending on the cases you’ll want to use an additional:
* `[data-bs-theme]` [color mode attribute]([[docsref:/foundation/color-modes#how-to-use]]) is the best option most of the time and moreover when the element using a background utility contains complex sub-elements such as components that need to respond to color modes. It also sets the right color for texts inside
* `.text-*` [color utilities]([[docsref:/utilities/color]]) when the background color and color couple are accessible together in light and dark mode, and there is no components inside

<Callout type="info">
  You can find more information on the OUDS background colors in the [design guidelines](https://unified-design-system.orange.com/472794e18/p/217ac6-color/t/b3d025a22f)
</Callout>

<BootstrapCompatibility>

Here are the equivalent Bootstrap background that you shouldn’t be using. Prefer using the classes above according to [our design system]([[config:ouds.web]]).

<Example code={[
  ...getData('theme-colors').map((themeColor) => `<div class="p-3 mb-2 bg-${themeColor.name}">.bg-${themeColor.name}</div>
<div class="p-3 mb-2 bg-${themeColor.name}-subtle text-${themeColor.name}-emphasis">.bg-${themeColor.name}-subtle</div>`),
  `<div class="p-3 mb-2 bg-body-secondary">.bg-body-secondary</div>
<div class="p-3 mb-2 bg-body-tertiary">.bg-body-tertiary</div>
<div class="p-3 mb-2 bg-body text-body">.bg-body</div>
<div class="p-3 mb-2 bg-black text-white">.bg-black</div>
<div class="p-3 mb-2 bg-white text-black">.bg-white</div>
<div class="p-3 mb-2 bg-transparent text-body">.bg-transparent</div>`]} />

</BootstrapCompatibility>

### `data-bs-theme` attribute

Here are the nominal cases you should be using, when there is no other theme interferences than the root one, using `data-bs-theme` attribute:

<Callout type="info">
  Please note that we use `[data-bs-theme]` attribute on a child element to avoid interfering with the parent theme. This is a workaround to avoid switching the colors between light and dark modes and keep having the good ones displayed.
</Callout>

<Example code={[
  ...allTokens.filter(token => token.name.match(/\$ouds-color-bg-.*-light/))
    .map(token => {
      const bgName = token.name.match(/\$ouds-color-bg-(.*)-light/)[1]
      const themesArray = allTokens.filter(allToken => {
        return allToken.name.match(`modes-on-(bg-)?${bgName}-(dark|light)`)
      }).map(token => token.compiledValue)
      const theme = themesArray[0].includes('dark')
        ? themesArray[1].includes('light')
          ? 'root'
          : 'dark'
        : themesArray[1].includes('light')
          ? 'light'
          : 'root-inverted'
      return `<p class="bg-${bgName} p-large fw-bold">${theme !== 'root' ? `<span data-bs-theme="${theme}">` : ''}.bg-${bgName}${theme !== 'root' ? '</span>' : ''}</p>`
    }),
  ...allTokens.filter(token => token.name.match(/\$ouds-color-surface-.*-light/))
    .map(token => {
      const surfaceName = token.name.match(/\$ouds-color-surface-(.*)-light/)[1]
      const bgName = `surface-${surfaceName}`
      const themesArray = allTokens.filter(allToken => {
        return allToken.name.match(`modes-on-(surface-)?${surfaceName}-(dark|light)`)
      }).map(token => token.compiledValue)
      const theme = themesArray[0].includes('dark')
        ? themesArray[1].includes('light')
          ? 'root'
          : 'dark'
        : themesArray[1].includes('light')
          ? 'light'
          : 'root-inverted'
      return `<p class="bg-${bgName} p-large fw-bold">${theme !== 'root' ? `<span data-bs-theme="${theme}">` : ''}.bg-${bgName}${theme !== 'root' ? '</span>' : ''}</p>`
    }),
  `<p class="bg-always-black p-large fw-bold"><span data-bs-theme="dark">.bg-always-black</span></p>
  <p class="bg-always-white p-large fw-bold"><span data-bs-theme="light">.bg-always-white</span></p>
  <p class="bg-transparent p-large fw-bold">.bg-transparent</p>`]} />

We also provide some opacity backgrounds that should only be used in very specific context, to opacify the background and make some text readable. Prefer using `.bg-secondary` when possible.

<Example code={`<p class="bg-opacity-lower p-large fw-bold">.bg-opacity-lower</p>
  <p class="bg-opacity-lowest p-large fw-bold">.bg-opacity-lowest</p>`} />

#### Inside a static theme

Here is a more complex example to understand how to use `[data-bs-theme]` in specific static contexts. In here you should only use the inverse static theme by replacing all `data-bs-theme="root-inverted"` by `data-bs-theme="light"`. So if you’re in a dark theme context, use only `data-bs-theme="light"` when and if needed and respectively.

<details class="mb-large px-small">
  <summary class="py-small">You’re in a static <code>light</code> context</summary>

<Example class="p-none" code={[`<div class="bg-always-white p-large">
    <div data-bs-theme="light">`,
    ...allTokens.filter(token => token.name.match(/\$ouds-color-bg-.*-light/))
      .map(token => {
        const bgName = token.name.match(/\$ouds-color-bg-(.*)-light/)[1]
        const themesArray = allTokens.filter(allToken => {
          return allToken.name.match(`modes-on-(bg-)?${bgName}-(dark|light)`)
        }).map(token => token.compiledValue)
        const theme = themesArray[0].includes('light')
          ? 'light'
          : 'dark'
        return `    <p class="bg-${bgName} p-large fw-bold">${theme !== 'light' ? `<span data-bs-theme="${theme}">` : ''}.bg-${bgName}${theme !== 'light' ? '</span>' : ''}</p>`
      }),
    ...allTokens.filter(token => token.name.match(/\$ouds-color-surface-.*-light/))
      .map(token => {
        const surfaceName = token.name.match(/\$ouds-color-surface-(.*)-light/)[1]
        const bgName = `surface-${surfaceName}`
        const themesArray = allTokens.filter(allToken => {
          return allToken.name.match(`modes-on-(surface-)?${surfaceName}-(dark|light)`)
        }).map(token => token.compiledValue)
        const theme = themesArray[0].includes('light')
          ? 'light'
          : 'dark'
        return `    <p class="bg-${bgName} p-large fw-bold">${theme !== 'light' ? `<span data-bs-theme="${theme}">` : ''}.bg-${bgName}${theme !== 'light' ? '</span>' : ''}</p>`
      }),
  `    <p class="bg-always-black p-large fw-bold"><span data-bs-theme="dark">.bg-always-black</span></p>
      <p class="bg-always-white p-large fw-bold"><span data-bs-theme="light">.bg-always-white</span></p>
      <p class="bg-transparent p-large fw-bold">.bg-transparent</p>`,
  `  </div>
  </div>`]} />

We also provide some opacity backgrounds that should only be used in very specific context, to opacify the background and make some text readable. Prefer using `.bg-secondary` when possible.

<Example code={`<div class="bg-always-white p-large">
    <div data-bs-theme="light">
      <p class="bg-opacity-lower p-large fw-bold">.bg-opacity-lower</p>
      <p class="bg-opacity-lowest p-large fw-bold">.bg-opacity-lowest</p>
    </div>
  </div>`} />

</details>

<details class="mb-large px-small">
  <summary class="py-small">You’re in a static <code>dark</code> context</summary>

<Example class="p-none" code={[`<div class="bg-always-black p-large">
    <div data-bs-theme="dark">`,
    ...allTokens.filter(token => token.name.match(/\$ouds-color-bg-.*-light/))
      .map(token => {
        const bgName = token.name.match(/\$ouds-color-bg-(.*)-light/)[1]
        const themesArray = allTokens.filter(allToken => {
          return allToken.name.match(`modes-on-(bg-)?${bgName}-(dark|light)`)
        }).map(token => token.compiledValue)
        const theme = themesArray[0].includes('dark')
          ? 'dark'
          : 'light'
        return `    <p class="bg-${bgName} p-large fw-bold">${theme !== 'dark' ? `<span data-bs-theme="${theme}">` : ''}.bg-${bgName}${theme !== 'dark' ? '</span>' : ''}</p>`
      }),
    ...allTokens.filter(token => token.name.match(/\$ouds-color-surface-.*-light/))
      .map(token => {
        const surfaceName = token.name.match(/\$ouds-color-surface-(.*)-light/)[1]
        const bgName = `surface-${surfaceName}`
        const themesArray = allTokens.filter(allToken => {
          return allToken.name.match(`modes-on-(surface-)?${surfaceName}-(dark|light)`)
        }).map(token => token.compiledValue)
        const theme = themesArray[0].includes('dark')
          ? 'dark'
          : 'light'
        return `    <p class="bg-${bgName} p-large fw-bold">${theme !== 'dark' ? `<span data-bs-theme="${theme}">` : ''}.bg-${bgName}${theme !== 'dark' ? '</span>' : ''}</p>`
      }),
  `    <p class="bg-always-black p-large fw-bold"><span data-bs-theme="dark">.bg-always-black</span></p>
      <p class="bg-always-white p-large fw-bold"><span data-bs-theme="light">.bg-always-white</span></p>
      <p class="bg-transparent p-large fw-bold">.bg-transparent</p>`,
  `  </div>
  </div>`]} />

We also provide some opacity backgrounds that should only be used in very specific context, to opacify the background and make some text readable. Prefer using `.bg-secondary` when possible.

<Example code={`<div class="bg-always-black p-large">
    <div data-bs-theme="dark">
      <p class="bg-opacity-lower p-large fw-bold">.bg-opacity-lower</p>
      <p class="bg-opacity-lowest p-large fw-bold">.bg-opacity-lowest</p>
    </div>
  </div>`} />

</details>

#### Inside a dynamic theme

Here is a more complex example to understand how to use `[data-bs-theme]` in specific dynamic contexts. In here you should only replace `data-bs-theme="root-inverted"` by `data-bs-theme="root"` and respectively.

<details class="mb-large px-small">
  <summary class="py-small">You’re in a dynamic <code>root-inverted</code> context</summary>

<Example class="p-none" code={[`<div class="bg-inverse-high p-large">
    <div data-bs-theme="root-inverted">`,
    ...allTokens.filter(token => token.name.match(/\$ouds-color-bg-.*-light/))
      .map(token => {
        const bgName = token.name.match(/\$ouds-color-bg-(.*)-light/)[1]
        const themesArray = allTokens.filter(allToken => {
          return allToken.name.match(`modes-on-(bg-)?${bgName}-(dark|light)`)
        }).map(token => token.compiledValue)
        const theme = themesArray[0].includes('dark')
          ? themesArray[1].includes('light')
            ? 'root-inverted'
            : 'dark'
          : themesArray[1].includes('light')
            ? 'light'
            : 'root'
        return `    <p class="bg-${bgName} p-large fw-bold">${theme !== 'root-inverted' ? `<span data-bs-theme="${theme}">` : ''}.bg-${bgName}${theme !== 'root-inverted' ? '</span>' : ''}</p>`
      }),
    ...allTokens.filter(token => token.name.match(/\$ouds-color-surface-.*-light/))
      .map(token => {
        const surfaceName = token.name.match(/\$ouds-color-surface-(.*)-light/)[1]
        const bgName = `surface-${surfaceName}`
        const themesArray = allTokens.filter(allToken => {
          return allToken.name.match(`modes-on-(surface-)?${surfaceName}-(dark|light)`)
        }).map(token => token.compiledValue)
        const theme = themesArray[0].includes('dark')
          ? themesArray[1].includes('light')
            ? 'root-inverted'
            : 'dark'
          : themesArray[1].includes('light')
            ? 'light'
            : 'root'
        return `    <p class="bg-${bgName} p-large fw-bold">${theme !== 'root-inverted' ? `<span data-bs-theme="${theme}">` : ''}.bg-${bgName}${theme !== 'root-inverted' ? '</span>' : ''}</p>`
      }),
  `    <p class="bg-always-black p-large fw-bold"><span data-bs-theme="dark">.bg-always-black</span></p>
      <p class="bg-always-white p-large fw-bold"><span data-bs-theme="light">.bg-always-white</span></p>
      <p class="bg-transparent p-large fw-bold">.bg-transparent</p>`,
  `  </div>
  </div>`]} />

We also provide some opacity backgrounds that should only be used in very specific context, to opacify the background and make some text readable. Prefer using `.bg-secondary` when possible.

<Example code={`<div class="bg-inverse-high p-large">
    <div data-bs-theme="root-inverted">
      <p class="bg-opacity-lower p-large fw-bold">.bg-opacity-lower</p>
      <p class="bg-opacity-lowest p-large fw-bold">.bg-opacity-lowest</p>
    </div>
  </div>`} />

</details>

## Colored backgrounds

In OUDS Web, we have some backgrounds that are a bit specific because they can take only few components like buttons, links and texts. For accessibility reasons we remove the color of these components.

`.bg-surface-brand-primary`,{getConfig().brand !== 'orange' ? <><code>.bg-surface-brand-secondary</code>, <code>.bg-surface-brand-tertiary</code></> : ''} `.bg-surface-status-accent-emphasized`, `.bg-surface-status-warning-emphasized`, `.bg-surface-status-negative-emphasized`, `.bg-surface-status-positive-emphasized` and `.bg-surface-status-info-emphasized` are considered as colored backgrounds.

<Example code={[
  ...allTokens.filter(token => (token.name.match(/\$ouds-color-surface-brand.*-light/) && token.compiledValue)).map(token => {
    const brandName = token.name.match(/\$ouds-color-surface-brand-(.*)-light/)[1]
    const themesArray = allTokens.filter(allToken => {
      return allToken.name.match(`modes-on-brand-${brandName}-(dark|light)`)
    }).map(token => token.compiledValue)
    const theme = themesArray[0].includes('dark')
      ? themesArray[1].includes('light')
        ? 'root'
        : 'dark'
      : themesArray[1].includes('light')
        ? 'light'
        : 'root-inverted'
    return `<p class="bg-surface-brand-${brandName} p-large fw-bold">${theme !== 'root' ? `<span data-bs-theme="${theme}">` : ''}.bg-surface-brand-${brandName}${theme !== 'root' ? '</span>' : ''}</p>`
  }),
  ...allTokens.filter(token => (token.name.match(/\$ouds-color-surface-status-.*-emphasized-light/) && token.compiledValue)).map(token => {
    const statusName = token.name.match(/\$ouds-color-surface-status-(.*)-emphasized-light/)[1]
    const themesArray = allTokens.filter(allToken => {
      return allToken.name.match(`modes-on-status-${statusName}`)
    }).map(token => token.compiledValue)
    const theme = themesArray[0].includes('dark')
      ? themesArray[1].includes('light')
        ? 'root'
        : 'dark'
      : themesArray[1].includes('light')
        ? 'light'
        : 'root-inverted'
    return `<p class="bg-surface-status-${statusName}-emphasized p-large fw-bold">${theme !== 'root' ? `<span data-bs-theme="${theme}">` : ''}.bg-surface-status-${statusName}-emphasized${theme !== 'root' ? '</span>' : ''}</p>`
  })
  ]} />

## Multiple backgrounds

Sometimes it will be necessary to layer two background colors on top of each other. This can happen when designers opt to have two fill color on a container for example if the parent container have a specific background and we want to opacify a card on top of it. To achieve this with OUDS Web you will need two containers with the specified background color utility.

<Example code={`<div class="p-large" style="background: repeating-linear-gradient(-45deg, #ccc, #ccc 40px, var(--bs-color-bg-secondary) 40px, var(--bs-color-bg-secondary) 80px)">
    <div class="bg-secondary">
      <div class="bg-surface-secondary p-large">
        .bg-secondary and .bg-surface-brand-secondary
      </div>
    </div>
  </div>`} />
