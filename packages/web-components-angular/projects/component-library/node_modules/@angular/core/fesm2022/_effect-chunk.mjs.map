{"version":3,"file":"_effect-chunk.mjs","sources":["../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/primitives/signals/src/graph.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/primitives/signals/src/equality.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/primitives/signals/src/computed.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/primitives/signals/src/errors.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/primitives/signals/src/signal.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/primitives/signals/src/untracked.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/primitives/signals/src/effect.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n// global `ngDevMode` type is defined.\ndeclare const ngDevMode: boolean | undefined;\n\n/**\n * The currently active consumer `ReactiveNode`, if running code in a reactive context.\n *\n * Change this via `setActiveConsumer`.\n */\nlet activeConsumer: ReactiveNode | null = null;\nlet inNotificationPhase = false;\n\nexport type Version = number & {__brand: 'Version'};\n\n/**\n * Global epoch counter. Incremented whenever a source signal is set.\n */\nlet epoch: Version = 1 as Version;\n\nexport type ReactiveHookFn = (node: ReactiveNode) => void;\n\n/**\n * If set, called after a producer `ReactiveNode` is created.\n */\nlet postProducerCreatedFn: ReactiveHookFn | null = null;\n\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nexport const SIGNAL: unique symbol = /* @__PURE__ */ Symbol('SIGNAL');\n\nexport function setActiveConsumer(consumer: ReactiveNode | null): ReactiveNode | null {\n  const prev = activeConsumer;\n  activeConsumer = consumer;\n  return prev;\n}\n\nexport function getActiveConsumer(): ReactiveNode | null {\n  return activeConsumer;\n}\n\nexport function isInNotificationPhase(): boolean {\n  return inNotificationPhase;\n}\n\nexport interface Reactive {\n  [SIGNAL]: ReactiveNode;\n}\n\nexport function isReactive(value: unknown): value is Reactive {\n  return (value as Partial<Reactive>)[SIGNAL] !== undefined;\n}\n\nexport const REACTIVE_NODE: ReactiveNode = {\n  version: 0 as Version,\n  lastCleanEpoch: 0 as Version,\n  dirty: false,\n  producers: undefined,\n  producersTail: undefined,\n  consumers: undefined,\n  consumersTail: undefined,\n  recomputing: false,\n  consumerAllowSignalWrites: false,\n  consumerIsAlwaysLive: false,\n  kind: 'unknown',\n  producerMustRecompute: () => false,\n  producerRecomputeValue: () => {},\n  consumerMarkedDirty: () => {},\n  consumerOnSignalRead: () => {},\n};\n\ninterface ReactiveLink {\n  producer: ReactiveNode;\n  consumer: ReactiveNode;\n  lastReadVersion: number;\n  prevConsumer: ReactiveLink | undefined;\n  nextConsumer: ReactiveLink | undefined;\n  nextProducer: ReactiveLink | undefined;\n}\n\nexport type ReactiveNodeKind =\n  | 'signal'\n  | 'computed'\n  | 'effect'\n  | 'template'\n  | 'linkedSignal'\n  | 'afterRenderEffectPhase'\n  | 'unknown';\n\n/**\n * A producer and/or consumer which participates in the reactive graph.\n *\n * Producer `ReactiveNode`s which are accessed when a consumer `ReactiveNode` is the\n * `activeConsumer` are tracked as dependencies of that consumer.\n *\n * Certain consumers are also tracked as \"live\" consumers and create edges in the other direction,\n * from producer to consumer. These edges are used to propagate change notifications when a\n * producer's value is updated.\n *\n * A `ReactiveNode` may be both a producer and consumer.\n */\nexport interface ReactiveNode {\n  /**\n   * Version of the value that this node produces.\n   *\n   * This is incremented whenever a new value is produced by this node which is not equal to the\n   * previous value (by whatever definition of equality is in use).\n   */\n  version: Version;\n\n  /**\n   * Epoch at which this node is verified to be clean.\n   *\n   * This allows skipping of some polling operations in the case where no signals have been set\n   * since this node was last read.\n   */\n  lastCleanEpoch: Version;\n\n  /**\n   * Whether this node (in its consumer capacity) is dirty.\n   *\n   * Only live consumers become dirty, when receiving a change notification from a dependency\n   * producer.\n   */\n  dirty: boolean;\n\n  /**\n   * Whether this node is currently rebuilding its producer list.\n   */\n  recomputing: boolean;\n\n  /**\n   * Producers which are dependencies of this consumer.\n   */\n  producers: ReactiveLink | undefined;\n\n  /**\n   * Points to the last linked list node in the `producers` linked list.\n   *\n   * When this node is recomputing, this is used to track the producers that we have accessed so far.\n   */\n  producersTail: ReactiveLink | undefined;\n\n  /**\n   * Linked list of consumers of this producer that are \"live\" (they require push notifications).\n   *\n   * The length of this list is effectively our reference count for this node.\n   */\n  consumers: ReactiveLink | undefined;\n  consumersTail: ReactiveLink | undefined;\n\n  /**\n   * Whether writes to signals are allowed when this consumer is the `activeConsumer`.\n   *\n   * This is used to enforce guardrails such as preventing writes to writable signals in the\n   * computation function of computed signals, which is supposed to be pure.\n   */\n  consumerAllowSignalWrites: boolean;\n\n  readonly consumerIsAlwaysLive: boolean;\n\n  /**\n   * Tracks whether producers need to recompute their value independently of the reactive graph (for\n   * example, if no initial value has been computed).\n   */\n  producerMustRecompute(node: unknown): boolean;\n  producerRecomputeValue(node: unknown): void;\n  consumerMarkedDirty(node: unknown): void;\n\n  /**\n   * Called when a signal is read within this consumer.\n   */\n  consumerOnSignalRead(node: unknown): void;\n\n  /**\n   * A debug name for the reactive node. Used in Angular DevTools to identify the node.\n   */\n  debugName?: string;\n\n  /**\n   * Kind of node. Example: 'signal', 'computed', 'input', 'effect'.\n   *\n   * ReactiveNode has this as 'unknown' by default, but derived node types should override this to\n   * make available the kind of signal that particular instance of a ReactiveNode represents.\n   *\n   * Used in Angular DevTools to identify the kind of signal.\n   */\n  kind: ReactiveNodeKind;\n}\n\n/**\n * Called by implementations when a producer's signal is read.\n */\nexport function producerAccessed(node: ReactiveNode): void {\n  if (inNotificationPhase) {\n    throw new Error(\n      typeof ngDevMode !== 'undefined' && ngDevMode\n        ? `Assertion error: signal read during notification phase`\n        : '',\n    );\n  }\n\n  if (activeConsumer === null) {\n    // Accessed outside of a reactive context, so nothing to record.\n    return;\n  }\n\n  activeConsumer.consumerOnSignalRead(node);\n\n  const prevProducerLink = activeConsumer.producersTail;\n\n  // If the last producer we accessed is the same as the current one, we can skip adding a new\n  // link\n  if (prevProducerLink !== undefined && prevProducerLink.producer === node) {\n    return;\n  }\n\n  let nextProducerLink: ReactiveLink | undefined = undefined;\n  const isRecomputing = activeConsumer.recomputing;\n  if (isRecomputing) {\n    // If we're incrementally rebuilding the producers list, we want to check if the next producer\n    // in the list is the same as the one we're trying to add.\n\n    // If the previous producer is defined, then the next producer is just the one that follows it.\n    // Otherwise, we should check the head of the producers list (the first node that we accessed the last time this consumer was run).\n    nextProducerLink =\n      prevProducerLink !== undefined ? prevProducerLink.nextProducer : activeConsumer.producers;\n    if (nextProducerLink !== undefined && nextProducerLink.producer === node) {\n      // If the next producer is the same as the one we're trying to add, we can just update the\n      // last read version, update the tail of the producers list of this rerun, and return.\n      activeConsumer.producersTail = nextProducerLink;\n      nextProducerLink.lastReadVersion = node.version;\n      return;\n    }\n  }\n\n  const prevConsumerLink = node.consumersTail;\n\n  // If the producer we're accessing already has a link to this consumer, we can skip adding a new\n  // link. This can short circuit the creation of a new link in the case where the consumer reads alternating ReeactiveNodes\n  if (\n    prevConsumerLink !== undefined &&\n    prevConsumerLink.consumer === activeConsumer &&\n    // However, we have to make sure that the link we've discovered isn't from a node that is incrementally rebuilding its producer list\n    (!isRecomputing || isValidLink(prevConsumerLink, activeConsumer))\n  ) {\n    // If we found an existing link to the consumer we can just return.\n    return;\n  }\n\n  // If we got here, it means that we need to create a new link between the producer and the consumer.\n  const isLive = consumerIsLive(activeConsumer);\n  const newLink = {\n    producer: node,\n    consumer: activeConsumer,\n    // instead of eagerly destroying the previous link, we delay until we've finished recomputing\n    // the producers list, so that we can destroy all of the old links at once.\n    nextProducer: nextProducerLink,\n    prevConsumer: prevConsumerLink,\n    lastReadVersion: node.version,\n    nextConsumer: undefined,\n  };\n  activeConsumer.producersTail = newLink;\n  if (prevProducerLink !== undefined) {\n    prevProducerLink.nextProducer = newLink;\n  } else {\n    activeConsumer.producers = newLink;\n  }\n\n  if (isLive) {\n    producerAddLiveConsumer(node, newLink);\n  }\n}\n\n/**\n * Increment the global epoch counter.\n *\n * Called by source producers (that is, not computeds) whenever their values change.\n */\nexport function producerIncrementEpoch(): void {\n  epoch++;\n}\n\n/**\n * Ensure this producer's `version` is up-to-date.\n */\nexport function producerUpdateValueVersion(node: ReactiveNode): void {\n  if (consumerIsLive(node) && !node.dirty) {\n    // A live consumer will be marked dirty by producers, so a clean state means that its version\n    // is guaranteed to be up-to-date.\n    return;\n  }\n\n  if (!node.dirty && node.lastCleanEpoch === epoch) {\n    // Even non-live consumers can skip polling if they previously found themselves to be clean at\n    // the current epoch, since their dependencies could not possibly have changed (such a change\n    // would've increased the epoch).\n    return;\n  }\n\n  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n    // None of our producers report a change since the last time they were read, so no\n    // recomputation of our value is necessary, and we can consider ourselves clean.\n    producerMarkClean(node);\n    return;\n  }\n\n  node.producerRecomputeValue(node);\n\n  // After recomputing the value, we're no longer dirty.\n  producerMarkClean(node);\n}\n\n/**\n * Propagate a dirty notification to live consumers of this producer.\n */\nexport function producerNotifyConsumers(node: ReactiveNode): void {\n  if (node.consumers === undefined) {\n    return;\n  }\n\n  // Prevent signal reads when we're updating the graph\n  const prev = inNotificationPhase;\n  inNotificationPhase = true;\n  try {\n    for (\n      let link: ReactiveLink | undefined = node.consumers;\n      link !== undefined;\n      link = link.nextConsumer\n    ) {\n      const consumer = link.consumer;\n      if (!consumer.dirty) {\n        consumerMarkDirty(consumer);\n      }\n    }\n  } finally {\n    inNotificationPhase = prev;\n  }\n}\n\n/**\n * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n * based on the current consumer context.\n */\nexport function producerUpdatesAllowed(): boolean {\n  return activeConsumer?.consumerAllowSignalWrites !== false;\n}\n\nexport function consumerMarkDirty(node: ReactiveNode): void {\n  node.dirty = true;\n  producerNotifyConsumers(node);\n  node.consumerMarkedDirty?.(node);\n}\n\nexport function producerMarkClean(node: ReactiveNode): void {\n  node.dirty = false;\n  node.lastCleanEpoch = epoch;\n}\n\n/**\n * Prepare this consumer to run a computation in its reactive context and set\n * it as the active consumer.\n *\n * Must be called by subclasses which represent reactive computations, before those computations\n * begin.\n */\nexport function consumerBeforeComputation(node: ReactiveNode | null): ReactiveNode | null {\n  if (node) resetConsumerBeforeComputation(node);\n\n  return setActiveConsumer(node);\n}\n\n/**\n * Prepare this consumer to run a computation in its reactive context.\n *\n * We expose this mainly for code where we manually batch effects into a single\n * consumer. In those cases we may wish to \"reopen\" a consumer multiple times\n * in initial render before finalizing it. Most code should just call\n * `consumerBeforeComputation` instead of calling this directly.\n */\nexport function resetConsumerBeforeComputation(node: ReactiveNode): void {\n  node.producersTail = undefined;\n  node.recomputing = true;\n}\n\n/**\n * Finalize this consumer's state and set previous consumer as the active consumer after a\n * reactive computation has run.\n *\n * Must be called by subclasses which represent reactive computations, after those computations\n * have finished.\n */\nexport function consumerAfterComputation(\n  node: ReactiveNode | null,\n  prevConsumer: ReactiveNode | null,\n): void {\n  setActiveConsumer(prevConsumer);\n\n  if (node) finalizeConsumerAfterComputation(node);\n}\n\n/**\n * Finalize this consumer's state after a reactive computation has run.\n *\n * We expose this mainly for code where we manually batch effects into a single\n * consumer. In those cases we may wish to \"reopen\" a consumer multiple times\n * in initial render before finalizing it. Most code should just call\n * `consumerAfterComputation` instead of calling this directly.\n */\nexport function finalizeConsumerAfterComputation(node: ReactiveNode): void {\n  node.recomputing = false;\n\n  // We've finished incrementally rebuilding the producers list, now if there are any producers\n  // that are after producersTail, they are stale and should be removed.\n  const producersTail = node.producersTail as ReactiveLink | undefined;\n  let toRemove = producersTail !== undefined ? producersTail.nextProducer : node.producers;\n  if (toRemove !== undefined) {\n    if (consumerIsLive(node)) {\n      // For each stale link, we first unlink it from the producers list of consumers\n      do {\n        toRemove = producerRemoveLiveConsumerLink(toRemove);\n      } while (toRemove !== undefined);\n    }\n\n    // Now, we can truncate the producers list to remove all stale links.\n    if (producersTail !== undefined) {\n      producersTail.nextProducer = undefined;\n    } else {\n      node.producers = undefined;\n    }\n  }\n}\n\n/**\n * Determine whether this consumer has any dependencies which have changed since the last time\n * they were read.\n */\nexport function consumerPollProducersForChange(node: ReactiveNode): boolean {\n  // Poll producers for change.\n  for (let link = node.producers; link !== undefined; link = link.nextProducer) {\n    const producer = link.producer;\n    const seenVersion = link.lastReadVersion;\n\n    // First check the versions. A mismatch means that the producer's value is known to have\n    // changed since the last time we read it.\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n\n    // The producer's version is the same as the last time we read it, but it might itself be\n    // stale. Force the producer to recompute its version (calculating a new value if necessary).\n    producerUpdateValueVersion(producer);\n\n    // Now when we do this check, `producer.version` is guaranteed to be up to date, so if the\n    // versions still match then it has not changed since the last time we read it.\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Disconnect this consumer from the graph.\n */\nexport function consumerDestroy(node: ReactiveNode): void {\n  if (consumerIsLive(node)) {\n    // Drop all connections from the graph to this node.\n    let link = node.producers;\n    while (link !== undefined) {\n      link = producerRemoveLiveConsumerLink(link);\n    }\n  }\n\n  // Truncate all the linked lists to drop all connection from this node to the graph.\n  node.producers = undefined;\n  node.producersTail = undefined;\n  node.consumers = undefined;\n  node.consumersTail = undefined;\n}\n\n/**\n * Add `consumer` as a live consumer of this node.\n *\n * Note that this operation is potentially transitive. If this node becomes live, then it becomes\n * a live consumer of all of its current producers.\n */\nfunction producerAddLiveConsumer(node: ReactiveNode, link: ReactiveLink): void {\n  const consumersTail = node.consumersTail;\n  const wasLive = consumerIsLive(node);\n  if (consumersTail !== undefined) {\n    link.nextConsumer = consumersTail.nextConsumer;\n    consumersTail.nextConsumer = link;\n  } else {\n    link.nextConsumer = undefined;\n    node.consumers = link;\n  }\n  link.prevConsumer = consumersTail;\n  node.consumersTail = link;\n  if (!wasLive) {\n    for (\n      let link: ReactiveLink | undefined = node.producers;\n      link !== undefined;\n      link = link.nextProducer\n    ) {\n      producerAddLiveConsumer(link.producer, link);\n    }\n  }\n}\n\nfunction producerRemoveLiveConsumerLink(link: ReactiveLink): ReactiveLink | undefined {\n  const producer = link.producer;\n  const nextProducer = link.nextProducer;\n  const nextConsumer = link.nextConsumer;\n  const prevConsumer = link.prevConsumer;\n  link.nextConsumer = undefined;\n  link.prevConsumer = undefined;\n  if (nextConsumer !== undefined) {\n    nextConsumer.prevConsumer = prevConsumer;\n  } else {\n    producer.consumersTail = prevConsumer;\n  }\n  if (prevConsumer !== undefined) {\n    prevConsumer.nextConsumer = nextConsumer;\n  } else {\n    producer.consumers = nextConsumer;\n    if (!consumerIsLive(producer)) {\n      let producerLink = producer.producers;\n      while (producerLink !== undefined) {\n        producerLink = producerRemoveLiveConsumerLink(producerLink);\n      }\n    }\n  }\n  return nextProducer;\n}\n\nfunction consumerIsLive(node: ReactiveNode): boolean {\n  return node.consumerIsAlwaysLive || node.consumers !== undefined;\n}\n\nexport function runPostProducerCreatedFn(node: ReactiveNode): void {\n  postProducerCreatedFn?.(node);\n}\n\nexport function setPostProducerCreatedFn(fn: ReactiveHookFn | null): ReactiveHookFn | null {\n  const prev = postProducerCreatedFn;\n  postProducerCreatedFn = fn;\n  return prev;\n}\n\n// While a ReactiveNode is recomputing, it may not have destroyed previous links\n// This allows us to check if a given link will be destroyed by a reactivenode if it were to finish running immediately without accesing any more producers\nfunction isValidLink(checkLink: ReactiveLink, consumer: ReactiveNode): boolean {\n  const producersTail = consumer.producersTail;\n  if (producersTail !== undefined) {\n    let link = consumer.producers!;\n    do {\n      if (link === checkLink) {\n        return true;\n      }\n      if (link === producersTail) {\n        break;\n      }\n      link = link.nextProducer!;\n    } while (link !== undefined);\n  }\n  return false;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * A comparison function which can determine if two values are equal.\n */\nexport type ValueEqualityFn<T> = (a: T, b: T) => boolean;\n\n/**\n * The default equality function used for `signal` and `computed`, which uses referential equality.\n */\nexport function defaultEquals<T>(a: T, b: T) {\n  return Object.is(a, b);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {defaultEquals, ValueEqualityFn} from './equality';\nimport {\n  consumerAfterComputation,\n  consumerBeforeComputation,\n  producerAccessed,\n  producerUpdateValueVersion,\n  REACTIVE_NODE,\n  ReactiveNode,\n  setActiveConsumer,\n  SIGNAL,\n  runPostProducerCreatedFn,\n} from './graph';\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n// global `ngDevMode` type is defined.\ndeclare const ngDevMode: boolean | undefined;\n\n/**\n * A computation, which derives a value from a declarative reactive expression.\n *\n * `Computed`s are both producers and consumers of reactivity.\n */\nexport interface ComputedNode<T> extends ReactiveNode {\n  /**\n   * Current value of the computation, or one of the sentinel values above (`UNSET`, `COMPUTING`,\n   * `ERROR`).\n   */\n  value: T;\n\n  /**\n   * If `value` is `ERRORED`, the error caught from the last computation attempt which will\n   * be re-thrown.\n   */\n  error: unknown;\n\n  /**\n   * The computation function which will produce a new value.\n   */\n  computation: () => T;\n\n  equal: ValueEqualityFn<T>;\n}\n\nexport type ComputedGetter<T> = (() => T) & {\n  [SIGNAL]: ComputedNode<T>;\n};\n\n/**\n * Create a computed signal which derives a reactive value from an expression.\n */\nexport function createComputed<T>(\n  computation: () => T,\n  equal?: ValueEqualityFn<T>,\n): ComputedGetter<T> {\n  const node: ComputedNode<T> = Object.create(COMPUTED_NODE);\n  node.computation = computation;\n\n  if (equal !== undefined) {\n    node.equal = equal;\n  }\n\n  const computed = () => {\n    // Check if the value needs updating before returning it.\n    producerUpdateValueVersion(node);\n\n    // Record that someone looked at this signal.\n    producerAccessed(node);\n\n    if (node.value === ERRORED) {\n      throw node.error;\n    }\n\n    return node.value;\n  };\n\n  (computed as ComputedGetter<T>)[SIGNAL] = node;\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n    computed.toString = () => `[Computed${debugName}: ${String(node.value)}]`;\n  }\n\n  runPostProducerCreatedFn(node);\n\n  return computed as unknown as ComputedGetter<T>;\n}\n\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nexport const UNSET: any = /* @__PURE__ */ Symbol('UNSET');\n\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nexport const COMPUTING: any = /* @__PURE__ */ Symbol('COMPUTING');\n\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nexport const ERRORED: any = /* @__PURE__ */ Symbol('ERRORED');\n\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst COMPUTED_NODE = /* @__PURE__ */ (() => {\n  return {\n    ...REACTIVE_NODE,\n    value: UNSET,\n    dirty: true,\n    error: null,\n    equal: defaultEquals,\n    kind: 'computed',\n\n    producerMustRecompute(node: ComputedNode<unknown>): boolean {\n      // Force a recomputation if there's no current value, or if the current value is in the\n      // process of being calculated (which should throw an error).\n      return node.value === UNSET || node.value === COMPUTING;\n    },\n\n    producerRecomputeValue(node: ComputedNode<unknown>): void {\n      if (node.value === COMPUTING) {\n        // Our computation somehow led to a cyclic read of itself.\n        throw new Error(\n          typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '',\n        );\n      }\n\n      const oldValue = node.value;\n      node.value = COMPUTING;\n\n      const prevConsumer = consumerBeforeComputation(node);\n      let newValue: unknown;\n      let wasEqual = false;\n      try {\n        newValue = node.computation();\n        // We want to mark this node as errored if calling `equal` throws; however, we don't want\n        // to track any reactive reads inside `equal`.\n        setActiveConsumer(null);\n        wasEqual =\n          oldValue !== UNSET &&\n          oldValue !== ERRORED &&\n          newValue !== ERRORED &&\n          node.equal(oldValue, newValue);\n      } catch (err) {\n        newValue = ERRORED;\n        node.error = err;\n      } finally {\n        consumerAfterComputation(node, prevConsumer);\n      }\n\n      if (wasEqual) {\n        // No change to `valueVersion` - old and new values are\n        // semantically equivalent.\n        node.value = oldValue;\n        return;\n      }\n\n      node.value = newValue;\n      node.version++;\n    },\n  };\n})();\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {SignalNode} from './signal';\n\nfunction defaultThrowError(): never {\n  throw new Error();\n}\n\nlet throwInvalidWriteToSignalErrorFn: <T>(node: SignalNode<T>) => never = defaultThrowError;\n\nexport function throwInvalidWriteToSignalError<T>(node: SignalNode<T>) {\n  throwInvalidWriteToSignalErrorFn(node);\n}\n\nexport function setThrowInvalidWriteToSignalError(fn: <T>(node: SignalNode<T>) => never): void {\n  throwInvalidWriteToSignalErrorFn = fn;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {defaultEquals, ValueEqualityFn} from './equality';\nimport {throwInvalidWriteToSignalError} from './errors';\nimport {\n  producerAccessed,\n  producerIncrementEpoch,\n  producerNotifyConsumers,\n  producerUpdatesAllowed,\n  REACTIVE_NODE,\n  ReactiveNode,\n  ReactiveHookFn,\n  runPostProducerCreatedFn,\n  SIGNAL,\n} from './graph';\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n// global `ngDevMode` type is defined.\ndeclare const ngDevMode: boolean | undefined;\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn: ReactiveHookFn | null = null;\n\nexport interface SignalNode<T> extends ReactiveNode {\n  value: T;\n  equal: ValueEqualityFn<T>;\n}\n\nexport type SignalBaseGetter<T> = (() => T) & {readonly [SIGNAL]: unknown};\nexport type SignalSetter<T> = (newValue: T) => void;\nexport type SignalUpdater<T> = (updateFn: (value: T) => T) => void;\n\n// Note: Closure *requires* this to be an `interface` and not a type, which is why the\n// `SignalBaseGetter` type exists to provide the correct shape.\nexport interface SignalGetter<T> extends SignalBaseGetter<T> {\n  readonly [SIGNAL]: SignalNode<T>;\n}\n\n/**\n * Creates a `Signal` getter, setter, and updater function.\n */\nexport function createSignal<T>(\n  initialValue: T,\n  equal?: ValueEqualityFn<T>,\n): [SignalGetter<T>, SignalSetter<T>, SignalUpdater<T>] {\n  const node: SignalNode<T> = Object.create(SIGNAL_NODE);\n  node.value = initialValue;\n  if (equal !== undefined) {\n    node.equal = equal;\n  }\n  const getter = (() => signalGetFn(node)) as SignalGetter<T>;\n  (getter as any)[SIGNAL] = node;\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n    getter.toString = () => `[Signal${debugName}: ${String(node.value)}]`;\n  }\n\n  runPostProducerCreatedFn(node);\n  const set = (newValue: T) => signalSetFn(node, newValue);\n  const update = (updateFn: (value: T) => T) => signalUpdateFn(node, updateFn);\n  return [getter, set, update];\n}\n\nexport function setPostSignalSetFn(fn: ReactiveHookFn | null): ReactiveHookFn | null {\n  const prev = postSignalSetFn;\n  postSignalSetFn = fn;\n  return prev;\n}\n\nexport function signalGetFn<T>(node: SignalNode<T>): T {\n  producerAccessed(node);\n  return node.value;\n}\n\nexport function signalSetFn<T>(node: SignalNode<T>, newValue: T) {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError(node);\n  }\n\n  if (!node.equal(node.value, newValue)) {\n    node.value = newValue;\n    signalValueChanged(node);\n  }\n}\n\nexport function signalUpdateFn<T>(node: SignalNode<T>, updater: (value: T) => T): void {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError(node);\n  }\n\n  signalSetFn(node, updater(node.value));\n}\n\nexport function runPostSignalSetFn<T>(node: SignalNode<T>): void {\n  postSignalSetFn?.(node);\n}\n\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nexport const SIGNAL_NODE: SignalNode<unknown> = /* @__PURE__ */ (() => {\n  return {\n    ...REACTIVE_NODE,\n    equal: defaultEquals,\n    value: undefined,\n    kind: 'signal',\n  };\n})();\n\nfunction signalValueChanged<T>(node: SignalNode<T>): void {\n  node.version++;\n  producerIncrementEpoch();\n  producerNotifyConsumers(node);\n  postSignalSetFn?.(node);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {setActiveConsumer} from './graph';\n\n/**\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\n * can, optionally, return a value.\n */\nexport function untracked<T>(nonReactiveReadsFn: () => T): T {\n  const prevConsumer = setActiveConsumer(null);\n  // We are not trying to catch any particular errors here, just making sure that the consumers\n  // stack is restored in case of errors.\n  try {\n    return nonReactiveReadsFn();\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  consumerAfterComputation,\n  consumerBeforeComputation,\n  consumerPollProducersForChange,\n  REACTIVE_NODE,\n  ReactiveNode,\n} from './graph';\n\n/**\n * An effect can, optionally, register a cleanup function. If registered, the cleanup is executed\n * before the next effect run. The cleanup function makes it possible to \"cancel\" any work that the\n * previous effect run might have started.\n */\nexport type EffectCleanupFn = () => void;\n\n/**\n * A callback passed to the effect function that makes it possible to register cleanup logic.\n */\nexport type EffectCleanupRegisterFn = (cleanupFn: EffectCleanupFn) => void;\n\nexport interface BaseEffectNode extends ReactiveNode {\n  fn: () => void;\n  destroy(): void;\n  cleanup(): void;\n  run(): void;\n}\n\nexport const BASE_EFFECT_NODE: Omit<BaseEffectNode, 'fn' | 'destroy' | 'cleanup' | 'run'> =\n  /* @__PURE__ */ (() => ({\n    ...REACTIVE_NODE,\n    consumerIsAlwaysLive: true,\n    consumerAllowSignalWrites: true,\n    dirty: true,\n    kind: 'effect',\n  }))();\n\nexport function runEffect(node: BaseEffectNode) {\n  node.dirty = false;\n  if (node.version > 0 && !consumerPollProducersForChange(node)) {\n    return;\n  }\n  node.version++;\n  const prevNode = consumerBeforeComputation(node);\n  try {\n    node.cleanup();\n    node.fn();\n  } finally {\n    consumerAfterComputation(node, prevNode);\n  }\n}\n"],"names":["activeConsumer","inNotificationPhase","epoch","postProducerCreatedFn","SIGNAL","Symbol","setActiveConsumer","consumer","prev","getActiveConsumer","isInNotificationPhase","isReactive","value","undefined","REACTIVE_NODE","version","lastCleanEpoch","dirty","producers","producersTail","consumers","consumersTail","recomputing","consumerAllowSignalWrites","consumerIsAlwaysLive","kind","producerMustRecompute","producerRecomputeValue","consumerMarkedDirty","consumerOnSignalRead","producerAccessed","node","Error","ngDevMode","prevProducerLink","producer","nextProducerLink","isRecomputing","nextProducer","lastReadVersion","prevConsumerLink","isValidLink","isLive","consumerIsLive","newLink","prevConsumer","nextConsumer","producerAddLiveConsumer","producerIncrementEpoch","producerUpdateValueVersion","consumerPollProducersForChange","producerMarkClean","producerNotifyConsumers","link","consumerMarkDirty","producerUpdatesAllowed","consumerBeforeComputation","resetConsumerBeforeComputation","consumerAfterComputation","finalizeConsumerAfterComputation","toRemove","producerRemoveLiveConsumerLink","seenVersion","consumerDestroy","wasLive","producerLink","runPostProducerCreatedFn","setPostProducerCreatedFn","fn","checkLink","defaultEquals","a","b","Object","is","createComputed","computation","equal","create","COMPUTED_NODE","computed","ERRORED","error","debugName","toString","String","UNSET","COMPUTING","oldValue","newValue","wasEqual","err","defaultThrowError","throwInvalidWriteToSignalErrorFn","throwInvalidWriteToSignalError","setThrowInvalidWriteToSignalError","postSignalSetFn","createSignal","initialValue","SIGNAL_NODE","getter","signalGetFn","set","signalSetFn","update","updateFn","signalUpdateFn","setPostSignalSetFn","signalValueChanged","updater","runPostSignalSetFn","untracked","nonReactiveReadsFn","BASE_EFFECT_NODE","runEffect","prevNode","cleanup"],"mappings":"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"}