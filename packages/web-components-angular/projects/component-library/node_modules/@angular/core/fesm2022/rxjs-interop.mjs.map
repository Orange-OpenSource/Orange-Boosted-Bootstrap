{"version":3,"file":"rxjs-interop.mjs","sources":["../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/rxjs-interop/src/take_until_destroyed.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/rxjs-interop/src/output_from_observable.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/rxjs-interop/src/output_to_observable.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/rxjs-interop/src/to_observable.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/rxjs-interop/src/to_signal.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/rxjs-interop/src/pending_until_event.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/rxjs-interop/src/rx_resource.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {assertInInjectionContext, DestroyRef, inject} from '../../src/core';\nimport {MonoTypeOperatorFunction, Observable} from 'rxjs';\nimport {takeUntil} from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\n * context](guide/di/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\n *\n * @see [Unsubscribing with takeUntilDestroyed](ecosystem/rxjs-interop/take-until-destroyed)\n *\n * @publicApi 19.0\n */\nexport function takeUntilDestroyed<T>(destroyRef?: DestroyRef): MonoTypeOperatorFunction<T> {\n  if (!destroyRef) {\n    ngDevMode && assertInInjectionContext(takeUntilDestroyed);\n    destroyRef = inject(DestroyRef);\n  }\n\n  const destroyed$ = new Observable<void>((subscriber) => {\n    if (destroyRef.destroyed) {\n      subscriber.next();\n      return;\n    }\n    const unregisterFn = destroyRef.onDestroy(subscriber.next.bind(subscriber));\n    return unregisterFn;\n  });\n\n  return <T>(source: Observable<T>) => {\n    return source.pipe(takeUntil(destroyed$));\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  assertInInjectionContext,\n  DestroyRef,\n  inject,\n  OutputOptions,\n  OutputRef,\n  OutputRefSubscription,\n  ɵRuntimeError,\n  ɵRuntimeErrorCode,\n} from '../../src/core';\nimport {Observable} from 'rxjs';\n\nimport {takeUntilDestroyed} from './take_until_destroyed';\n\n/**\n * Implementation of `OutputRef` that emits values from\n * an RxJS observable source.\n *\n * @internal\n */\nclass OutputFromObservableRef<T> implements OutputRef<T> {\n  private destroyed = false;\n\n  destroyRef = inject(DestroyRef);\n\n  constructor(private source: Observable<T>) {\n    this.destroyRef.onDestroy(() => {\n      this.destroyed = true;\n    });\n  }\n\n  subscribe(callbackFn: (value: T) => void): OutputRefSubscription {\n    if (this.destroyed) {\n      throw new ɵRuntimeError(\n        ɵRuntimeErrorCode.OUTPUT_REF_DESTROYED,\n        ngDevMode &&\n          'Unexpected subscription to destroyed `OutputRef`. ' +\n            'The owning directive/component is destroyed.',\n      );\n    }\n\n    // Stop yielding more values when the directive/component is already destroyed.\n    const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\n      next: (value) => callbackFn(value),\n    });\n\n    return {\n      unsubscribe: () => subscription.unsubscribe(),\n    };\n  }\n}\n\n/**\n * Declares an Angular output that is using an RxJS observable as a source\n * for events dispatched to parent subscribers.\n *\n * The behavior for an observable as source is defined as followed:\n *    1. New values are forwarded to the Angular output (next notifications).\n *    2. Errors notifications are not handled by Angular. You need to handle these manually.\n *       For example by using `catchError`.\n *    3. Completion notifications stop the output from emitting new values.\n *\n * @usageNotes\n * Initialize an output in your directive by declaring a\n * class field and initializing it with the `outputFromObservable()` function.\n *\n * ```ts\n * @Directive({..})\n * export class MyDir {\n *   nameChange$ = <some-observable>;\n *   nameChange = outputFromObservable(this.nameChange$);\n * }\n * ```\n * @see [RxJS interop with component and directive outputs](ecosystem/rxjs-interop/output-interop)\n *\n * @publicApi 19.0\n */\nexport function outputFromObservable<T>(\n  observable: Observable<T>,\n  opts?: OutputOptions,\n): OutputRef<T> {\n  ngDevMode && assertInInjectionContext(outputFromObservable);\n  return new OutputFromObservableRef<T>(observable);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {OutputRef, ɵgetOutputDestroyRef} from '../../src/core';\nimport {Observable} from 'rxjs';\n\n/**\n * Converts an Angular output declared via `output()` or `outputFromObservable()`\n * to an observable.\n * It creates an observable that represents the stream of \"events firing\" in an output.\n *\n * You can subscribe to the output via `Observable.subscribe` then.\n *\n * @see [RxJS interop with component and directive outputs](ecosystem/rxjs-interop/output-interop)\n *\n * @publicApi 19.0\n */\nexport function outputToObservable<T>(ref: OutputRef<T>): Observable<T> {\n  const destroyRef = ɵgetOutputDestroyRef(ref);\n\n  return new Observable<T>((observer) => {\n    // Complete the observable upon directive/component destroy.\n    // Note: May be `undefined` if an `EventEmitter` is declared outside\n    // of an injection context.\n    const unregisterOnDestroy = destroyRef?.onDestroy(() => observer.complete());\n\n    const subscription = ref.subscribe((v) => observer.next(v));\n    return () => {\n      subscription.unsubscribe();\n      unregisterOnDestroy?.();\n    };\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  assertInInjectionContext,\n  DestroyRef,\n  effect,\n  inject,\n  Injector,\n  Signal,\n  untracked,\n} from '../../src/core';\nimport {Observable, ReplaySubject} from 'rxjs';\n\n/**\n * Options for `toObservable`.\n *\n * @publicApi 20.0\n */\nexport interface ToObservableOptions {\n  /**\n   * The `Injector` to use when creating the underlying `effect` which watches the signal.\n   *\n   * If this isn't specified, the current [injection context](guide/di/dependency-injection-context)\n   * will be used.\n   */\n  injector?: Injector;\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n * As it reflects a state, the observable will always emit the latest value upon subscription.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @see [RxJS interop with Angular signals](ecosystem/rxjs-interop)\n * @see [Create an RxJS Observable from a signal with toObservable](ecosystem/rxjs-interop#create-an-rxjs-observable-from-a-signal-with-toobservable)\n *\n * @publicApi 20.0\n */\nexport function toObservable<T>(source: Signal<T>, options?: ToObservableOptions): Observable<T> {\n  if (ngDevMode && !options?.injector) {\n    assertInInjectionContext(toObservable);\n  }\n  const injector = options?.injector ?? inject(Injector);\n  const subject = new ReplaySubject<T>(1);\n\n  const watcher = effect(\n    () => {\n      let value: T;\n      try {\n        value = source();\n      } catch (err) {\n        untracked(() => subject.error(err));\n        return;\n      }\n      untracked(() => subject.next(value));\n    },\n    {injector, manualCleanup: true},\n  );\n\n  injector.get(DestroyRef).onDestroy(() => {\n    watcher.destroy();\n    subject.complete();\n  });\n\n  return subject.asObservable();\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  assertInInjectionContext,\n  assertNotInReactiveContext,\n  computed,\n  DestroyRef,\n  inject,\n  Injector,\n  signal,\n  Signal,\n  WritableSignal,\n  ɵRuntimeError,\n  ɵRuntimeErrorCode,\n} from '../../src/core';\nimport {ValueEqualityFn} from '../../primitives/signals';\nimport {Observable, Subscribable} from 'rxjs';\n\n/**\n * Options for `toSignal`.\n *\n * @publicApi 20.0\n */\nexport interface ToSignalOptions<T> {\n  /**\n   * Initial value for the signal produced by `toSignal`.\n   *\n   * This will be the value of the signal until the observable emits its first value.\n   */\n  initialValue?: unknown;\n\n  /**\n   * Whether to require that the observable emits synchronously when `toSignal` subscribes.\n   *\n   * If this is `true`, `toSignal` will assert that the observable produces a value immediately upon\n   * subscription. Setting this option removes the need to either deal with `undefined` in the\n   * signal type or provide an `initialValue`, at the cost of a runtime error if this requirement is\n   * not met.\n   */\n  requireSync?: boolean;\n\n  /**\n   * `Injector` which will provide the `DestroyRef` used to clean up the Observable subscription.\n   *\n   * If this is not provided, a `DestroyRef` will be retrieved from the current [injection\n   * context](guide/di/dependency-injection-context), unless manual cleanup is requested.\n   */\n  injector?: Injector;\n\n  /**\n   * Whether the subscription should be automatically cleaned up (via `DestroyRef`) when\n   * `toSignal`'s creation context is destroyed.\n   *\n   * If manual cleanup is enabled, then `DestroyRef` is not used, and the subscription will persist\n   * until the `Observable` itself completes.\n   */\n  manualCleanup?: boolean;\n\n  /**\n   * A comparison function which defines equality for values emitted by the observable.\n   *\n   * Equality comparisons are executed against the initial value if one is provided.\n   */\n  equal?: ValueEqualityFn<T>;\n\n  /**\n   * A debug name for the signal. Used in Angular DevTools to identify the signal.\n   */\n  debugName?: string;\n}\n\n// Base case: no options -> `undefined` in the result type.\nexport function toSignal<T>(source: Observable<T> | Subscribable<T>): Signal<T | undefined>;\n// Options with `undefined` initial value and no `requiredSync` -> `undefined`.\nexport function toSignal<T>(\n  source: Observable<T> | Subscribable<T>,\n  options: NoInfer<ToSignalOptions<T | undefined>> & {\n    initialValue?: undefined;\n    requireSync?: false;\n  },\n): Signal<T | undefined>;\n// Options with `null` initial value -> `null`.\nexport function toSignal<T>(\n  source: Observable<T> | Subscribable<T>,\n  options: NoInfer<ToSignalOptions<T | null>> & {initialValue?: null; requireSync?: false},\n): Signal<T | null>;\n// Options with `undefined` initial value and `requiredSync` -> strict result type.\nexport function toSignal<T>(\n  source: Observable<T> | Subscribable<T>,\n  options: NoInfer<ToSignalOptions<T>> & {initialValue?: undefined; requireSync: true},\n): Signal<T>;\n// Options with a more specific initial value type.\nexport function toSignal<T, const U extends T>(\n  source: Observable<T> | Subscribable<T>,\n  options: NoInfer<ToSignalOptions<T | U>> & {initialValue: U; requireSync?: false},\n): Signal<T | U>;\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\n * does not include an `undefined` type.\n *\n * By default, the subscription will be automatically cleaned up when the current [injection\n * context](guide/di/dependency-injection-context) is destroyed. For example, when `toSignal` is\n * called during the construction of a component, the subscription will be cleaned up when the\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\n * passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n *\n * @see [RxJS interop with Angular signals](ecosystem/rxjs-interop)\n */\nexport function toSignal<T, U = undefined>(\n  source: Observable<T> | Subscribable<T>,\n  options?: ToSignalOptions<T | U> & {initialValue?: U},\n): Signal<T | U> {\n  typeof ngDevMode !== 'undefined' &&\n    ngDevMode &&\n    assertNotInReactiveContext(\n      toSignal,\n      'Invoking `toSignal` causes new subscriptions every time. ' +\n        'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.',\n    );\n\n  const requiresCleanup = !options?.manualCleanup;\n\n  if (ngDevMode && requiresCleanup && !options?.injector) {\n    assertInInjectionContext(toSignal);\n  }\n\n  const cleanupRef = requiresCleanup\n    ? (options?.injector?.get(DestroyRef) ?? inject(DestroyRef))\n    : null;\n\n  const equal = makeToSignalEqual(options?.equal);\n\n  // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n  // the same - the returned signal gives values of type `T`.\n  let state: WritableSignal<State<T | U>>;\n  if (options?.requireSync) {\n    // Initially the signal is in a `NoValue` state.\n    state = signal(\n      {kind: StateKind.NoValue},\n      {equal, ...(ngDevMode ? createDebugNameObject(options?.debugName, 'state') : undefined)},\n    );\n  } else {\n    // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n    state = signal<State<T | U>>(\n      {kind: StateKind.Value, value: options?.initialValue as U},\n      {equal, ...(ngDevMode ? createDebugNameObject(options?.debugName, 'state') : undefined)},\n    );\n  }\n\n  let destroyUnregisterFn: (() => void) | undefined;\n\n  // Note: This code cannot run inside a reactive context (see assertion above). If we'd support\n  // this, we would subscribe to the observable outside of the current reactive context, avoiding\n  // that side-effect signal reads/writes are attribute to the current consumer. The current\n  // consumer only needs to be notified when the `state` signal changes through the observable\n  // subscription. Additional context (related to async pipe):\n  // https://github.com/angular/angular/pull/50522.\n  const sub = source.subscribe({\n    next: (value) => state.set({kind: StateKind.Value, value}),\n    error: (error) => {\n      state.set({kind: StateKind.Error, error});\n      destroyUnregisterFn?.();\n    },\n    complete: () => {\n      destroyUnregisterFn?.();\n    },\n    // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n    // \"complete\".\n  });\n\n  if (options?.requireSync && state().kind === StateKind.NoValue) {\n    throw new ɵRuntimeError(\n      ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT,\n      (typeof ngDevMode === 'undefined' || ngDevMode) &&\n        '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.',\n    );\n  }\n\n  // Unsubscribe when the current context is destroyed, if requested.\n  destroyUnregisterFn = cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n\n  // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n  // to either values or errors.\n  return computed(\n    () => {\n      const current = state();\n      switch (current.kind) {\n        case StateKind.Value:\n          return current.value;\n        case StateKind.Error:\n          throw current.error;\n        case StateKind.NoValue:\n          // This shouldn't really happen because the error is thrown on creation.\n          throw new ɵRuntimeError(\n            ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT,\n            (typeof ngDevMode === 'undefined' || ngDevMode) &&\n              '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.',\n          );\n      }\n    },\n    {\n      equal: options?.equal,\n      ...(ngDevMode ? createDebugNameObject(options?.debugName, 'source') : undefined),\n    },\n  );\n}\n\nfunction makeToSignalEqual<T>(\n  userEquality: ValueEqualityFn<T> = Object.is,\n): ValueEqualityFn<State<T>> {\n  return (a, b) =>\n    a.kind === StateKind.Value && b.kind === StateKind.Value && userEquality(a.value, b.value);\n}\n\n/**\n * Creates a debug name object for an internal toSignal signal.\n */\nfunction createDebugNameObject(\n  toSignalDebugName: string | undefined,\n  internalSignalDebugName: string,\n): {debugName?: string} {\n  return {\n    debugName: `toSignal${toSignalDebugName ? '#' + toSignalDebugName : ''}.${internalSignalDebugName}`,\n  };\n}\n\nconst enum StateKind {\n  NoValue,\n  Value,\n  Error,\n}\n\ninterface NoValueState {\n  kind: StateKind.NoValue;\n}\n\ninterface ValueState<T> {\n  kind: StateKind.Value;\n  value: T;\n}\n\ninterface ErrorState {\n  kind: StateKind.Error;\n  error: unknown;\n}\n\ntype State<T> = NoValueState | ValueState<T> | ErrorState;\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {assertInInjectionContext, PendingTasks, inject, Injector} from '../../src/core';\nimport {MonoTypeOperatorFunction, Observable} from 'rxjs';\n\n/**\n * Operator which makes the application unstable until the observable emits, completes, errors, or is unsubscribed.\n *\n * Use this operator in observables whose subscriptions are important for rendering and should be included in SSR serialization.\n *\n * @param injector The `Injector` to use during creation. If this is not provided, the current injection context will be used instead (via `inject`).\n *\n * @developerPreview 20.0\n */\nexport function pendingUntilEvent<T>(injector?: Injector): MonoTypeOperatorFunction<T> {\n  if (injector === undefined) {\n    ngDevMode && assertInInjectionContext(pendingUntilEvent);\n    injector = inject(Injector);\n  }\n  const taskService = injector.get(PendingTasks);\n\n  return (sourceObservable) => {\n    return new Observable<T>((originalSubscriber) => {\n      // create a new task on subscription\n      const removeTask = taskService.add();\n\n      let cleanedUp = false;\n      function cleanupTask() {\n        if (cleanedUp) {\n          return;\n        }\n\n        removeTask();\n        cleanedUp = true;\n      }\n\n      const innerSubscription = sourceObservable.subscribe({\n        next: (v) => {\n          originalSubscriber.next(v);\n          cleanupTask();\n        },\n        complete: () => {\n          originalSubscriber.complete();\n          cleanupTask();\n        },\n        error: (e) => {\n          originalSubscriber.error(e);\n          cleanupTask();\n        },\n      });\n      innerSubscription.add(() => {\n        originalSubscriber.unsubscribe();\n        cleanupTask();\n      });\n      return innerSubscription;\n    });\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  assertInInjectionContext,\n  resource,\n  ResourceLoaderParams,\n  ResourceRef,\n  Signal,\n  signal,\n  BaseResourceOptions,\n  ɵRuntimeError,\n  ɵRuntimeErrorCode,\n  ResourceStreamItem,\n} from '../../src/core';\nimport {Observable, Subscription} from 'rxjs';\nimport {encapsulateResourceError} from '../../src/resource/resource';\n\n/**\n * Like `ResourceOptions` but uses an RxJS-based `loader`.\n *\n * @experimental\n */\nexport interface RxResourceOptions<T, R> extends BaseResourceOptions<T, R> {\n  stream: (params: ResourceLoaderParams<R>) => Observable<T>;\n}\n\n/**\n * Like `resource` but uses an RxJS based `loader` which maps the request to an `Observable` of the\n * resource's value.\n *\n * @see [Using rxResource for async data](ecosystem/rxjs-interop#using-rxresource-for-async-data)\n *\n * @experimental\n */\nexport function rxResource<T, R>(\n  opts: RxResourceOptions<T, R> & {defaultValue: NoInfer<T>},\n): ResourceRef<T>;\n\n/**\n * Like `resource` but uses an RxJS based `loader` which maps the request to an `Observable` of the\n * resource's value.\n *\n * @experimental\n */\nexport function rxResource<T, R>(opts: RxResourceOptions<T, R>): ResourceRef<T | undefined>;\nexport function rxResource<T, R>(opts: RxResourceOptions<T, R>): ResourceRef<T | undefined> {\n  if (ngDevMode && !opts?.injector) {\n    assertInInjectionContext(rxResource);\n  }\n  return resource<T, R>({\n    ...opts,\n    loader: undefined,\n    stream: (params) => {\n      let sub: Subscription | undefined;\n\n      // Track the abort listener so it can be removed if the Observable completes (as a memory\n      // optimization).\n      const onAbort = () => sub?.unsubscribe();\n      params.abortSignal.addEventListener('abort', onAbort);\n\n      // Start off stream as undefined.\n      const stream = signal<ResourceStreamItem<T>>({value: undefined as T});\n      let resolve: ((value: Signal<ResourceStreamItem<T>>) => void) | undefined;\n      const promise = new Promise<Signal<ResourceStreamItem<T>>>((r) => (resolve = r));\n\n      function send(value: ResourceStreamItem<T>): void {\n        stream.set(value);\n        resolve?.(stream);\n        resolve = undefined;\n      }\n\n      // TODO(alxhub): remove after g3 updated to rename loader -> stream\n      const streamFn = opts.stream ?? (opts as {loader?: RxResourceOptions<T, R>['stream']}).loader;\n      if (streamFn === undefined) {\n        throw new ɵRuntimeError(\n          ɵRuntimeErrorCode.MUST_PROVIDE_STREAM_OPTION,\n          ngDevMode && `Must provide \\`stream\\` option.`,\n        );\n      }\n\n      sub = streamFn(params).subscribe({\n        next: (value) => send({value}),\n        error: (error: unknown) => {\n          send({error: encapsulateResourceError(error)});\n          params.abortSignal.removeEventListener('abort', onAbort);\n        },\n        complete: () => {\n          if (resolve) {\n            send({\n              error: new ɵRuntimeError(\n                ɵRuntimeErrorCode.RESOURCE_COMPLETED_BEFORE_PRODUCING_VALUE,\n                ngDevMode && 'Resource completed before producing a value',\n              ),\n            });\n          }\n          params.abortSignal.removeEventListener('abort', onAbort);\n        },\n      });\n\n      return promise;\n    },\n  });\n}\n"],"names":["takeUntilDestroyed","destroyRef","ngDevMode","assertInInjectionContext","inject","DestroyRef","destroyed$","Observable","subscriber","destroyed","next","unregisterFn","onDestroy","bind","source","pipe","takeUntil","OutputFromObservableRef","constructor","subscribe","callbackFn","ɵRuntimeError","subscription","value","unsubscribe","outputFromObservable","observable","opts","outputToObservable","ref","ɵgetOutputDestroyRef","observer","unregisterOnDestroy","complete","v","toObservable","options","injector","Injector","subject","ReplaySubject","watcher","effect","err","untracked","error","manualCleanup","get","destroy","asObservable","toSignal","assertNotInReactiveContext","requiresCleanup","cleanupRef","equal","makeToSignalEqual","state","requireSync","signal","kind","createDebugNameObject","debugName","undefined","initialValue","destroyUnregisterFn","sub","set","computed","current","userEquality","Object","is","a","b","toSignalDebugName","internalSignalDebugName","pendingUntilEvent","taskService","PendingTasks","sourceObservable","originalSubscriber","removeTask","add","cleanedUp","cleanupTask","innerSubscription","e","rxResource","resource","loader","stream","params","onAbort","abortSignal","addEventListener","resolve","promise","Promise","r","send","streamFn","encapsulateResourceError","removeEventListener"],"mappings":"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"}