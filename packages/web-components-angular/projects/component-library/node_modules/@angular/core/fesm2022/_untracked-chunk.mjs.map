{"version":3,"file":"_untracked-chunk.mjs","sources":["../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/version.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/error_details_base_url.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/errors.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/util/global.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/util/ng_dev_mode.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/util/property.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/util/stringify.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/di/forward_ref.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/util/assert.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/di/interface/defs.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/di/injection_token.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/render3/debug/injector_profiler.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/di/interface/provider.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/render3/fields.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/render3/def_getters.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/render3/util/stringify_utils.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/render3/errors_di.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/di/inject_switch.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/di/injector_compatibility.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/render3/definition_factory.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/util/array_utils.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/util/empty.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/di/initializer_token.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/di/injector_token.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/di/internal_tokens.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/di/null_injector.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/di/provider_collection.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/di/scope.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/di/r3_injector.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/di/contextual.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/render3/interfaces/view.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/render3/interfaces/container.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/render3/interfaces/type_checks.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/render3/assert.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/render3/namespaces.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/render3/util/view_utils.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/render3/state.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/di/create_injector.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/di/injector.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/document.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/linker/destroy_ref.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/change_detection/scheduling/flags.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/pending_tasks_internal.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/event_emitter.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/util/noop.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/util/callback_scheduler.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/zone/async-stack-tagging.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/zone/ng_zone.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/error_handler.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/render3/reactivity/signal.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/render3/reactivity/asserts.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/render3/view_context.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/change_detection/scheduling/zoneless_scheduling.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/pending_tasks.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/render3/reactivity/root_effect_scheduler.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/render3/reactivity/effect.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/src/render3/reactivity/untracked.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * @description Represents the version of Angular\n *\n * @publicApi\n */\nexport class Version {\n  public readonly major: string;\n  public readonly minor: string;\n  public readonly patch: string;\n\n  constructor(public full: string) {\n    const parts = full.split('.');\n    this.major = parts[0];\n    this.minor = parts[1];\n    this.patch = parts.slice(2).join('.');\n  }\n}\n\n/**\n * @publicApi\n */\nexport const VERSION = /* @__PURE__ */ new Version('21.0.8');\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {VERSION} from './version';\n\n/**\n * Base URL for the error details page.\n *\n * Keep this constant in sync across:\n *  - packages/compiler-cli/src/ngtsc/diagnostics/src/error_details_base_url.ts\n *  - packages/core/src/error_details_base_url.ts\n */\nexport const ERROR_DETAILS_PAGE_BASE_URL: string = (() => {\n  const versionSubDomain = VERSION.major !== '0' ? `v${VERSION.major}.` : '';\n  return `https://${versionSubDomain}angular.dev/errors`;\n})();\n\n/**\n * URL for the XSS security documentation.\n */\nexport const XSS_SECURITY_URL =\n  'https://angular.dev/best-practices/security#preventing-cross-site-scripting-xss';\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ERROR_DETAILS_PAGE_BASE_URL} from './error_details_base_url';\n\n/**\n * The list of error codes used in runtime code of the `core` package.\n * Reserved error code range: 100-999.\n *\n * Note: the minus sign denotes the fact that a particular code has a detailed guide on\n * angular.io. This extra annotation is needed to avoid introducing a separate set to store\n * error codes which have guides, which might leak into runtime code.\n *\n * Full list of available error guides can be found at https://angular.dev/errors.\n *\n * Error code ranges per package:\n *  - core (this package): 100-999\n *  - forms: 1000-1999\n *  - common: 2000-2999\n *  - animations: 3000-3999\n *  - router: 4000-4999\n *  - platform-browser: 5000-5500\n */\nexport const enum RuntimeErrorCode {\n  // Change Detection Errors\n  EXPRESSION_CHANGED_AFTER_CHECKED = -100,\n  RECURSIVE_APPLICATION_REF_TICK = 101,\n  INFINITE_CHANGE_DETECTION = 103,\n\n  // Dependency Injection Errors\n  CYCLIC_DI_DEPENDENCY = -200,\n  PROVIDER_NOT_FOUND = -201,\n  INVALID_FACTORY_DEPENDENCY = 202,\n  MISSING_INJECTION_CONTEXT = -203,\n  INVALID_INJECTION_TOKEN = 204,\n  INJECTOR_ALREADY_DESTROYED = 205,\n  PROVIDER_IN_WRONG_CONTEXT = 207,\n  MISSING_INJECTION_TOKEN = 208,\n  INVALID_MULTI_PROVIDER = -209,\n  MISSING_DOCUMENT = 210,\n  INVALID_APP_ID = 211,\n\n  // Template Errors\n  MULTIPLE_COMPONENTS_MATCH = -300,\n  EXPORT_NOT_FOUND = -301,\n  PIPE_NOT_FOUND = -302,\n  UNKNOWN_BINDING = 303,\n  UNKNOWN_ELEMENT = 304,\n  TEMPLATE_STRUCTURE_ERROR = 305,\n  INVALID_EVENT_BINDING = 306,\n  HOST_DIRECTIVE_UNRESOLVABLE = 307,\n  HOST_DIRECTIVE_NOT_STANDALONE = 308,\n  DUPLICATE_DIRECTIVE = 309,\n  HOST_DIRECTIVE_COMPONENT = 310,\n  HOST_DIRECTIVE_UNDEFINED_BINDING = 311,\n  HOST_DIRECTIVE_CONFLICTING_ALIAS = 312,\n  MULTIPLE_MATCHING_PIPES = 313,\n  UNINITIALIZED_LET_ACCESS = 314,\n  NO_BINDING_TARGET = 315,\n  INVALID_BINDING_TARGET = 316,\n  INVALID_SET_INPUT_CALL = 317,\n  INVALID_FIELD_DIRECTIVE_HOST = 318,\n\n  // Bootstrap Errors\n  MULTIPLE_PLATFORMS = 400,\n  PLATFORM_NOT_FOUND = -401,\n  MISSING_REQUIRED_INJECTABLE_IN_BOOTSTRAP = 402,\n  BOOTSTRAP_COMPONENTS_NOT_FOUND = -403,\n  PLATFORM_ALREADY_DESTROYED = 404,\n  ASYNC_INITIALIZERS_STILL_RUNNING = 405,\n  APPLICATION_REF_ALREADY_DESTROYED = 406,\n  RENDERER_NOT_FOUND = 407,\n  PROVIDED_BOTH_ZONE_AND_ZONELESS = 408,\n\n  // Hydration Errors\n  HYDRATION_NODE_MISMATCH = -500,\n  HYDRATION_MISSING_SIBLINGS = -501,\n  HYDRATION_MISSING_NODE = -502,\n  UNSUPPORTED_PROJECTION_DOM_NODES = -503,\n  INVALID_SKIP_HYDRATION_HOST = -504,\n  MISSING_HYDRATION_ANNOTATIONS = -505,\n  HYDRATION_STABLE_TIMEDOUT = -506,\n  MISSING_SSR_CONTENT_INTEGRITY_MARKER = -507,\n  MISCONFIGURED_INCREMENTAL_HYDRATION = 508,\n\n  // Signal Errors\n  SIGNAL_WRITE_FROM_ILLEGAL_CONTEXT = 600,\n  REQUIRE_SYNC_WITHOUT_SYNC_EMIT = 601,\n  ASSERTION_NOT_INSIDE_REACTIVE_CONTEXT = -602,\n\n  // Animation Errors\n  ANIMATE_INVALID_VALUE = 650,\n  // Declarations Errors\n\n  // i18n Errors\n  INVALID_I18N_STRUCTURE = 700,\n  MISSING_LOCALE_DATA = 701,\n\n  // Defer errors (750-799 range)\n  DEFER_LOADING_FAILED = -750,\n  DEFER_IN_HMR_MODE = -751,\n\n  // standalone errors\n  IMPORT_PROVIDERS_FROM_STANDALONE = 800,\n\n  // JIT Compilation Errors\n  // Other\n  INVALID_DIFFER_INPUT = 900,\n  NO_SUPPORTING_DIFFER_FACTORY = 901,\n  VIEW_ALREADY_ATTACHED = 902,\n  INVALID_INHERITANCE = 903,\n  UNSAFE_VALUE_IN_RESOURCE_URL = 904,\n  UNSAFE_VALUE_IN_SCRIPT = 905,\n  MISSING_GENERATED_DEF = 906,\n  TYPE_IS_NOT_STANDALONE = 907,\n  MISSING_ZONEJS = 908,\n  UNEXPECTED_ZONE_STATE = 909,\n  UNSAFE_ATTRIBUTE_BINDING = -910,\n  /**\n   * @deprecated use `UNSAFE_ATTRIBUTE_BINDING` instead.\n   */\n  // tslint:disable-next-line:no-duplicate-enum-values\n  UNSAFE_IFRAME_ATTRS = -910,\n  VIEW_ALREADY_DESTROYED = 911,\n  COMPONENT_ID_COLLISION = -912,\n  IMAGE_PERFORMANCE_WARNING = -913,\n  UNEXPECTED_ZONEJS_PRESENT_IN_ZONELESS_MODE = 914,\n  MISSING_NG_MODULE_DEFINITION = 915,\n  MISSING_DIRECTIVE_DEFINITION = 916,\n  NO_COMPONENT_FACTORY_FOUND = 917,\n  EXTERNAL_RESOURCE_LOADING_FAILED = 918,\n  DEF_TYPE_UNDEFINED = -919,\n  NG_MODULE_ID_NOT_FOUND = 920,\n  DUPLICATE_NG_MODULE_ID = 921,\n  VIEW_DESTROYED_INSERT_ERROR = 922,\n  VIEW_DESTROYED_MOVE_ERROR = 923,\n  // Signal integration errors\n  REQUIRED_INPUT_NO_VALUE = -950,\n  REQUIRED_QUERY_NO_VALUE = -951,\n  REQUIRED_MODEL_NO_VALUE = 952,\n\n  // Output()\n  OUTPUT_REF_DESTROYED = 953,\n\n  // Repeater errors\n  LOOP_TRACK_DUPLICATE_KEYS = -955,\n  LOOP_TRACK_RECREATE = -956,\n\n  // Runtime dependency tracker errors\n  RUNTIME_DEPS_INVALID_IMPORTED_TYPE = 980,\n  RUNTIME_DEPS_ORPHAN_COMPONENT = 981,\n\n  // resource() API errors\n  MUST_PROVIDE_STREAM_OPTION = 990,\n  RESOURCE_COMPLETED_BEFORE_PRODUCING_VALUE = 991,\n\n  // Upper bounds for core runtime errors is 999\n}\n\n/**\n * Class that represents a runtime error.\n * Formats and outputs the error message in a consistent way.\n *\n * Example:\n * ```ts\n *  throw new RuntimeError(\n *    RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED,\n *    ngDevMode && 'Injector has already been destroyed.');\n * ```\n *\n * Note: the `message` argument contains a descriptive error message as a string in development\n * mode (when the `ngDevMode` is defined). In production mode (after tree-shaking pass), the\n * `message` argument becomes `false`, thus we account for it in the typings and the runtime\n * logic.\n */\nexport class RuntimeError<T extends number = RuntimeErrorCode> extends Error {\n  constructor(\n    public code: T,\n    message: null | false | string,\n  ) {\n    super(formatRuntimeError<T>(code, message));\n  }\n}\n\nexport function formatRuntimeErrorCode<T extends number = RuntimeErrorCode>(code: T): string {\n  // Error code might be a negative number, which is a special marker that instructs the logic to\n  // generate a link to the error details page on angular.io.\n  // We also prepend `0` to non-compile-time errors.\n  return `NG0${Math.abs(code)}`;\n}\n\n/**\n * Called to format a runtime error.\n * See additional info on the `message` argument type in the `RuntimeError` class description.\n */\nexport function formatRuntimeError<T extends number = RuntimeErrorCode>(\n  code: T,\n  message: null | false | string,\n): string {\n  const fullCode = formatRuntimeErrorCode(code);\n\n  let errorMessage = `${fullCode}${message ? ': ' + message : ''}`;\n\n  if (ngDevMode && code < 0) {\n    const addPeriodSeparator = !errorMessage.match(/[.,;!?\\n]$/);\n    const separator = addPeriodSeparator ? '.' : '';\n    errorMessage = `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;\n  }\n  return errorMessage;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nconst _global: any = globalThis;\n\n/**\n * Attention: whenever providing a new value, be sure to add an\n * entry into the corresponding `....externs.js` file,\n * so that closure won't use that global for its purposes.\n */\nexport {_global as global};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {global} from './global';\n\ndeclare global {\n  /**\n   * Values of ngDevMode\n   * Depending on the current state of the application, ngDevMode may have one of several values.\n   *\n   * For convenience, the “truthy” value which enables dev mode is also an object which contains\n   * Angular’s performance counters. This is not necessary, but cuts down on boilerplate for the\n   * perf counters.\n   *\n   * ngDevMode may also be set to false. This can happen in one of a few ways:\n   * - The user explicitly sets `window.ngDevMode = false` somewhere in their app.\n   * - The user calls `enableProdMode()`.\n   * - The URL contains a `ngDevMode=false` text.\n   * Finally, ngDevMode may not have been defined at all.\n   */\n  const ngDevMode: null | NgDevModePerfCounters;\n\n  interface NgDevModePerfCounters {\n    hydratedNodes: number;\n    hydratedComponents: number;\n    dehydratedViewsRemoved: number;\n    dehydratedViewsCleanupRuns: number;\n    componentsSkippedHydration: number;\n    deferBlocksWithIncrementalHydration: number;\n  }\n}\n\nfunction ngDevModeResetPerfCounters(): NgDevModePerfCounters {\n  const locationString = typeof location !== 'undefined' ? location.toString() : '';\n  const newCounters: NgDevModePerfCounters = {\n    hydratedNodes: 0,\n    hydratedComponents: 0,\n    dehydratedViewsRemoved: 0,\n    dehydratedViewsCleanupRuns: 0,\n    componentsSkippedHydration: 0,\n    deferBlocksWithIncrementalHydration: 0,\n  };\n\n  // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.\n  const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;\n  if (!allowNgDevModeTrue) {\n    global['ngDevMode'] = false;\n  } else {\n    if (typeof global['ngDevMode'] !== 'object') {\n      global['ngDevMode'] = {};\n    }\n    Object.assign(global['ngDevMode'], newCounters);\n  }\n  return newCounters;\n}\n\n/**\n * This function checks to see if the `ngDevMode` has been set. If yes,\n * then we honor it, otherwise we default to dev mode with additional checks.\n *\n * The idea is that unless we are doing production build where we explicitly\n * set `ngDevMode == false` we should be helping the developer by providing\n * as much early warning and errors as possible.\n *\n * `ɵɵdefineComponent` is guaranteed to have been called before any component template functions\n * (and thus Ivy instructions), so a single initialization there is sufficient to ensure ngDevMode\n * is defined for the entire instruction set.\n *\n * When checking `ngDevMode` on toplevel, always init it before referencing it\n * (e.g. `((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode())`), otherwise you can\n *  get a `ReferenceError` like in https://github.com/angular/angular/issues/31595.\n *\n * Details on possible values for `ngDevMode` can be found on its docstring.\n */\nexport function initNgDevMode(): boolean {\n  // The below checks are to ensure that calling `initNgDevMode` multiple times does not\n  // reset the counters.\n  // If the `ngDevMode` is not an object, then it means we have not created the perf counters\n  // yet.\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (typeof ngDevMode !== 'object' || Object.keys(ngDevMode).length === 0) {\n      ngDevModeResetPerfCounters();\n    }\n    return typeof ngDevMode !== 'undefined' && !!ngDevMode;\n  }\n  return false;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nexport function getClosureSafeProperty<T>(objWithPropertyToExtract: T): string {\n  for (let key in objWithPropertyToExtract) {\n    if (objWithPropertyToExtract[key] === (getClosureSafeProperty as any)) {\n      return key;\n    }\n  }\n  // Cannot change it to `RuntimeError` because the `util` target cannot\n  // circularly depend on the `core` target.\n  throw Error(\n    typeof ngDevMode !== 'undefined' && ngDevMode\n      ? 'Could not find renamed property on target object.'\n      : '',\n  );\n}\n\n/**\n * Sets properties on a target object from a source object, but only if\n * the property doesn't already exist on the target object.\n * @param target The target to set properties on\n * @param source The source of the property keys and values to set\n */\nexport function fillProperties(target: Record<string, unknown>, source: Record<string, unknown>) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nexport function stringify(token: any): string {\n  if (typeof token === 'string') {\n    return token;\n  }\n\n  if (Array.isArray(token)) {\n    return `[${token.map(stringify).join(', ')}]`;\n  }\n\n  if (token == null) {\n    return '' + token;\n  }\n\n  const name = token.overriddenName || token.name;\n  if (name) {\n    return `${name}`;\n  }\n\n  const result = token.toString();\n\n  if (result == null) {\n    return '' + result;\n  }\n\n  const newLineIndex = result.indexOf('\\n');\n  return newLineIndex >= 0 ? result.slice(0, newLineIndex) : result;\n}\n\n/**\n * Concatenates two strings with separator, allocating new strings only when necessary.\n *\n * @param before before string.\n * @param separator separator string.\n * @param after after string.\n * @returns concatenated string.\n */\nexport function concatStringsWithSpace(before: string | null, after: string | null): string {\n  if (!before) return after || '';\n  if (!after) return before;\n  return `${before} ${after}`;\n}\n\n/**\n * Ellipses the string in the middle when longer than the max length\n *\n * @param string\n * @param maxLength of the output string\n * @returns ellipsed string with ... in the middle\n */\nexport function truncateMiddle(str: string, maxLength = 100): string {\n  if (!str || maxLength < 1 || str.length <= maxLength) return str;\n  if (maxLength == 1) return str.substring(0, 1) + '...';\n\n  const halfLimit = Math.round(maxLength / 2);\n  return str.substring(0, halfLimit) + '...' + str.substring(str.length - halfLimit);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Type} from '../interface/type';\nimport {getClosureSafeProperty} from '../util/property';\nimport {stringify} from '../util/stringify';\n\n/**\n * An interface that a function passed into `forwardRef` has to implement.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref_fn'}\n * @publicApi\n */\nexport interface ForwardRefFn {\n  (): any;\n}\n\nconst __forward_ref__ = getClosureSafeProperty({__forward_ref__: getClosureSafeProperty});\n\n/**\n * Allows to refer to references which are not yet defined.\n *\n * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of\n * DI is declared, but not yet defined. It is also used when the `token` which we use when creating\n * a query is not yet defined.\n *\n * `forwardRef` is also used to break circularities in standalone components imports.\n *\n * @usageNotes\n * ### Circular dependency example\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}\n *\n * ### Circular standalone reference import example\n * ```angular-ts\n * @Component({\n *   imports: [ChildComponent],\n *   selector: 'app-parent',\n *   template: `<app-child [hideParent]=\"hideParent()\"/>`,\n * })\n * export class ParentComponent {\n *    hideParent = input.required<boolean>();\n * }\n *\n *\n * @Component({\n *   imports: [forwardRef(() => ParentComponent)],\n *   selector: 'app-child',\n *   template: `\n *    @if(!hideParent()) {\n *       <app-parent/>\n *    }\n *  `,\n * })\n * export class ChildComponent {\n *    hideParent = input.required<boolean>();\n * }\n * ```\n * @see [Resolve circular dependencies with a forward reference](guide/di/di-in-action#resolve-circular-dependencies-with-a-forward-reference)\n * @publicApi\n */\nexport function forwardRef(forwardRefFn: ForwardRefFn): Type<any> {\n  (<any>forwardRefFn).__forward_ref__ = forwardRef;\n  (<any>forwardRefFn).toString = function () {\n    return stringify(this());\n  };\n  return <Type<any>>(<any>forwardRefFn);\n}\n\n/**\n * Lazily retrieves the reference value from a forwardRef.\n *\n * Acts as the identity function when given a non-forward-ref value.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}\n *\n * @see {@link forwardRef}\n * @publicApi\n */\nexport function resolveForwardRef<T>(type: T): T {\n  return isForwardRef(type) ? type() : type;\n}\n\n/** Checks whether a function is wrapped by a `forwardRef`. */\nexport function isForwardRef(fn: any): fn is () => any {\n  return (\n    typeof fn === 'function' &&\n    fn.hasOwnProperty(__forward_ref__) &&\n    fn.__forward_ref__ === forwardRef\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n// The functions in this file verify that the assumptions we are making\n// about state in an instruction are correct before implementing any logic.\n// They are meant only to be called in dev mode as sanity checks.\n\nimport {getActiveConsumer} from '../../primitives/signals';\n\nimport {stringify} from './stringify';\n\nexport function assertNumber(actual: any, msg: string): asserts actual is number {\n  if (!(typeof actual === 'number')) {\n    throwError(msg, typeof actual, 'number', '===');\n  }\n}\n\nexport function assertNumberInRange(\n  actual: any,\n  minInclusive: number,\n  maxInclusive: number,\n): asserts actual is number {\n  assertNumber(actual, 'Expected a number');\n  assertLessThanOrEqual(actual, maxInclusive, 'Expected number to be less than or equal to');\n  assertGreaterThanOrEqual(actual, minInclusive, 'Expected number to be greater than or equal to');\n}\n\nexport function assertString(actual: any, msg: string): asserts actual is string {\n  if (!(typeof actual === 'string')) {\n    throwError(msg, actual === null ? 'null' : typeof actual, 'string', '===');\n  }\n}\n\nexport function assertFunction(actual: any, msg: string): asserts actual is Function {\n  if (!(typeof actual === 'function')) {\n    throwError(msg, actual === null ? 'null' : typeof actual, 'function', '===');\n  }\n}\n\nexport function assertEqual<T>(actual: T, expected: T, msg: string) {\n  if (!(actual == expected)) {\n    throwError(msg, actual, expected, '==');\n  }\n}\n\nexport function assertNotEqual<T>(actual: T, expected: T, msg: string): asserts actual is T {\n  if (!(actual != expected)) {\n    throwError(msg, actual, expected, '!=');\n  }\n}\n\nexport function assertSame<T>(actual: T, expected: T, msg: string): asserts actual is T {\n  if (!(actual === expected)) {\n    throwError(msg, actual, expected, '===');\n  }\n}\n\nexport function assertNotSame<T>(actual: T, expected: T, msg: string) {\n  if (!(actual !== expected)) {\n    throwError(msg, actual, expected, '!==');\n  }\n}\n\nexport function assertLessThan<T>(actual: T, expected: T, msg: string): asserts actual is T {\n  if (!(actual < expected)) {\n    throwError(msg, actual, expected, '<');\n  }\n}\n\nexport function assertLessThanOrEqual<T>(actual: T, expected: T, msg: string): asserts actual is T {\n  if (!(actual <= expected)) {\n    throwError(msg, actual, expected, '<=');\n  }\n}\n\nexport function assertGreaterThan<T>(actual: T, expected: T, msg: string): asserts actual is T {\n  if (!(actual > expected)) {\n    throwError(msg, actual, expected, '>');\n  }\n}\n\nexport function assertGreaterThanOrEqual<T>(\n  actual: T,\n  expected: T,\n  msg: string,\n): asserts actual is T {\n  if (!(actual >= expected)) {\n    throwError(msg, actual, expected, '>=');\n  }\n}\n\nexport function assertNotDefined<T>(actual: T, msg: string) {\n  if (actual != null) {\n    throwError(msg, actual, null, '==');\n  }\n}\n\nexport function assertDefined<T>(actual: T | null | undefined, msg: string): asserts actual is T {\n  if (actual == null) {\n    throwError(msg, actual, null, '!=');\n  }\n}\n\nexport function throwError(msg: string): never;\nexport function throwError(msg: string, actual: any, expected: any, comparison: string): never;\nexport function throwError(msg: string, actual?: any, expected?: any, comparison?: string): never {\n  throw new Error(\n    `ASSERTION ERROR: ${msg}` +\n      (comparison == null ? '' : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`),\n  );\n}\n\nexport function assertDomNode(node: any): asserts node is Node {\n  if (!(node instanceof Node)) {\n    throwError(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);\n  }\n}\n\nexport function assertElement(node: any): asserts node is Element {\n  if (!(node instanceof Element)) {\n    throwError(`The provided value must be an element but got ${stringify(node)}`);\n  }\n}\n\nexport function assertIndexInRange(arr: any[], index: number) {\n  assertDefined(arr, 'Array must be defined.');\n  const maxLen = arr.length;\n  if (index < 0 || index >= maxLen) {\n    throwError(`Index expected to be less than ${maxLen} but got ${index}`);\n  }\n}\n\nexport function assertOneOf(value: any, ...validValues: any[]) {\n  if (validValues.indexOf(value) !== -1) return true;\n  throwError(\n    `Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`,\n  );\n}\n\nexport function assertNotReactive(fn: string): void {\n  if (getActiveConsumer() !== null) {\n    throwError(`${fn}() should never be called in a reactive context.`);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Type} from '../../interface/type';\nimport {getClosureSafeProperty} from '../../util/property';\n\nimport {\n  ClassProvider,\n  ConstructorProvider,\n  EnvironmentProviders,\n  ExistingProvider,\n  FactoryProvider,\n  StaticClassProvider,\n  ValueProvider,\n} from './provider';\n\n/**\n * Information about how a type or `InjectionToken` interfaces with the DI system.\n *\n * At a minimum, this includes a `factory` which defines how to create the given type `T`, possibly\n * requesting injection of other types if necessary.\n *\n * Optionally, a `providedIn` parameter specifies that the given type belongs to a particular\n * `Injector`, `NgModule`, or a special scope (e.g. `'root'`). A value of `null` indicates\n * that the injectable does not belong to any scope.\n *\n * @codeGenApi\n * @publicApi The ViewEngine compiler emits code with this type for injectables. This code is\n *   deployed to npm, and should be treated as public api.\n\n */\nexport interface ɵɵInjectableDeclaration<T> {\n  /**\n   * Specifies that the given type belongs to a particular injector:\n   * - `InjectorType` such as `NgModule`,\n   * - `'root'` the root injector\n   * - `'any'` all injectors.\n   * - `null`, does not belong to any injector. Must be explicitly listed in the injector\n   *   `providers`.\n   */\n  providedIn: InjectorType<any> | 'root' | 'platform' | 'any' | 'environment' | null;\n\n  /**\n   * The token to which this definition belongs.\n   *\n   * Note that this may not be the same as the type that the `factory` will create.\n   */\n  token: unknown;\n\n  /**\n   * Factory method to execute to create an instance of the injectable.\n   */\n  factory: (t?: Type<any>) => T;\n\n  /**\n   * In a case of no explicit injector, a location where the instance of the injectable is stored.\n   */\n  value: T | undefined;\n}\n\n/**\n * Information about the providers to be included in an `Injector` as well as how the given type\n * which carries the information should be created by the DI system.\n *\n * An `InjectorDef` can import other types which have `InjectorDefs`, forming a deep nested\n * structure of providers with a defined priority (identically to how `NgModule`s also have\n * an import/dependency structure).\n *\n * NOTE: This is a private type and should not be exported\n *\n * @codeGenApi\n */\nexport interface ɵɵInjectorDef<T> {\n  // TODO(alxhub): Narrow down the type here once decorators properly change the return type of the\n  // class they are decorating (to add the ɵprov property for example).\n  providers: (\n    | Type<any>\n    | ValueProvider\n    | ExistingProvider\n    | FactoryProvider\n    | ConstructorProvider\n    | StaticClassProvider\n    | ClassProvider\n    | EnvironmentProviders\n    | any[]\n  )[];\n\n  imports: (InjectorType<any> | InjectorTypeWithProviders<any>)[];\n}\n\n/**\n * A `Type` which has a `ɵprov: ɵɵInjectableDeclaration` static field.\n *\n * `InjectableType`s contain their own Dependency Injection metadata and are usable in an\n * `InjectorDef`-based `StaticInjector`.\n *\n * @publicApi\n */\nexport interface InjectableType<T> extends Type<T> {\n  /**\n   * Opaque type whose structure is highly version dependent. Do not rely on any properties.\n   */\n  ɵprov: unknown;\n}\n\n/**\n * A type which has an `InjectorDef` static field.\n *\n * `InjectorTypes` can be used to configure a `StaticInjector`.\n *\n * This is an opaque type whose structure is highly version dependent. Do not rely on any\n * properties.\n *\n * @publicApi\n */\nexport interface InjectorType<T> extends Type<T> {\n  ɵfac?: unknown;\n  ɵinj: unknown;\n}\n\n/**\n * Describes the `InjectorDef` equivalent of a `ModuleWithProviders`, an `InjectorType` with an\n * associated array of providers.\n *\n * Objects of this type can be listed in the imports section of an `InjectorDef`.\n *\n * NOTE: This is a private type and should not be exported\n */\nexport interface InjectorTypeWithProviders<T> {\n  ngModule: InjectorType<T>;\n  providers?: (\n    | Type<any>\n    | ValueProvider\n    | ExistingProvider\n    | FactoryProvider\n    | ConstructorProvider\n    | StaticClassProvider\n    | ClassProvider\n    | EnvironmentProviders\n    | any[]\n  )[];\n}\n\n/**\n * Construct an injectable definition which defines how a token will be constructed by the DI\n * system, and in which injectors (if any) it will be available.\n *\n * This should be assigned to a static `ɵprov` field on a type, which will then be an\n * `InjectableType`.\n *\n * Options:\n * * `providedIn` determines which injectors will include the injectable, by either associating it\n *   with an `@NgModule` or other `InjectorType`, or by specifying that this injectable should be\n *   provided in the `'root'` injector, which will be the application-level injector in most apps.\n * * `factory` gives the zero argument function which will create an instance of the injectable.\n *   The factory can call [`inject`](api/core/inject) to access the `Injector` and request injection\n * of dependencies.\n *\n * @codeGenApi\n * @publicApi This instruction has been emitted by ViewEngine for some time and is deployed to npm.\n */\nexport function ɵɵdefineInjectable<T>(opts: {\n  token: unknown;\n  providedIn?: Type<any> | 'root' | 'platform' | 'any' | 'environment' | null;\n  factory: () => T;\n}): unknown {\n  return {\n    token: opts.token,\n    providedIn: (opts.providedIn as any) || null,\n    factory: opts.factory,\n    value: undefined,\n  } as ɵɵInjectableDeclaration<T>;\n}\n\n/**\n * Construct an `InjectorDef` which configures an injector.\n *\n * This should be assigned to a static injector def (`ɵinj`) field on a type, which will then be an\n * `InjectorType`.\n *\n * Options:\n *\n * * `providers`: an optional array of providers to add to the injector. Each provider must\n *   either have a factory or point to a type which has a `ɵprov` static property (the\n *   type must be an `InjectableType`).\n * * `imports`: an optional array of imports of other `InjectorType`s or `InjectorTypeWithModule`s\n *   whose providers will also be added to the injector. Locally provided types will override\n *   providers from imports.\n *\n * @codeGenApi\n */\nexport function ɵɵdefineInjector(options: {providers?: any[]; imports?: any[]}): unknown {\n  return {providers: options.providers || [], imports: options.imports || []};\n}\n\n/**\n * Read the injectable def (`ɵprov`) for `type` in a way which is immune to accidentally reading\n * inherited value.\n *\n * @param type A type which may have its own (non-inherited) `ɵprov`.\n */\nexport function getInjectableDef<T>(type: any): ɵɵInjectableDeclaration<T> | null {\n  return getOwnDefinition(type, NG_PROV_DEF);\n}\n\nexport function isInjectable(type: any): boolean {\n  return getInjectableDef(type) !== null;\n}\n\n/**\n * Return definition only if it is defined directly on `type` and is not inherited from a base\n * class of `type`.\n */\nfunction getOwnDefinition<T>(type: any, field: string): ɵɵInjectableDeclaration<T> | null {\n  // if the ɵprov prop exist but is undefined we still want to return null\n  return (type.hasOwnProperty(field) && type[field]) || null;\n}\n\n/**\n * Read the injectable def (`ɵprov`) for `type` or read the `ɵprov` from one of its ancestors.\n *\n * @param type A type which may have `ɵprov`, via inheritance.\n *\n * @deprecated Will be removed in a future version of Angular, where an error will occur in the\n *     scenario if we find the `ɵprov` on an ancestor only.\n */\nexport function getInheritedInjectableDef<T>(type: any): ɵɵInjectableDeclaration<T> | null {\n  // if the ɵprov prop exist but is undefined we still want to return null\n  const def = type?.[NG_PROV_DEF] ?? null;\n\n  if (def) {\n    ngDevMode &&\n      console.warn(\n        `DEPRECATED: DI is instantiating a token \"${type.name}\" that inherits its @Injectable decorator but does not provide one itself.\\n` +\n          `This will become an error in a future version of Angular. Please add @Injectable() to the \"${type.name}\" class.`,\n      );\n    return def;\n  } else {\n    return null;\n  }\n}\n\n/**\n * Read the injector def type in a way which is immune to accidentally reading inherited value.\n *\n * @param type type which may have an injector def (`ɵinj`)\n */\nexport function getInjectorDef<T>(type: any): ɵɵInjectorDef<T> | null {\n  return type && type.hasOwnProperty(NG_INJ_DEF) ? (type as any)[NG_INJ_DEF] : null;\n}\n\nexport const NG_PROV_DEF: string = getClosureSafeProperty({ɵprov: getClosureSafeProperty});\nexport const NG_INJ_DEF: string = getClosureSafeProperty({ɵinj: getClosureSafeProperty});\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Type} from '../interface/type';\nimport {assertLessThan} from '../util/assert';\n\nimport {ɵɵdefineInjectable} from './interface/defs';\n\n/**\n * Creates a token that can be used in a DI Provider.\n *\n * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a\n * runtime representation) such as when injecting an interface, callable type, array or\n * parameterized type.\n *\n * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by\n * the `Injector`. This provides an additional level of type safety.\n *\n * <div class=\"docs-alert docs-alert-helpful\">\n *\n * **Important Note**: Ensure that you use the same instance of the `InjectionToken` in both the\n * provider and the injection call. Creating a new instance of `InjectionToken` in different places,\n * even with the same description, will be treated as different tokens by Angular's DI system,\n * leading to a `NullInjectorError`.\n *\n * </div>\n *\n * {@example injection-token/src/main.ts region='InjectionToken'}\n *\n * When creating an `InjectionToken`, you can optionally specify a factory function which returns\n * (possibly by creating) a default value of the parameterized type `T`. This sets up the\n * `InjectionToken` using this factory as a provider as if it was defined explicitly in the\n * application's root injector. If the factory function, which takes zero arguments, needs to inject\n * dependencies, it can do so using the [`inject`](api/core/inject) function.\n * As you can see in the Tree-shakable InjectionToken example below.\n *\n * Additionally, if a `factory` is specified you can also specify the `providedIn` option, which\n * overrides the above behavior and marks the token as belonging to a particular `@NgModule` (note:\n * this option is now deprecated). As mentioned above, `'root'` is the default value for\n * `providedIn`.\n *\n * The `providedIn: NgModule` and `providedIn: 'any'` options are deprecated.\n *\n * @usageNotes\n * ### Basic Examples\n *\n * ### Plain InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='InjectionToken'}\n *\n * ### Tree-shakable InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}\n *\n *\n * @see [What is an InjectionToken?](guide/di/defining-dependency-providers#what-is-an-injectiontoken)\n *\n * @publicApi\n */\nexport class InjectionToken<T> {\n  /** @internal */\n  readonly ngMetadataName = 'InjectionToken';\n\n  readonly ɵprov: unknown;\n\n  /**\n   * @deprecated The `providedIn: NgModule` or `providedIn:'any'` options are deprecated. Please use the other signature.\n   */\n  constructor(\n    _desc: string,\n    options: {\n      providedIn: Type<any> | 'any';\n      factory: () => T;\n    },\n  );\n\n  /**\n   * @param _desc   Description for the token,\n   *                used only for debugging purposes,\n   *                it should but does not need to be unique\n   * @param options Options for the token's usage, as described above\n   */\n  constructor(\n    _desc: string,\n    options?: {\n      providedIn?: Type<any> | 'root' | 'platform' | 'any' | null;\n      factory: () => T;\n    },\n  );\n\n  constructor(\n    protected _desc: string,\n    options?: {\n      providedIn?: Type<any> | 'root' | 'platform' | 'any' | null;\n      factory: () => T;\n    },\n  ) {\n    this.ɵprov = undefined;\n    if (typeof options == 'number') {\n      (typeof ngDevMode === 'undefined' || ngDevMode) &&\n        assertLessThan(options, 0, 'Only negative numbers are supported here');\n      // This is a special hack to assign __NG_ELEMENT_ID__ to this instance.\n      // See `InjectorMarkers`\n      (this as any).__NG_ELEMENT_ID__ = options;\n    } else if (options !== undefined) {\n      this.ɵprov = ɵɵdefineInjectable({\n        token: this,\n        providedIn: options.providedIn || 'root',\n        factory: options.factory,\n      });\n    }\n  }\n\n  /**\n   * @internal\n   */\n  get multi(): InjectionToken<Array<T>> {\n    return this as InjectionToken<Array<T>>;\n  }\n\n  toString(): string {\n    return `InjectionToken ${this._desc}`;\n  }\n}\n\nexport interface InjectableDefToken<T> extends InjectionToken<T> {\n  ɵprov: unknown;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {FactoryProvider, ProviderToken} from '../../di';\nimport {resolveForwardRef} from '../../di/forward_ref';\nimport {InjectionToken} from '../../di/injection_token';\nimport type {Injector} from '../../di/injector';\nimport {InjectOptions, InternalInjectFlags} from '../../di/interface/injector';\nimport type {SingleProvider} from '../../di/provider_collection';\nimport {Type} from '../../interface/type';\nimport {throwError} from '../../util/assert';\nimport type {TNode} from '../interfaces/node';\nimport type {LView} from '../interfaces/view';\nimport type {AfterRenderPhaseEffectNode} from '../reactivity/after_render_effect';\nimport type {EffectRefImpl} from '../reactivity/effect';\n\n/**\n * An enum describing the types of events that can be emitted from the injector profiler\n */\nexport const enum InjectorProfilerEventType {\n  /**\n   * Emits when a service is injected.\n   */\n  Inject,\n\n  /**\n   * Emits when an Angular class instance is created by an injector.\n   */\n  InstanceCreatedByInjector,\n\n  /**\n   * Emits when an injector configures a provider.\n   */\n  ProviderConfigured,\n\n  /**\n   * Emits when an effect is created.\n   */\n  EffectCreated,\n\n  /**\n   * Emits when an after render effect phase is created.\n   */\n  AfterRenderEffectPhaseCreated,\n\n  /**\n   * Emits when an Angular DI system is about to create an instance corresponding to a given token.\n   */\n  InjectorToCreateInstanceEvent,\n}\n\n/**\n * An object that defines an injection context for the injector profiler.\n */\nexport interface InjectorProfilerContext {\n  /**\n   *  The Injector that service is being injected into.\n   *      - Example: if ModuleA --provides--> ServiceA --injects--> ServiceB\n   *                 then inject(ServiceB) in ServiceA has ModuleA as an injector context\n   */\n  injector: Injector;\n\n  /**\n   *  The class where the constructor that is calling `inject` is located\n   *      - Example: if ModuleA --provides--> ServiceA --injects--> ServiceB\n   *                 then inject(ServiceB) in ServiceA has ServiceA as a construction context\n   */\n  token: Type<unknown> | null;\n}\n\nexport interface InjectedServiceEvent {\n  type: InjectorProfilerEventType.Inject;\n  context: InjectorProfilerContext;\n  service: InjectedService;\n}\n\nexport interface InjectorToCreateInstanceEvent {\n  type: InjectorProfilerEventType.InjectorToCreateInstanceEvent;\n  context: InjectorProfilerContext;\n  token: ProviderToken<unknown>;\n}\n\nexport interface InjectorCreatedInstanceEvent {\n  type: InjectorProfilerEventType.InstanceCreatedByInjector;\n  context: InjectorProfilerContext;\n  instance: InjectorCreatedInstance;\n}\n\nexport interface ProviderConfiguredEvent {\n  type: InjectorProfilerEventType.ProviderConfigured;\n  context: InjectorProfilerContext;\n  providerRecord: ProviderRecord;\n}\n\nexport interface EffectCreatedEvent {\n  type: InjectorProfilerEventType.EffectCreated;\n  context: InjectorProfilerContext;\n  effect: EffectRefImpl;\n}\n\nexport interface AfterRenderEffectPhaseCreatedEvent {\n  type: InjectorProfilerEventType.AfterRenderEffectPhaseCreated;\n  context: InjectorProfilerContext;\n  effectPhase: AfterRenderPhaseEffectNode;\n}\n\n/**\n * An object representing an event that is emitted through the injector profiler\n */\n\nexport type InjectorProfilerEvent =\n  | InjectedServiceEvent\n  | InjectorToCreateInstanceEvent\n  | InjectorCreatedInstanceEvent\n  | ProviderConfiguredEvent\n  | EffectCreatedEvent\n  | AfterRenderEffectPhaseCreatedEvent;\n\n/**\n * An object that contains information about a provider that has been configured\n *\n * TODO: rename to indicate that it is a debug structure eg. ProviderDebugInfo.\n */\nexport interface ProviderRecord {\n  /**\n   * DI token that this provider is configuring\n   */\n  token: Type<unknown> | InjectionToken<unknown>;\n\n  /**\n   * Determines if provider is configured as view provider.\n   */\n  isViewProvider: boolean;\n\n  /**\n   * The raw provider associated with this ProviderRecord.\n   */\n  provider: SingleProvider;\n\n  /**\n   * The path of DI containers that were followed to import this provider\n   */\n  importPath?: Type<unknown>[];\n}\n\n/**\n * An object that contains information about a value that has been constructed within an injector\n */\nexport interface InjectorCreatedInstance {\n  /**\n   * Value of the created instance\n   */\n  value: unknown;\n}\n\n/**\n * An object that contains information a service that has been injected within an\n * InjectorProfilerContext\n */\nexport interface InjectedService {\n  /**\n   * DI token of the Service that is injected\n   */\n  token?: Type<unknown> | InjectionToken<unknown>;\n\n  /**\n   * Value of the injected service\n   */\n  value: unknown;\n\n  /**\n   * Flags that this service was injected with\n   */\n  flags?: InternalInjectFlags | InjectOptions;\n\n  /**\n   * Injector that this service was provided in.\n   */\n  providedIn?: Injector;\n\n  /**\n   * In NodeInjectors, the LView and TNode that serviced this injection.\n   */\n  injectedIn?: {lView: LView; tNode: TNode};\n}\n\nexport interface InjectorProfiler {\n  (event: InjectorProfilerEvent): void;\n}\n\nlet _injectorProfilerContext: InjectorProfilerContext;\nexport function getInjectorProfilerContext() {\n  !ngDevMode && throwError('getInjectorProfilerContext should never be called in production mode');\n  return _injectorProfilerContext;\n}\n\nexport function setInjectorProfilerContext(context: InjectorProfilerContext) {\n  !ngDevMode && throwError('setInjectorProfilerContext should never be called in production mode');\n\n  const previous = _injectorProfilerContext;\n  _injectorProfilerContext = context;\n  return previous;\n}\n\nconst injectorProfilerCallbacks: InjectorProfiler[] = [];\n\nconst NOOP_PROFILER_REMOVAL = () => {};\n\nfunction removeProfiler(profiler: InjectorProfiler) {\n  const profilerIdx = injectorProfilerCallbacks.indexOf(profiler);\n  if (profilerIdx !== -1) {\n    injectorProfilerCallbacks.splice(profilerIdx, 1);\n  }\n}\n\n/**\n * Adds a callback function which will be invoked during certain DI events within the\n * runtime (for example: injecting services, creating injectable instances, configuring providers).\n * Multiple profiler callbacks can be set: in this case profiling events are\n * reported to every registered callback.\n *\n * Warning: this function is *INTERNAL* and should not be relied upon in application's code.\n * The contract of the function might be changed in any release and/or the function can be removed\n * completely.\n *\n * @param profiler function provided by the caller or null value to disable profiling.\n * @returns a cleanup function that, when invoked, removes a given profiler callback.\n */\nexport function setInjectorProfiler(injectorProfiler: InjectorProfiler | null): () => void {\n  !ngDevMode && throwError('setInjectorProfiler should never be called in production mode');\n\n  if (injectorProfiler !== null) {\n    if (!injectorProfilerCallbacks.includes(injectorProfiler)) {\n      injectorProfilerCallbacks.push(injectorProfiler);\n    }\n    return () => removeProfiler(injectorProfiler);\n  } else {\n    injectorProfilerCallbacks.length = 0;\n    return NOOP_PROFILER_REMOVAL;\n  }\n}\n\n/**\n * Injector profiler function which emits on DI events executed by the runtime.\n *\n * @param event InjectorProfilerEvent corresponding to the DI event being emitted\n */\nexport function injectorProfiler(event: InjectorProfilerEvent): void {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n\n  for (let i = 0; i < injectorProfilerCallbacks.length; i++) {\n    const injectorProfilerCallback = injectorProfilerCallbacks[i];\n    injectorProfilerCallback(event);\n  }\n}\n\n/**\n * Emits an InjectorProfilerEventType.ProviderConfigured to the injector profiler. The data in the\n * emitted event includes the raw provider, as well as the token that provider is providing.\n *\n * @param eventProvider A provider object\n */\nexport function emitProviderConfiguredEvent(\n  eventProvider: SingleProvider,\n  isViewProvider: boolean = false,\n): void {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n\n  let token;\n  // if the provider is a TypeProvider (typeof provider is function) then the token is the\n  // provider itself\n  if (typeof eventProvider === 'function') {\n    token = eventProvider;\n  }\n  // if the provider is an injection token, then the token is the injection token.\n  else if (eventProvider instanceof InjectionToken) {\n    token = eventProvider;\n  }\n  // in all other cases we can access the token via the `provide` property of the provider\n  else {\n    token = resolveForwardRef(eventProvider.provide);\n  }\n\n  let provider = eventProvider;\n  // Injection tokens may define their own default provider which gets attached to the token itself\n  // as `ɵprov`. In this case, we want to emit the provider that is attached to the token, not the\n  // token itself.\n  if (eventProvider instanceof InjectionToken) {\n    provider = (eventProvider.ɵprov as FactoryProvider) || eventProvider;\n  }\n\n  injectorProfiler({\n    type: InjectorProfilerEventType.ProviderConfigured,\n    context: getInjectorProfilerContext(),\n    providerRecord: {token, provider, isViewProvider},\n  });\n}\n\n/**\n * Emits an event to the injector profiler when an instance corresponding to a given token is about to be created be an injector. Note that\n * the injector associated with this emission can be accessed by using getDebugInjectContext()\n *\n * @param instance an object created by an injector\n */\nexport function emitInjectorToCreateInstanceEvent(token: ProviderToken<unknown>): void {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n\n  injectorProfiler({\n    type: InjectorProfilerEventType.InjectorToCreateInstanceEvent,\n    context: getInjectorProfilerContext(),\n    token: token,\n  });\n}\n\n/**\n * Emits an event to the injector profiler with the instance that was created. Note that\n * the injector associated with this emission can be accessed by using getDebugInjectContext()\n *\n * @param instance an object created by an injector\n */\nexport function emitInstanceCreatedByInjectorEvent(instance: unknown): void {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n\n  injectorProfiler({\n    type: InjectorProfilerEventType.InstanceCreatedByInjector,\n    context: getInjectorProfilerContext(),\n    instance: {value: instance},\n  });\n}\n\n/**\n * @param token DI token associated with injected service\n * @param value the instance of the injected service (i.e the result of `inject(token)`)\n * @param flags the flags that the token was injected with\n */\nexport function emitInjectEvent(\n  token: Type<unknown>,\n  value: unknown,\n  flags: InternalInjectFlags,\n): void {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n\n  injectorProfiler({\n    type: InjectorProfilerEventType.Inject,\n    context: getInjectorProfilerContext(),\n    service: {token, value, flags},\n  });\n}\n\nexport function emitEffectCreatedEvent(effect: EffectRefImpl): void {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n\n  injectorProfiler({\n    type: InjectorProfilerEventType.EffectCreated,\n    context: getInjectorProfilerContext(),\n    effect,\n  });\n}\n\nexport function emitAfterRenderEffectPhaseCreatedEvent(\n  effectPhase: AfterRenderPhaseEffectNode,\n): void {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n\n  injectorProfiler({\n    type: InjectorProfilerEventType.AfterRenderEffectPhaseCreated,\n    context: getInjectorProfilerContext(),\n    effectPhase,\n  });\n}\n\nexport function runInInjectorProfilerContext(\n  injector: Injector,\n  token: Type<unknown>,\n  callback: () => void,\n): void {\n  !ngDevMode &&\n    throwError('runInInjectorProfilerContext should never be called in production mode');\n\n  const prevInjectContext = setInjectorProfilerContext({injector, token});\n  try {\n    callback();\n  } finally {\n    setInjectorProfilerContext(prevInjectContext);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Type} from '../../interface/type';\n\n/**\n * Configures the `Injector` to return a value for a token.\n * Base for `ValueProvider` decorator.\n *\n * @publicApi\n */\nexport interface ValueSansProvider {\n  /**\n   * The value to inject.\n   */\n  useValue: any;\n}\n\n/**\n * Configures the `Injector` to return a value for a token.\n * @see [Dependency Injection Guide](guide/di/dependency-injection)\n *\n * @usageNotes\n *\n * ### Example\n *\n * {@example core/di/ts/provider_spec.ts region='ValueProvider'}\n *\n * ### Multi-value example\n *\n * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}\n *\n * @publicApi\n */\nexport interface ValueProvider extends ValueSansProvider {\n  /**\n   * An injection token. Typically an instance of `Type` or `InjectionToken`, but can be `any`.\n   */\n  provide: any;\n\n  /**\n   * When true, injector returns an array of instances. This is useful to allow multiple\n   * providers spread across many files to provide configuration information to a common token.\n   */\n  multi?: boolean;\n}\n\n/**\n * Configures the `Injector` to return an instance of `useClass` for a token.\n * Base for `StaticClassProvider` decorator.\n *\n * @publicApi\n */\nexport interface StaticClassSansProvider {\n  /**\n   * An optional class to instantiate for the `token`. By default, the `provide`\n   * class is instantiated.\n   */\n  useClass: Type<any>;\n\n  /**\n   * A list of `token`s to be resolved by the injector. The list of values is then\n   * used as arguments to the `useClass` constructor.\n   */\n  deps: any[];\n}\n\n/**\n * Configures the `Injector` to return an instance of `useClass` for a token.\n * @see [Dependency Injection Guide](guide/di/dependency-injection)\n *\n * @usageNotes\n *\n * {@example core/di/ts/provider_spec.ts region='StaticClassProvider'}\n *\n * Note that following two providers are not equal:\n *\n * {@example core/di/ts/provider_spec.ts region='StaticClassProviderDifference'}\n *\n * ### Multi-value example\n *\n * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}\n *\n * @publicApi\n */\nexport interface StaticClassProvider extends StaticClassSansProvider {\n  /**\n   * An injection token. Typically an instance of `Type` or `InjectionToken`, but can be `any`.\n   */\n  provide: any;\n\n  /**\n   * When true, injector returns an array of instances. This is useful to allow multiple\n   * providers spread across many files to provide configuration information to a common token.\n   */\n  multi?: boolean;\n}\n\n/**\n * Configures the `Injector` to return an instance of a token.\n *\n * @see [Dependency Injection Guide](guide/di/dependency-injection)\n *\n * @usageNotes\n *\n * ```ts\n * @Injectable(SomeModule, {deps: []})\n * class MyService {}\n * ```\n *\n * @publicApi\n */\nexport interface ConstructorSansProvider {\n  /**\n   * A list of `token`s to be resolved by the injector.\n   */\n  deps?: any[];\n}\n\n/**\n * Configures the `Injector` to return an instance of a token.\n *\n * @see [Dependency Injection Guide](guide/di/dependency-injection)\n *\n * @usageNotes\n *\n * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\n *\n * ### Multi-value example\n *\n * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}\n *\n * @publicApi\n */\nexport interface ConstructorProvider extends ConstructorSansProvider {\n  /**\n   * An injection token. Typically an instance of `Type` or `InjectionToken`, but can be `any`.\n   */\n  provide: Type<any>;\n\n  /**\n   * When true, injector returns an array of instances. This is useful to allow multiple\n   * providers spread across many files to provide configuration information to a common token.\n   */\n  multi?: boolean;\n}\n\n/**\n * Configures the `Injector` to return a value of another `useExisting` token.\n *\n * @see {@link ExistingProvider}\n * @see [Dependency Injection Guide](guide/di/dependency-injection)\n *\n * @publicApi\n */\nexport interface ExistingSansProvider {\n  /**\n   * Existing `token` to return. (Equivalent to `injector.get(useExisting)`)\n   */\n  useExisting: any;\n}\n\n/**\n * Configures the `Injector` to return a value of another `useExisting` token.\n *\n * @see [Dependency Injection Guide](guide/di/dependency-injection)\n *\n * @usageNotes\n *\n * {@example core/di/ts/provider_spec.ts region='ExistingProvider'}\n *\n * ### Multi-value example\n *\n * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}\n *\n * @publicApi\n */\nexport interface ExistingProvider extends ExistingSansProvider {\n  /**\n   * An injection token. Typically an instance of `Type` or `InjectionToken`, but can be `any`.\n   */\n  provide: any;\n\n  /**\n   * When true, injector returns an array of instances. This is useful to allow multiple\n   * providers spread across many files to provide configuration information to a common token.\n   */\n  multi?: boolean;\n}\n\n/**\n * Configures the `Injector` to return a value by invoking a `useFactory` function.\n *\n * @see {@link FactoryProvider}\n * @see [Dependency Injection Guide](guide/di/dependency-injection)\n *\n * @publicApi\n */\nexport interface FactorySansProvider {\n  /**\n   * A function to invoke to create a value for this `token`. The function is invoked with\n   * resolved values of `token`s in the `deps` field.\n   */\n  useFactory: Function;\n\n  /**\n   * A list of `token`s to be resolved by the injector. The list of values is then\n   * used as arguments to the `useFactory` function.\n   */\n  deps?: any[];\n}\n\n/**\n * Configures the `Injector` to return a value by invoking a `useFactory` function.\n * @see [Dependency Injection Guide](guide/di/dependency-injection)\n *\n * @usageNotes\n *\n * {@example core/di/ts/provider_spec.ts region='FactoryProvider'}\n *\n * Dependencies can also be marked as optional:\n *\n * {@example core/di/ts/provider_spec.ts region='FactoryProviderOptionalDeps'}\n *\n * ### Multi-value example\n *\n * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}\n *\n * @publicApi\n */\nexport interface FactoryProvider extends FactorySansProvider {\n  /**\n   * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).\n   */\n  provide: any;\n\n  /**\n   * When true, injector returns an array of instances. This is useful to allow multiple\n   * providers spread across many files to provide configuration information to a common token.\n   */\n  multi?: boolean;\n}\n\n/**\n * Describes how an `Injector` should be configured as static (that is, without reflection).\n * A static provider provides tokens to an injector for various types of dependencies.\n *\n * @see {@link Injector.create()}\n * @see [Dependency Injection Guide](guide/di/dependency-injection-providers).\n *\n * @publicApi\n */\nexport type StaticProvider =\n  | ValueProvider\n  | ExistingProvider\n  | StaticClassProvider\n  | ConstructorProvider\n  | FactoryProvider\n  | any[];\n\n/**\n * Configures the `Injector` to return an instance of `Type` when `Type' is used as the token.\n *\n * Create an instance by invoking the `new` operator and supplying additional arguments.\n * This form is a short form of `TypeProvider`;\n *\n * For more details, see the [\"Dependency Injection Guide\"](guide/di/dependency-injection.\n *\n * @usageNotes\n *\n * {@example core/di/ts/provider_spec.ts region='TypeProvider'}\n *\n * @publicApi\n */\nexport interface TypeProvider extends Type<any> {}\n\n/**\n * Configures the `Injector` to return a value by invoking a `useClass` function.\n * Base for `ClassProvider` decorator.\n *\n * @see [Dependency Injection Guide](guide/di/dependency-injection)\n *\n * @publicApi\n */\nexport interface ClassSansProvider {\n  /**\n   * Class to instantiate for the `token`.\n   */\n  useClass: Type<any>;\n}\n\n/**\n * Configures the `Injector` to return an instance of `useClass` for a token.\n * @see [Dependency Injection Guide](guide/di/dependency-injection)\n *\n * @usageNotes\n *\n * {@example core/di/ts/provider_spec.ts region='ClassProvider'}\n *\n * Note that following two providers are not equal:\n *\n * {@example core/di/ts/provider_spec.ts region='ClassProviderDifference'}\n *\n * ### Multi-value example\n *\n * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}\n *\n * @publicApi\n */\nexport interface ClassProvider extends ClassSansProvider {\n  /**\n   * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).\n   */\n  provide: any;\n\n  /**\n   * When true, injector returns an array of instances. This is useful to allow multiple\n   * providers spread across many files to provide configuration information to a common token.\n   */\n  multi?: boolean;\n}\n\n/**\n * Describes how the `Injector` should be configured.\n * @see [Dependency Injection Guide](guide/di/dependency-injection)\n *\n * @see {@link StaticProvider}\n *\n * @publicApi\n */\nexport type Provider =\n  | TypeProvider\n  | ValueProvider\n  | ClassProvider\n  | ConstructorProvider\n  | ExistingProvider\n  | FactoryProvider\n  | any[];\n\n/**\n * Encapsulated `Provider`s that are only accepted during creation of an `EnvironmentInjector` (e.g.\n * in an `NgModule`).\n *\n * Using this wrapper type prevents providers which are only designed to work in\n * application/environment injectors from being accidentally included in\n * `@Component.providers` and ending up in a component injector.\n *\n * This wrapper type prevents access to the `Provider`s inside.\n *\n * @see {@link makeEnvironmentProviders}\n * @see {@link importProvidersFrom}\n *\n * @publicApi\n */\nexport type EnvironmentProviders = {\n  ɵbrand: 'EnvironmentProviders';\n};\n\nexport interface InternalEnvironmentProviders extends EnvironmentProviders {\n  ɵproviders: (Provider | EnvironmentProviders)[];\n\n  /**\n   * If present, indicates that the `EnvironmentProviders` were derived from NgModule providers.\n   *\n   * This is used to produce clearer error messages.\n   */\n  ɵfromNgModule?: true;\n}\n\nexport function isEnvironmentProviders(\n  value: Provider | EnvironmentProviders | InternalEnvironmentProviders,\n): value is InternalEnvironmentProviders {\n  return value && !!(value as InternalEnvironmentProviders).ɵproviders;\n}\n\n/**\n * Describes a function that is used to process provider lists (such as provider\n * overrides).\n */\nexport type ProcessProvidersFunction = (providers: Provider[]) => Provider[];\n\n/**\n * A wrapper around an NgModule that associates it with providers\n * Usage without a generic type is deprecated.\n *\n * @publicApi\n */\nexport interface ModuleWithProviders<T> {\n  ngModule: Type<T>;\n  providers?: Array<Provider | EnvironmentProviders>;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {getClosureSafeProperty} from '../util/property';\n\nexport const NG_COMP_DEF: string = getClosureSafeProperty({ɵcmp: getClosureSafeProperty});\nexport const NG_DIR_DEF: string = getClosureSafeProperty({ɵdir: getClosureSafeProperty});\nexport const NG_PIPE_DEF: string = getClosureSafeProperty({ɵpipe: getClosureSafeProperty});\nexport const NG_MOD_DEF: string = getClosureSafeProperty({ɵmod: getClosureSafeProperty});\nexport const NG_FACTORY_DEF: string = getClosureSafeProperty({ɵfac: getClosureSafeProperty});\n\n/**\n * If a directive is diPublic, bloomAdd sets a property on the type with this constant as\n * the key and the directive's unique ID as the value. This allows us to map directives to their\n * bloom filter bit for DI.\n */\n// TODO(misko): This is wrong. The NG_ELEMENT_ID should never be minified.\nexport const NG_ELEMENT_ID: string = getClosureSafeProperty({\n  __NG_ELEMENT_ID__: getClosureSafeProperty,\n});\n\n/**\n * The `NG_ENV_ID` field on a DI token indicates special processing in the `EnvironmentInjector`:\n * getting such tokens from the `EnvironmentInjector` will bypass the standard DI resolution\n * strategy and instead will return implementation produced by the `NG_ENV_ID` factory function.\n *\n * This particular retrieval of DI tokens is mostly done to eliminate circular dependencies and\n * improve tree-shaking.\n */\nexport const NG_ENV_ID: string = getClosureSafeProperty({__NG_ENV_ID__: getClosureSafeProperty});\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {Type} from '../interface/type';\nimport type {NgModuleDef} from '../r3_symbols';\nimport {stringify} from '../util/stringify';\nimport {NG_COMP_DEF, NG_DIR_DEF, NG_MOD_DEF, NG_PIPE_DEF} from './fields';\nimport type {ComponentDef, DirectiveDef, PipeDef} from './interfaces/definition';\n\nexport function getNgModuleDef<T>(type: any): NgModuleDef<T> | null {\n  assertTypeDefined(type, '@NgModule');\n  return type[NG_MOD_DEF] || null;\n}\n\nexport function getNgModuleDefOrThrow<T>(type: any): NgModuleDef<T> | never {\n  const ngModuleDef = getNgModuleDef<T>(type);\n  if (!ngModuleDef) {\n    throw new RuntimeError(\n      RuntimeErrorCode.MISSING_NG_MODULE_DEFINITION,\n      (typeof ngDevMode === 'undefined' || ngDevMode) &&\n        `Type ${stringify(type)} does not have 'ɵmod' property.`,\n    );\n  }\n  return ngModuleDef;\n}\n\n/**\n * The following getter methods retrieve the definition from the type. Currently the retrieval\n * honors inheritance, but in the future we may change the rule to require that definitions are\n * explicit. This would require some sort of migration strategy.\n */\n\nexport function getComponentDef<T>(type: any): ComponentDef<T> | null {\n  assertTypeDefined(type, '@Component');\n  return type[NG_COMP_DEF] || null;\n}\n\nexport function getDirectiveDefOrThrow<T>(type: any): DirectiveDef<T> | never {\n  const def = getDirectiveDef<T>(type);\n  if (!def) {\n    throw new RuntimeError(\n      RuntimeErrorCode.MISSING_DIRECTIVE_DEFINITION,\n      (typeof ngDevMode === 'undefined' || ngDevMode) &&\n        `Type ${stringify(type)} does not have 'ɵdir' property.`,\n    );\n  }\n  return def;\n}\n\nexport function getDirectiveDef<T>(type: any): DirectiveDef<T> | null {\n  assertTypeDefined(type, '@Directive');\n  return type[NG_DIR_DEF] || null;\n}\n\nexport function getPipeDef<T>(type: any): PipeDef<T> | null {\n  assertTypeDefined(type, '@Pipe');\n  return type[NG_PIPE_DEF] || null;\n}\n\nfunction assertTypeDefined(type: any, symbolType: string): void {\n  if (type == null) {\n    throw new RuntimeError(\n      RuntimeErrorCode.DEF_TYPE_UNDEFINED,\n      (typeof ngDevMode === 'undefined' || ngDevMode) &&\n        `Cannot read ${symbolType} metadata. This can indicate a runtime ` +\n          `circular dependency in your app that needs to be resolved.`,\n    );\n  }\n}\n\n/**\n * Checks whether a given Component, Directive or Pipe is marked as standalone.\n * This will return false if passed anything other than a Component, Directive, or Pipe class\n * See [this guide](guide/components/importing) for additional information:\n *\n * @param type A reference to a Component, Directive or Pipe.\n * @publicApi\n */\nexport function isStandalone(type: Type<unknown>): boolean {\n  const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);\n  return def !== null && def.standalone;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Type} from '../../interface/type';\nimport {getComponentDef} from '../def_getters';\nimport type {ClassDebugInfo} from '../interfaces/definition';\n\n/**\n * Used for stringify render output in Ivy.\n * Important! This function is very performance-sensitive and we should\n * be extra careful not to introduce megamorphic reads in it.\n * Check `core/test/render3/perf/render_stringify` for benchmarks and alternate implementations.\n */\nexport function renderStringify(value: any): string {\n  if (typeof value === 'string') return value;\n  if (value == null) return '';\n  // Use `String` so that it invokes the `toString` method of the value. Note that this\n  // appears to be faster than calling `value.toString` (see `render_stringify` benchmark).\n  return String(value);\n}\n\n/**\n * Used to stringify a value so that it can be displayed in an error message.\n *\n * Important! This function contains a megamorphic read and should only be\n * used for error messages.\n */\nexport function stringifyForError(value: any): string {\n  if (typeof value === 'function') return value.name || value.toString();\n  if (typeof value === 'object' && value != null && typeof value.type === 'function') {\n    return value.type.name || value.type.toString();\n  }\n\n  return renderStringify(value);\n}\n\n/**\n * Used to stringify a `Type` and including the file path and line number in which it is defined, if\n * possible, for better debugging experience.\n *\n * Important! This function contains a megamorphic read and should only be used for error messages.\n */\nexport function debugStringifyTypeForError(type: Type<any>): string {\n  const componentDef = getComponentDef(type);\n\n  if (componentDef !== null && componentDef.debugInfo) {\n    return stringifyTypeFromDebugInfo(componentDef.debugInfo);\n  }\n\n  return stringifyForError(type);\n}\n\nfunction stringifyTypeFromDebugInfo(debugInfo: ClassDebugInfo): string {\n  if (!debugInfo.filePath || !debugInfo.lineNumber) {\n    return debugInfo.className;\n  } else {\n    return `${debugInfo.className} (at ${debugInfo.filePath}:${debugInfo.lineNumber})`;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {ProviderToken} from '../di';\nimport {isEnvironmentProviders} from '../di/interface/provider';\nimport {formatRuntimeError, RuntimeError, RuntimeErrorCode} from '../errors';\nimport {Type} from '../interface/type';\nimport {assertDefined} from '../util/assert';\nimport {getClosureSafeProperty} from '../util/property';\nimport {stringify} from '../util/stringify';\n\nimport {stringifyForError} from './util/stringify_utils';\n\nconst NG_RUNTIME_ERROR_CODE = getClosureSafeProperty({'ngErrorCode': getClosureSafeProperty});\nconst NG_RUNTIME_ERROR_MESSAGE = getClosureSafeProperty({'ngErrorMessage': getClosureSafeProperty});\nconst NG_TOKEN_PATH = getClosureSafeProperty({'ngTokenPath': getClosureSafeProperty});\n\n/** Creates a circular dependency runtime error. */\nexport function cyclicDependencyError(token: string, path?: string[]): Error {\n  const message = ngDevMode ? `Circular dependency detected for \\`${token}\\`.` : '';\n  return createRuntimeError(message, RuntimeErrorCode.CYCLIC_DI_DEPENDENCY, path);\n}\n\n/** Creates a circular dependency runtime error including a dependency path in the error message. */\nexport function cyclicDependencyErrorWithDetails(token: string, path: string[]): Error {\n  return augmentRuntimeError(cyclicDependencyError(token, path), null);\n}\n\nexport function throwMixedMultiProviderError() {\n  throw new Error(`Cannot mix multi providers and regular providers`);\n}\n\nexport function throwInvalidProviderError(\n  ngModuleType?: Type<unknown>,\n  providers?: any[],\n  provider?: any,\n): never {\n  if (ngModuleType && providers) {\n    const providerDetail = providers.map((v) => (v == provider ? '?' + provider + '?' : '...'));\n    throw new Error(\n      `Invalid provider for the NgModule '${stringify(\n        ngModuleType,\n      )}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(', ')}]`,\n    );\n  } else if (isEnvironmentProviders(provider)) {\n    if (provider.ɵfromNgModule) {\n      throw new RuntimeError(\n        RuntimeErrorCode.PROVIDER_IN_WRONG_CONTEXT,\n        `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`,\n      );\n    } else {\n      throw new RuntimeError(\n        RuntimeErrorCode.PROVIDER_IN_WRONG_CONTEXT,\n        `Invalid providers present in a non-environment injector. 'EnvironmentProviders' can't be used for component providers.`,\n      );\n    }\n  } else {\n    throw new Error('Invalid provider');\n  }\n}\n\n/** Throws an error when a token is not found in DI. */\nexport function throwProviderNotFoundError(\n  token: ProviderToken<unknown>,\n  injectorName?: string,\n): never {\n  const errorMessage =\n    ngDevMode &&\n    `No provider for ${stringifyForError(token)} found${injectorName ? ` in ${injectorName}` : ''}`;\n  throw new RuntimeError(RuntimeErrorCode.PROVIDER_NOT_FOUND, errorMessage);\n}\n\n/**\n * Given an Error instance and the current token - update the monkey-patched\n * dependency path info to include that token.\n *\n * @param error Current instance of the Error class.\n * @param token Extra token that should be appended.\n */\nexport function prependTokenToDependencyPath(\n  error: any,\n  token: ProviderToken<unknown> | {multi: true; provide: ProviderToken<unknown>},\n): void {\n  error[NG_TOKEN_PATH] ??= [];\n  // Append current token to the current token path. Since the error\n  // is bubbling up, add the token in front of other tokens.\n  const currentPath = error[NG_TOKEN_PATH];\n  // Do not append the same token multiple times.\n  let pathStr: string;\n  if (typeof token === 'object' && 'multi' in token && token?.multi === true) {\n    assertDefined(token.provide, 'Token with multi: true should have a provide property');\n    pathStr = stringifyForError(token.provide);\n  } else {\n    pathStr = stringifyForError(token);\n  }\n\n  if (currentPath[0] !== pathStr) {\n    (error[NG_TOKEN_PATH] as string[]).unshift(pathStr);\n  }\n}\n\n/**\n * Modifies an Error instance with an updated error message\n * based on the accumulated dependency path.\n *\n * @param error Current instance of the Error class.\n * @param source Extra info about the injector which started\n *    the resolution process, which eventually failed.\n */\nexport function augmentRuntimeError(error: any, source: string | null): Error {\n  const tokenPath: string[] = error[NG_TOKEN_PATH];\n  const errorCode = error[NG_RUNTIME_ERROR_CODE];\n  const message = error[NG_RUNTIME_ERROR_MESSAGE] || error.message;\n  error.message = formatErrorMessage(message, errorCode, tokenPath, source);\n  return error;\n}\n\n/**\n * Creates an initial RuntimeError instance when a problem is detected.\n * Monkey-patches extra info in the RuntimeError instance, so that it can\n * be reused later, before throwing the final error.\n */\nexport function createRuntimeError(message: string, code: number, path?: string[]): Error {\n  // Cast to `any`, so that extra info can be monkey-patched onto this instance.\n  const error = new RuntimeError(code, message) as any;\n\n  // Monkey-patch a runtime error code and a path onto an Error instance.\n  error[NG_RUNTIME_ERROR_CODE] = code;\n  error[NG_RUNTIME_ERROR_MESSAGE] = message;\n  if (path) {\n    error[NG_TOKEN_PATH] = path;\n  }\n  return error;\n}\n\n/**\n * Reads monkey-patched error code from the given Error instance.\n */\nexport function getRuntimeErrorCode(error: any): number | undefined {\n  return error[NG_RUNTIME_ERROR_CODE];\n}\n\nfunction formatErrorMessage(\n  text: string,\n  code: number,\n  path: string[] = [],\n  source: string | null = null,\n): string {\n  let pathDetails = '';\n  // If the path is empty or contains only one element (self) -\n  // do not append additional info the error message.\n  if (path && path.length > 1) {\n    pathDetails = ` Path: ${path.join(' -> ')}.`;\n  }\n  const sourceDetails = source ? ` Source: ${source}.` : '';\n  return formatRuntimeError(code, `${text}${sourceDetails}${pathDetails}`);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {throwProviderNotFoundError} from '../render3/errors_di';\nimport {assertNotEqual} from '../util/assert';\n\nimport {getInjectableDef, ɵɵInjectableDeclaration} from './interface/defs';\nimport {InternalInjectFlags} from './interface/injector';\nimport {ProviderToken} from './provider_token';\n\n/**\n * Current implementation of inject.\n *\n * By default, it is `injectInjectorOnly`, which makes it `Injector`-only aware. It can be changed\n * to `directiveInject`, which brings in the `NodeInjector` system of ivy. It is designed this\n * way for two reasons:\n *  1. `Injector` should not depend on ivy logic.\n *  2. To maintain tree shake-ability we don't want to bring in unnecessary code.\n */\nlet _injectImplementation:\n  | (<T>(token: ProviderToken<T>, flags?: InternalInjectFlags) => T | null)\n  | undefined;\nexport function getInjectImplementation() {\n  return _injectImplementation;\n}\n\n/**\n * Sets the current inject implementation.\n */\nexport function setInjectImplementation(\n  impl: (<T>(token: ProviderToken<T>, flags?: InternalInjectFlags) => T | null) | undefined,\n): (<T>(token: ProviderToken<T>, flags?: InternalInjectFlags) => T | null) | undefined {\n  const previous = _injectImplementation;\n  _injectImplementation = impl;\n  return previous;\n}\n\n/**\n * Injects `root` tokens in limp mode.\n *\n * If no injector exists, we can still inject tree-shakable providers which have `providedIn` set to\n * `\"root\"`. This is known as the limp mode injection. In such case the value is stored in the\n * injectable definition.\n */\nexport function injectRootLimpMode<T>(\n  token: ProviderToken<T>,\n  notFoundValue: T | undefined,\n  flags: InternalInjectFlags,\n): T | null {\n  const injectableDef: ɵɵInjectableDeclaration<T> | null = getInjectableDef(token);\n  if (injectableDef && injectableDef.providedIn == 'root') {\n    return injectableDef.value === undefined\n      ? (injectableDef.value = injectableDef.factory())\n      : injectableDef.value;\n  }\n  if (flags & InternalInjectFlags.Optional) return null;\n  if (notFoundValue !== undefined) return notFoundValue;\n  throwProviderNotFoundError(\n    token,\n    typeof ngDevMode !== 'undefined' && ngDevMode ? 'Injector' : '',\n  );\n}\n\n/**\n * Assert that `_injectImplementation` is not `fn`.\n *\n * This is useful, to prevent infinite recursion.\n *\n * @param fn Function which it should not equal to\n */\nexport function assertInjectImplementationNotEqual(\n  fn: <T>(token: ProviderToken<T>, flags?: InternalInjectFlags) => T | null,\n) {\n  ngDevMode &&\n    assertNotEqual(_injectImplementation, fn, 'Calling ɵɵinject would cause infinite recursion');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport '../util/ng_dev_mode';\n\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {Type} from '../interface/type';\nimport {emitInjectEvent} from '../render3/debug/injector_profiler';\nimport {stringify} from '../util/stringify';\n\nimport {resolveForwardRef} from './forward_ref';\nimport {getInjectImplementation, injectRootLimpMode} from './inject_switch';\nimport type {Injector} from './injector';\nimport {DecoratorFlags, InternalInjectFlags, InjectOptions} from './interface/injector';\nimport {ProviderToken} from './provider_token';\nimport type {HostAttributeToken} from './host_attribute_token';\nimport {\n  Injector as PrimitivesInjector,\n  isNotFound,\n  NotFound,\n  InjectionToken as PrimitivesInjectionToken,\n  getCurrentInjector,\n} from '../../primitives/di';\n\nimport {InjectionToken} from './injection_token';\n\nconst _THROW_IF_NOT_FOUND = {};\nexport const THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n\nexport {getCurrentInjector, setCurrentInjector} from '../../primitives/di';\n\n/*\n * Name of a property (that we patch onto DI decorator), which is used as an annotation of which\n * InjectFlag this decorator represents. This allows to avoid direct references to the DI decorators\n * in the code, thus making them tree-shakable.\n */\nconst DI_DECORATOR_FLAG = '__NG_DI_FLAG__';\n\n/**\n * A wrapper around an `Injector` that implements the `PrimitivesInjector` interface.\n *\n * This is used to allow the `inject` function to be used with the new primitives-based DI system.\n */\nexport class RetrievingInjector implements PrimitivesInjector {\n  constructor(readonly injector: Injector) {}\n  retrieve<T>(token: PrimitivesInjectionToken<T>, options: unknown): T | NotFound {\n    const flags: InternalInjectFlags =\n      convertToBitFlags(options as InjectOptions | undefined) || InternalInjectFlags.Default;\n    try {\n      return (this.injector as BackwardsCompatibleInjector).get(\n        token as unknown as InjectionToken<T>,\n        // When a dependency is requested with an optional flag, DI returns null as the default value.\n        (flags & InternalInjectFlags.Optional ? null : THROW_IF_NOT_FOUND) as T,\n        flags,\n      ) as T;\n    } catch (e: any) {\n      if (isNotFound(e)) {\n        return e;\n      }\n      throw e;\n    }\n  }\n}\n\nexport const NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';\nconst NG_TOKEN_PATH = 'ngTokenPath';\nconst NEW_LINE = /\\n/gm;\nconst NO_NEW_LINE = 'ɵ';\nexport const SOURCE = '__source';\n\n/**\n * Temporary type to allow internal symbols to use inject flags. This should be\n * removed once we consolidate the flags and the object literal approach.\n */\nexport type BackwardsCompatibleInjector = Injector & {\n  get<T>(\n    token: ProviderToken<T>,\n    notFoundValue?: T,\n    options?: InternalInjectFlags | InjectOptions,\n  ): T;\n};\n\nexport function injectInjectorOnly<T>(token: ProviderToken<T>): T;\nexport function injectInjectorOnly<T>(\n  token: ProviderToken<T>,\n  flags?: InternalInjectFlags,\n): T | null;\nexport function injectInjectorOnly<T>(\n  token: ProviderToken<T>,\n  flags = InternalInjectFlags.Default,\n): T | null {\n  const currentInjector = getCurrentInjector();\n  if (currentInjector === undefined) {\n    throw new RuntimeError(\n      RuntimeErrorCode.MISSING_INJECTION_CONTEXT,\n      ngDevMode &&\n        `The \\`${stringify(token)}\\` token injection failed. \\`inject()\\` function must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with \\`runInInjectionContext\\`.`,\n    );\n  } else if (currentInjector === null) {\n    return injectRootLimpMode(token, undefined, flags);\n  } else {\n    const options = convertToInjectOptions(flags);\n    // TODO: improve the typings here.\n    // `token` can be a multi: true provider definition, which is considered as a Token but not represented in the typings\n    const value = currentInjector.retrieve(token as PrimitivesInjectionToken<T>, options) as T;\n    ngDevMode && emitInjectEvent(token as Type<unknown>, value, flags);\n    if (isNotFound(value)) {\n      if (options.optional) {\n        return null;\n      }\n      throw value;\n    }\n    return value;\n  }\n}\n\n/**\n * Generated instruction: injects a token from the currently active injector.\n *\n * (Additional documentation moved to `inject`, as it is the public API, and an alias for this\n * instruction)\n *\n * @see inject\n * @codeGenApi\n * @publicApi This instruction has been emitted by ViewEngine for some time and is deployed to npm.\n */\nexport function ɵɵinject<T>(token: ProviderToken<T>): T;\nexport function ɵɵinject<T>(token: ProviderToken<T>, flags?: InternalInjectFlags): T | null;\nexport function ɵɵinject(token: HostAttributeToken): string;\nexport function ɵɵinject(token: HostAttributeToken, flags?: InternalInjectFlags): string | null;\nexport function ɵɵinject<T>(\n  token: ProviderToken<T> | HostAttributeToken,\n  flags?: InternalInjectFlags,\n): string | null;\nexport function ɵɵinject<T>(\n  token: ProviderToken<T> | HostAttributeToken,\n  flags = InternalInjectFlags.Default,\n): T | null {\n  return (getInjectImplementation() || injectInjectorOnly)(\n    resolveForwardRef(token as Type<T>),\n    flags,\n  );\n}\n\n/**\n * Throws an error indicating that a factory function could not be generated by the compiler for a\n * particular class.\n *\n * The name of the class is not mentioned here, but will be in the generated factory function name\n * and thus in the stack trace.\n *\n * @codeGenApi\n */\nexport function ɵɵinvalidFactoryDep(index: number): never {\n  throw new RuntimeError(\n    RuntimeErrorCode.INVALID_FACTORY_DEPENDENCY,\n    ngDevMode &&\n      `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.\nThis can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.\n\nPlease check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`,\n  );\n}\n\n/**\n * @param token A token that represents a dependency that should be injected.\n * @returns the injected value if operation is successful, `null` otherwise.\n * @throws if called outside of a supported context.\n *\n * @publicApi\n */\nexport function inject<T>(token: ProviderToken<T>): T;\n/**\n * @param token A token that represents a dependency that should be injected.\n * @param options Control how injection is executed. Options correspond to injection strategies\n *     that can be specified with parameter decorators `@Host`, `@Self`, `@SkipSelf`, and\n *     `@Optional`.\n * @returns the injected value if operation is successful.\n * @throws if called outside of a supported context, or if the token is not found.\n *\n * @publicApi\n */\nexport function inject<T>(token: ProviderToken<T>, options: InjectOptions & {optional?: false}): T;\n/**\n * @param token A token that represents a dependency that should be injected.\n * @param options Control how injection is executed. Options correspond to injection strategies\n *     that can be specified with parameter decorators `@Host`, `@Self`, `@SkipSelf`, and\n *     `@Optional`.\n * @returns the injected value if operation is successful,  `null` if the token is not\n *     found and optional injection has been requested.\n * @throws if called outside of a supported context, or if the token is not found and optional\n *     injection was not requested.\n *\n * @publicApi\n */\nexport function inject<T>(token: ProviderToken<T>, options: InjectOptions): T | null;\n/**\n * @param token A token that represents a static attribute on the host node that should be injected.\n * @returns Value of the attribute if it exists.\n * @throws If called outside of a supported context or the attribute does not exist.\n *\n * @publicApi\n */\nexport function inject(token: HostAttributeToken): string;\n/**\n * @param token A token that represents a static attribute on the host node that should be injected.\n * @returns Value of the attribute if it exists, otherwise `null`.\n * @throws If called outside of a supported context.\n *\n * @publicApi\n */\nexport function inject(token: HostAttributeToken, options: {optional: true}): string | null;\n/**\n * @param token A token that represents a static attribute on the host node that should be injected.\n * @returns Value of the attribute if it exists.\n * @throws If called outside of a supported context or the attribute does not exist.\n *\n * @publicApi\n */\nexport function inject(token: HostAttributeToken, options: {optional: false}): string;\n/**\n * Injects a token from the currently active injector.\n * `inject` is only supported in an [injection context](guide/di/dependency-injection-context). It\n * can be used during:\n * - Construction (via the `constructor`) of a class being instantiated by the DI system, such\n * as an `@Injectable` or `@Component`.\n * - In the initializer for fields of such classes.\n * - In the factory function specified for `useFactory` of a `Provider` or an `@Injectable`.\n * - In the `factory` function specified for an `InjectionToken`.\n * - In a stackframe of a function call in a DI context\n *\n * @param token A token that represents a dependency that should be injected.\n * @param flags Optional flags that control how injection is executed.\n * The flags correspond to injection strategies that can be specified with\n * parameter decorators `@Host`, `@Self`, `@SkipSelf`, and `@Optional`.\n * @returns the injected value if operation is successful, `null` otherwise.\n * @throws if called outside of a supported context.\n *\n * @usageNotes\n * In practice the `inject()` calls are allowed in a constructor, a constructor parameter and a\n * field initializer:\n *\n * ```ts\n * @Injectable({providedIn: 'root'})\n * export class Car {\n *   radio: Radio|undefined;\n *   // OK: field initializer\n *   spareTyre = inject(Tyre);\n *\n *   constructor() {\n *     // OK: constructor body\n *     this.radio = inject(Radio);\n *   }\n * }\n * ```\n *\n * It is also legal to call `inject` from a provider's factory:\n *\n * ```ts\n * providers: [\n *   {provide: Car, useFactory: () => {\n *     // OK: a class factory\n *     const engine = inject(Engine);\n *     return new Car(engine);\n *   }}\n * ]\n * ```\n *\n * Calls to the `inject()` function outside of the class creation context will result in error. Most\n * notably, calls to `inject()` are disallowed after a class instance was created, in methods\n * (including lifecycle hooks):\n *\n * ```ts\n * @Component({ ... })\n * export class CarComponent {\n *   ngOnInit() {\n *     // ERROR: too late, the component instance was already created\n *     const engine = inject(Engine);\n *     engine.start();\n *   }\n * }\n * ```\n *\n * @see [Injecting dependencies with inject()](guide/di#injecting-dependencies-with-inject)\n *\n * @publicApi\n */\nexport function inject<T>(token: ProviderToken<T> | HostAttributeToken, options?: InjectOptions) {\n  // The `as any` here _shouldn't_ be necessary, but without it JSCompiler\n  // throws a disambiguation  error due to the multiple signatures.\n  return ɵɵinject(token as any, convertToBitFlags(options));\n}\n\n// Converts object-based DI flags (`InjectOptions`) to bit flags (`InjectFlags`).\nexport function convertToBitFlags(\n  flags: InjectOptions | InternalInjectFlags | undefined,\n): InternalInjectFlags | undefined {\n  if (typeof flags === 'undefined' || typeof flags === 'number') {\n    return flags;\n  }\n\n  // While TypeScript doesn't accept it without a cast, bitwise OR with false-y values in\n  // JavaScript is a no-op. We can use that for a very codesize-efficient conversion from\n  // `InjectOptions` to `InjectFlags`.\n  return (InternalInjectFlags.Default | // comment to force a line break in the formatter\n    ((flags.optional && InternalInjectFlags.Optional) as number) |\n    ((flags.host && InternalInjectFlags.Host) as number) |\n    ((flags.self && InternalInjectFlags.Self) as number) |\n    ((flags.skipSelf && InternalInjectFlags.SkipSelf) as number)) as InternalInjectFlags;\n}\n\n// Converts bitflags to inject options\nfunction convertToInjectOptions(flags: InternalInjectFlags): InjectOptions {\n  return {\n    optional: !!(flags & InternalInjectFlags.Optional),\n    host: !!(flags & InternalInjectFlags.Host),\n    self: !!(flags & InternalInjectFlags.Self),\n    skipSelf: !!(flags & InternalInjectFlags.SkipSelf),\n  };\n}\n\nexport function injectArgs(types: (ProviderToken<any> | any[])[]): any[] {\n  const args: any[] = [];\n  for (let i = 0; i < types.length; i++) {\n    const arg = resolveForwardRef(types[i]);\n    if (Array.isArray(arg)) {\n      if (arg.length === 0) {\n        throw new RuntimeError(\n          RuntimeErrorCode.INVALID_DIFFER_INPUT,\n          ngDevMode && 'Arguments array must have arguments.',\n        );\n      }\n      let type: Type<any> | undefined = undefined;\n      let flags: InternalInjectFlags = InternalInjectFlags.Default;\n\n      for (let j = 0; j < arg.length; j++) {\n        const meta = arg[j];\n        const flag = getInjectFlag(meta);\n        if (typeof flag === 'number') {\n          // Special case when we handle @Inject decorator.\n          if (flag === DecoratorFlags.Inject) {\n            type = meta.token;\n          } else {\n            flags |= flag;\n          }\n        } else {\n          type = meta;\n        }\n      }\n\n      args.push(ɵɵinject(type!, flags));\n    } else {\n      args.push(ɵɵinject(arg));\n    }\n  }\n  return args;\n}\n\n/**\n * Attaches a given InjectFlag to a given decorator using monkey-patching.\n * Since DI decorators can be used in providers `deps` array (when provider is configured using\n * `useFactory`) without initialization (e.g. `Host`) and as an instance (e.g. `new Host()`), we\n * attach the flag to make it available both as a static property and as a field on decorator\n * instance.\n *\n * @param decorator Provided DI decorator.\n * @param flag InjectFlag that should be applied.\n */\nexport function attachInjectFlag(decorator: any, flag: InternalInjectFlags | DecoratorFlags): any {\n  decorator[DI_DECORATOR_FLAG] = flag;\n  decorator.prototype[DI_DECORATOR_FLAG] = flag;\n  return decorator;\n}\n\n/**\n * Reads monkey-patched property that contains InjectFlag attached to a decorator.\n *\n * @param token Token that may contain monkey-patched DI flags property.\n */\nexport function getInjectFlag(token: any): number | undefined {\n  return token[DI_DECORATOR_FLAG];\n}\n\nexport function formatError(\n  text: string,\n  obj: any,\n  injectorErrorName: string,\n  source: string | null = null,\n): string {\n  text = text && text.charAt(0) === '\\n' && text.charAt(1) == NO_NEW_LINE ? text.slice(2) : text;\n  let context = stringify(obj);\n  if (Array.isArray(obj)) {\n    context = obj.map(stringify).join(' -> ');\n  } else if (typeof obj === 'object') {\n    let parts = <string[]>[];\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        let value = obj[key];\n        parts.push(\n          key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)),\n        );\n      }\n    }\n    context = `{${parts.join(', ')}}`;\n  }\n  return `${injectorErrorName}${source ? '(' + source + ')' : ''}[${context}]: ${text.replace(\n    NEW_LINE,\n    '\\n  ',\n  )}`;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Type} from '../interface/type';\nimport {stringify} from '../util/stringify';\nimport {NG_FACTORY_DEF} from './fields';\n\n/**\n * Definition of what a factory function should look like.\n */\nexport type FactoryFn<T> = {\n  /**\n   * Subclasses without an explicit constructor call through to the factory of their base\n   * definition, providing it with their own constructor to instantiate.\n   */\n  <U extends T>(t?: Type<U>): U;\n\n  /**\n   * If no constructor to instantiate is provided, an instance of type T itself is created.\n   */\n  (t?: undefined): T;\n};\n\nexport function getFactoryDef<T>(type: any, throwNotFound: true): FactoryFn<T>;\nexport function getFactoryDef<T>(type: any): FactoryFn<T> | null;\nexport function getFactoryDef<T>(type: any, throwNotFound?: boolean): FactoryFn<T> | null {\n  const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);\n  if (!hasFactoryDef && throwNotFound === true && ngDevMode) {\n    throw new Error(`Type ${stringify(type)} does not have 'ɵfac' property.`);\n  }\n  return hasFactoryDef ? type[NG_FACTORY_DEF] : null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {assertEqual, assertLessThanOrEqual} from './assert';\n\n/**\n * Determines if the contents of two arrays is identical\n *\n * @param a first array\n * @param b second array\n * @param identityAccessor Optional function for extracting stable object identity from a value in\n *     the array.\n */\nexport function arrayEquals<T>(a: T[], b: T[], identityAccessor?: (value: T) => unknown): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    let valueA = a[i];\n    let valueB = b[i];\n    if (identityAccessor) {\n      valueA = identityAccessor(valueA) as any;\n      valueB = identityAccessor(valueB) as any;\n    }\n    if (valueB !== valueA) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Flattens an array.\n */\nexport function flatten(list: any[]): any[] {\n  return list.flat(Number.POSITIVE_INFINITY);\n}\n\nexport function deepForEach<T>(input: (T | any[])[], fn: (value: T) => void): void {\n  input.forEach((value) => (Array.isArray(value) ? deepForEach(value, fn) : fn(value)));\n}\n\nexport function addToArray(arr: any[], index: number, value: any): void {\n  // perf: array.push is faster than array.splice!\n  if (index >= arr.length) {\n    arr.push(value);\n  } else {\n    arr.splice(index, 0, value);\n  }\n}\n\nexport function removeFromArray(arr: any[], index: number): any {\n  // perf: array.pop is faster than array.splice!\n  if (index >= arr.length - 1) {\n    return arr.pop();\n  } else {\n    return arr.splice(index, 1)[0];\n  }\n}\n\nexport function newArray<T = any>(size: number): T[];\nexport function newArray<T>(size: number, value: T): T[];\nexport function newArray<T>(size: number, value?: T): T[] {\n  const list: T[] = [];\n  for (let i = 0; i < size; i++) {\n    list.push(value!);\n  }\n  return list;\n}\n\n/**\n * Remove item from array (Same as `Array.splice()` but faster.)\n *\n * `Array.splice()` is not as fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * https://jsperf.com/fast-array-splice (About 20x faster)\n *\n * @param array Array to splice\n * @param index Index of element in array to remove.\n * @param count Number of items to remove.\n */\nexport function arraySplice(array: any[], index: number, count: number): void {\n  const length = array.length - count;\n  while (index < length) {\n    array[index] = array[index + count];\n    index++;\n  }\n  while (count--) {\n    array.pop(); // shrink the array\n  }\n}\n\n/**\n * Same as `Array.splice(index, 0, value)` but faster.\n *\n * `Array.splice()` is not fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * @param array Array to splice.\n * @param index Index in array where the `value` should be added.\n * @param value Value to add to array.\n */\nexport function arrayInsert(array: any[], index: number, value: any): void {\n  ngDevMode && assertLessThanOrEqual(index, array.length, \"Can't insert past array end.\");\n  let end = array.length;\n  while (end > index) {\n    const previousEnd = end - 1;\n    array[end] = array[previousEnd];\n    end = previousEnd;\n  }\n  array[index] = value;\n}\n\n/**\n * Same as `Array.splice2(index, 0, value1, value2)` but faster.\n *\n * `Array.splice()` is not fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * @param array Array to splice.\n * @param index Index in array where the `value` should be added.\n * @param value1 Value to add to array.\n * @param value2 Value to add to array.\n */\nexport function arrayInsert2(array: any[], index: number, value1: any, value2: any): void {\n  ngDevMode && assertLessThanOrEqual(index, array.length, \"Can't insert past array end.\");\n  let end = array.length;\n  if (end == index) {\n    // inserting at the end.\n    array.push(value1, value2);\n  } else if (end === 1) {\n    // corner case when we have less items in array than we have items to insert.\n    array.push(value2, array[0]);\n    array[0] = value1;\n  } else {\n    end--;\n    array.push(array[end - 1], array[end]);\n    while (end > index) {\n      const previousEnd = end - 2;\n      array[end] = array[previousEnd];\n      end--;\n    }\n    array[index] = value1;\n    array[index + 1] = value2;\n  }\n}\n\n/**\n * Get an index of an `value` in a sorted `array`.\n *\n * NOTE:\n * - This uses binary search algorithm for fast removals.\n *\n * @param array A sorted array to binary search.\n * @param value The value to look for.\n * @returns index of the value.\n *   - positive index if value found.\n *   - negative index if value not found. (`~index` to get the value where it should have been\n *     located)\n */\nexport function arrayIndexOfSorted(array: string[], value: string): number {\n  return _arrayIndexOfSorted(array, value, 0);\n}\n\n/**\n * `KeyValueArray` is an array where even positions contain keys and odd positions contain values.\n *\n * `KeyValueArray` provides a very efficient way of iterating over its contents. For small\n * sets (~10) the cost of binary searching an `KeyValueArray` has about the same performance\n * characteristics that of a `Map` with significantly better memory footprint.\n *\n * If used as a `Map` the keys are stored in alphabetical order so that they can be binary searched\n * for retrieval.\n *\n * See: `keyValueArraySet`, `keyValueArrayGet`, `keyValueArrayIndexOf`, `keyValueArrayDelete`.\n */\nexport interface KeyValueArray<VALUE> extends Array<VALUE | string> {\n  __brand__: 'array-map';\n}\n\n/**\n * Set a `value` for a `key`.\n *\n * @param keyValueArray to modify.\n * @param key The key to locate or create.\n * @param value The value to set for a `key`.\n * @returns index (always even) of where the value vas set.\n */\nexport function keyValueArraySet<V>(\n  keyValueArray: KeyValueArray<V>,\n  key: string,\n  value: V,\n): number {\n  let index = keyValueArrayIndexOf(keyValueArray, key);\n  if (index >= 0) {\n    // if we found it set it.\n    keyValueArray[index | 1] = value;\n  } else {\n    index = ~index;\n    arrayInsert2(keyValueArray, index, key, value);\n  }\n  return index;\n}\n\n/**\n * Retrieve a `value` for a `key` (on `undefined` if not found.)\n *\n * @param keyValueArray to search.\n * @param key The key to locate.\n * @return The `value` stored at the `key` location or `undefined if not found.\n */\nexport function keyValueArrayGet<V>(keyValueArray: KeyValueArray<V>, key: string): V | undefined {\n  const index = keyValueArrayIndexOf(keyValueArray, key);\n  if (index >= 0) {\n    // if we found it retrieve it.\n    return keyValueArray[index | 1] as V;\n  }\n  return undefined;\n}\n\n/**\n * Retrieve a `key` index value in the array or `-1` if not found.\n *\n * @param keyValueArray to search.\n * @param key The key to locate.\n * @returns index of where the key is (or should have been.)\n *   - positive (even) index if key found.\n *   - negative index if key not found. (`~index` (even) to get the index where it should have\n *     been inserted.)\n */\nexport function keyValueArrayIndexOf<V>(keyValueArray: KeyValueArray<V>, key: string): number {\n  return _arrayIndexOfSorted(keyValueArray as string[], key, 1);\n}\n\n/**\n * Delete a `key` (and `value`) from the `KeyValueArray`.\n *\n * @param keyValueArray to modify.\n * @param key The key to locate or delete (if exist).\n * @returns index of where the key was (or should have been.)\n *   - positive (even) index if key found and deleted.\n *   - negative index if key not found. (`~index` (even) to get the index where it should have\n *     been.)\n */\nexport function keyValueArrayDelete<V>(keyValueArray: KeyValueArray<V>, key: string): number {\n  const index = keyValueArrayIndexOf(keyValueArray, key);\n  if (index >= 0) {\n    // if we found it remove it.\n    arraySplice(keyValueArray, index, 2);\n  }\n  return index;\n}\n\n/**\n * INTERNAL: Get an index of an `value` in a sorted `array` by grouping search by `shift`.\n *\n * NOTE:\n * - This uses binary search algorithm for fast removals.\n *\n * @param array A sorted array to binary search.\n * @param value The value to look for.\n * @param shift grouping shift.\n *   - `0` means look at every location\n *   - `1` means only look at every other (even) location (the odd locations are to be ignored as\n *         they are values.)\n * @returns index of the value.\n *   - positive index if value found.\n *   - negative index if value not found. (`~index` to get the value where it should have been\n * inserted)\n */\nfunction _arrayIndexOfSorted(array: string[], value: string, shift: number): number {\n  ngDevMode && assertEqual(Array.isArray(array), true, 'Expecting an array');\n  let start = 0;\n  let end = array.length >> shift;\n  while (end !== start) {\n    const middle = start + ((end - start) >> 1); // find the middle.\n    const current = array[middle << shift];\n    if (value === current) {\n      return middle << shift;\n    } else if (current > value) {\n      end = middle;\n    } else {\n      start = middle + 1; // We already searched middle so make it non-inclusive by adding 1\n    }\n  }\n  return ~(end << shift);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {initNgDevMode} from './ng_dev_mode';\n\n/**\n * This file contains reuseable \"empty\" symbols that can be used as default return values\n * in different parts of the rendering code. Because the same symbols are returned, this\n * allows for identity checks against these values to be consistently used by the framework\n * code.\n */\n\nexport const EMPTY_OBJ: never = {} as never;\nexport const EMPTY_ARRAY: any[] = [];\n\n// freezing the values prevents any code from accidentally inserting new values in\nif ((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode()) {\n  // These property accesses can be ignored because ngDevMode will be set to false\n  // when optimizing code and the whole if statement will be dropped.\n  // tslint:disable-next-line:no-toplevel-property-access\n  Object.freeze(EMPTY_OBJ);\n  // tslint:disable-next-line:no-toplevel-property-access\n  Object.freeze(EMPTY_ARRAY);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InjectionToken} from './injection_token';\n\n/**\n * A multi-provider token for initialization functions that will run upon construction of an\n * environment injector.\n *\n * @deprecated from v19.0.0, use provideEnvironmentInitializer instead\n *\n * @see {@link provideEnvironmentInitializer}\n *\n * Note: As opposed to the `APP_INITIALIZER` token, the `ENVIRONMENT_INITIALIZER` functions are not awaited,\n * hence they should not be `async`.\n *\n * @publicApi\n */\nexport const ENVIRONMENT_INITIALIZER = new InjectionToken<ReadonlyArray<() => void>>(\n  typeof ngDevMode !== 'undefined' && ngDevMode ? 'ENVIRONMENT_INITIALIZER' : '',\n);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InjectionToken} from './injection_token';\nimport type {Injector} from './injector';\nimport {InjectorMarkers} from './injector_marker';\n\n/**\n * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.\n *\n * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a\n * project.\n *\n * @publicApi\n */\nexport const INJECTOR = new InjectionToken<Injector>(\n  typeof ngDevMode !== 'undefined' && ngDevMode ? 'INJECTOR' : '',\n  // Disable tslint because this is const enum which gets inlined not top level prop access.\n  // tslint:disable-next-line: no-toplevel-property-access\n  InjectorMarkers.Injector as any, // Special value used by Ivy to identify `Injector`.\n);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Type} from '../interface/type';\n\nimport {InjectionToken} from './injection_token';\n\nexport const INJECTOR_DEF_TYPES = new InjectionToken<ReadonlyArray<Type<unknown>>>(\n  typeof ngDevMode !== 'undefined' && ngDevMode ? 'INJECTOR_DEF_TYPES' : '',\n);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {RuntimeErrorCode} from '../errors';\nimport {createRuntimeError} from '../render3/errors_di';\nimport {stringify} from '../util/stringify';\n\nimport type {Injector} from './injector';\nimport {THROW_IF_NOT_FOUND} from './injector_compatibility';\n\nexport class NullInjector implements Injector {\n  get(token: any, notFoundValue: any = THROW_IF_NOT_FOUND): any {\n    if (notFoundValue === THROW_IF_NOT_FOUND) {\n      const message = ngDevMode ? `No provider found for \\`${stringify(token)}\\`.` : '';\n      const error = createRuntimeError(message, RuntimeErrorCode.PROVIDER_NOT_FOUND);\n\n      // Note: This is the name used by the primitives to identify a not found error.\n      error.name = 'ɵNotFound';\n\n      throw error;\n    }\n    return notFoundValue;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {Type} from '../interface/type';\nimport {getComponentDef} from '../render3/def_getters';\nimport {getFactoryDef} from '../render3/definition_factory';\nimport {cyclicDependencyErrorWithDetails, throwInvalidProviderError} from '../render3/errors_di';\nimport {stringifyForError} from '../render3/util/stringify_utils';\nimport {deepForEach} from '../util/array_utils';\nimport {EMPTY_ARRAY} from '../util/empty';\nimport {getClosureSafeProperty} from '../util/property';\nimport {stringify} from '../util/stringify';\n\nimport {resolveForwardRef} from './forward_ref';\nimport {ENVIRONMENT_INITIALIZER} from './initializer_token';\nimport {ɵɵinject as inject} from './injector_compatibility';\nimport {getInjectorDef, InjectorType, InjectorTypeWithProviders} from './interface/defs';\nimport {\n  ClassProvider,\n  ConstructorProvider,\n  EnvironmentProviders,\n  ExistingProvider,\n  FactoryProvider,\n  InternalEnvironmentProviders,\n  isEnvironmentProviders,\n  ModuleWithProviders,\n  Provider,\n  StaticClassProvider,\n  TypeProvider,\n  ValueProvider,\n} from './interface/provider';\nimport {INJECTOR_DEF_TYPES} from './internal_tokens';\n\n/**\n * Wrap an array of `Provider`s into `EnvironmentProviders`, preventing them from being accidentally\n * referenced in `@Component` in a component injector.\n *\n * @publicApi\n */\nexport function makeEnvironmentProviders(\n  providers: (Provider | EnvironmentProviders)[],\n): EnvironmentProviders {\n  return {\n    ɵproviders: providers,\n  } as unknown as EnvironmentProviders;\n}\n\n/**\n * @description\n * This function is used to provide initialization functions that will be executed upon construction\n * of an environment injector.\n *\n * Note that the provided initializer is run in the injection context.\n *\n * Previously, this was achieved using the `ENVIRONMENT_INITIALIZER` token which is now deprecated.\n *\n * @see {@link ENVIRONMENT_INITIALIZER}\n *\n * @usageNotes\n * The following example illustrates how to configure an initialization function using\n * `provideEnvironmentInitializer()`\n * ```ts\n * createEnvironmentInjector(\n *   [\n *     provideEnvironmentInitializer(() => {\n *       console.log('environment initialized');\n *     }),\n *   ],\n *   parentInjector\n * );\n * ```\n *\n * @publicApi\n */\nexport function provideEnvironmentInitializer(initializerFn: () => void): EnvironmentProviders {\n  return makeEnvironmentProviders([\n    {\n      provide: ENVIRONMENT_INITIALIZER,\n      multi: true,\n      useValue: initializerFn,\n    },\n  ]);\n}\n\n/**\n * A source of providers for the `importProvidersFrom` function.\n *\n * @publicApi\n */\nexport type ImportProvidersSource =\n  | Type<unknown>\n  | ModuleWithProviders<unknown>\n  | Array<ImportProvidersSource>;\n\ntype WalkProviderTreeVisitor = (\n  provider: SingleProvider,\n  container: Type<unknown> | InjectorType<unknown>,\n) => void;\n\n/**\n * Collects providers from all NgModules and standalone components, including transitively imported\n * ones.\n *\n * Providers extracted via `importProvidersFrom` are only usable in an application injector or\n * another environment injector (such as a route injector). They should not be used in component\n * providers.\n *\n * More information about standalone components can be found in [this\n * guide](guide/components/importing).\n *\n * @usageNotes\n * The results of the `importProvidersFrom` call can be used in the `bootstrapApplication` call:\n *\n * ```ts\n * await bootstrapApplication(RootComponent, {\n *   providers: [\n *     importProvidersFrom(NgModuleOne, NgModuleTwo)\n *   ]\n * });\n * ```\n *\n * You can also use the `importProvidersFrom` results in the `providers` field of a route, when a\n * standalone component is used:\n *\n * ```ts\n * export const ROUTES: Route[] = [\n *   {\n *     path: 'foo',\n *     providers: [\n *       importProvidersFrom(NgModuleOne, NgModuleTwo)\n *     ],\n *     component: YourStandaloneComponent\n *   }\n * ];\n * ```\n *\n * @returns Collected providers from the specified list of types.\n * @publicApi\n */\nexport function importProvidersFrom(...sources: ImportProvidersSource[]): EnvironmentProviders {\n  return {\n    ɵproviders: internalImportProvidersFrom(true, sources),\n    ɵfromNgModule: true,\n  } as InternalEnvironmentProviders;\n}\n\nexport function internalImportProvidersFrom(\n  checkForStandaloneCmp: boolean,\n  ...sources: ImportProvidersSource[]\n): Provider[] {\n  const providersOut: SingleProvider[] = [];\n  const dedup = new Set<Type<unknown>>(); // already seen types\n  let injectorTypesWithProviders: InjectorTypeWithProviders<unknown>[] | undefined;\n\n  const collectProviders: WalkProviderTreeVisitor = (provider) => {\n    providersOut.push(provider);\n  };\n\n  deepForEach(sources, (source) => {\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && checkForStandaloneCmp) {\n      const cmpDef = getComponentDef(source);\n      if (cmpDef?.standalone) {\n        throw new RuntimeError(\n          RuntimeErrorCode.IMPORT_PROVIDERS_FROM_STANDALONE,\n          `Importing providers supports NgModule or ModuleWithProviders but got a standalone component \"${stringifyForError(\n            source,\n          )}\"`,\n        );\n      }\n    }\n\n    // Narrow `source` to access the internal type analogue for `ModuleWithProviders`.\n    const internalSource = source as Type<unknown> | InjectorTypeWithProviders<unknown>;\n    if (walkProviderTree(internalSource, collectProviders, [], dedup)) {\n      injectorTypesWithProviders ||= [];\n      injectorTypesWithProviders.push(internalSource);\n    }\n  });\n  // Collect all providers from `ModuleWithProviders` types.\n  if (injectorTypesWithProviders !== undefined) {\n    processInjectorTypesWithProviders(injectorTypesWithProviders, collectProviders);\n  }\n\n  return providersOut;\n}\n\n/**\n * Collects all providers from the list of `ModuleWithProviders` and appends them to the provided\n * array.\n */\nfunction processInjectorTypesWithProviders(\n  typesWithProviders: InjectorTypeWithProviders<unknown>[],\n  visitor: WalkProviderTreeVisitor,\n): void {\n  for (let i = 0; i < typesWithProviders.length; i++) {\n    const {ngModule, providers} = typesWithProviders[i];\n    deepForEachProvider(\n      providers! as Array<Provider | InternalEnvironmentProviders>,\n      (provider) => {\n        ngDevMode && validateProvider(provider, providers || EMPTY_ARRAY, ngModule);\n        visitor(provider, ngModule);\n      },\n    );\n  }\n}\n\n/**\n * Internal type for a single provider in a deep provider array.\n */\nexport type SingleProvider =\n  | TypeProvider\n  | ValueProvider\n  | ClassProvider\n  | ConstructorProvider\n  | ExistingProvider\n  | FactoryProvider\n  | StaticClassProvider;\n\n/**\n * The logic visits an `InjectorType`, an `InjectorTypeWithProviders`, or a standalone\n * `ComponentType`, and all of its transitive providers and collects providers.\n *\n * If an `InjectorTypeWithProviders` that declares providers besides the type is specified,\n * the function will return \"true\" to indicate that the providers of the type definition need\n * to be processed. This allows us to process providers of injector types after all imports of\n * an injector definition are processed. (following View Engine semantics: see FW-1349)\n */\nexport function walkProviderTree(\n  container: Type<unknown> | InjectorTypeWithProviders<unknown>,\n  visitor: WalkProviderTreeVisitor,\n  parents: Type<unknown>[],\n  dedup: Set<Type<unknown>>,\n): container is InjectorTypeWithProviders<unknown> {\n  container = resolveForwardRef(container);\n  if (!container) return false;\n\n  // The actual type which had the definition. Usually `container`, but may be an unwrapped type\n  // from `InjectorTypeWithProviders`.\n  let defType: Type<unknown> | null = null;\n\n  let injDef = getInjectorDef(container);\n  const cmpDef = !injDef && getComponentDef(container);\n  if (!injDef && !cmpDef) {\n    // `container` is not an injector type or a component type. It might be:\n    //  * An `InjectorTypeWithProviders` that wraps an injector type.\n    //  * A standalone directive or pipe that got pulled in from a standalone component's\n    //    dependencies.\n    // Try to unwrap it as an `InjectorTypeWithProviders` first.\n    const ngModule: Type<unknown> | undefined = (container as InjectorTypeWithProviders<any>)\n      .ngModule as Type<unknown> | undefined;\n    injDef = getInjectorDef(ngModule);\n    if (injDef) {\n      defType = ngModule!;\n    } else {\n      // Not a component or injector type, so ignore it.\n      return false;\n    }\n  } else if (cmpDef && !cmpDef.standalone) {\n    return false;\n  } else {\n    defType = container as Type<unknown>;\n  }\n\n  // Check for circular dependencies.\n  if (ngDevMode && parents.indexOf(defType) !== -1) {\n    const defName = stringify(defType);\n    const path = parents.map(stringify).concat(defName);\n    throw cyclicDependencyErrorWithDetails(defName, path);\n  }\n\n  // Check for multiple imports of the same module\n  const isDuplicate = dedup.has(defType);\n\n  if (cmpDef) {\n    if (isDuplicate) {\n      // This component definition has already been processed.\n      return false;\n    }\n    dedup.add(defType);\n\n    if (cmpDef.dependencies) {\n      const deps =\n        typeof cmpDef.dependencies === 'function' ? cmpDef.dependencies() : cmpDef.dependencies;\n      for (const dep of deps) {\n        walkProviderTree(dep, visitor, parents, dedup);\n      }\n    }\n  } else if (injDef) {\n    // First, include providers from any imports.\n    if (injDef.imports != null && !isDuplicate) {\n      // Before processing defType's imports, add it to the set of parents. This way, if it ends\n      // up deeply importing itself, this can be detected.\n      ngDevMode && parents.push(defType);\n      // Add it to the set of dedups. This way we can detect multiple imports of the same module\n      dedup.add(defType);\n\n      let importTypesWithProviders: InjectorTypeWithProviders<any>[] | undefined;\n      try {\n        deepForEach(injDef.imports, (imported) => {\n          if (walkProviderTree(imported, visitor, parents, dedup)) {\n            importTypesWithProviders ||= [];\n            // If the processed import is an injector type with providers, we store it in the\n            // list of import types with providers, so that we can process those afterwards.\n            importTypesWithProviders.push(imported);\n          }\n        });\n      } finally {\n        // Remove it from the parents set when finished.\n        ngDevMode && parents.pop();\n      }\n\n      // Imports which are declared with providers (TypeWithProviders) need to be processed\n      // after all imported modules are processed. This is similar to how View Engine\n      // processes/merges module imports in the metadata resolver. See: FW-1349.\n      if (importTypesWithProviders !== undefined) {\n        processInjectorTypesWithProviders(importTypesWithProviders, visitor);\n      }\n    }\n\n    if (!isDuplicate) {\n      // Track the InjectorType and add a provider for it.\n      // It's important that this is done after the def's imports.\n      const factory = getFactoryDef(defType) || (() => new defType!());\n\n      // Append extra providers to make more info available for consumers (to retrieve an injector\n      // type), as well as internally (to calculate an injection scope correctly and eagerly\n      // instantiate a `defType` when an injector is created).\n\n      // Provider to create `defType` using its factory.\n      visitor({provide: defType, useFactory: factory, deps: EMPTY_ARRAY}, defType);\n\n      // Make this `defType` available to an internal logic that calculates injector scope.\n      visitor({provide: INJECTOR_DEF_TYPES, useValue: defType, multi: true}, defType);\n\n      // Provider to eagerly instantiate `defType` via `INJECTOR_INITIALIZER`.\n      visitor(\n        {provide: ENVIRONMENT_INITIALIZER, useValue: () => inject(defType!), multi: true},\n        defType,\n      );\n    }\n\n    // Next, include providers listed on the definition itself.\n    const defProviders = injDef.providers as Array<SingleProvider | InternalEnvironmentProviders>;\n    if (defProviders != null && !isDuplicate) {\n      const injectorType = container as InjectorType<any>;\n      deepForEachProvider(defProviders, (provider) => {\n        ngDevMode && validateProvider(provider as SingleProvider, defProviders, injectorType);\n        visitor(provider, injectorType);\n      });\n    }\n  } else {\n    // Should not happen, but just in case.\n    return false;\n  }\n\n  return (\n    defType !== container && (container as InjectorTypeWithProviders<any>).providers !== undefined\n  );\n}\n\nfunction validateProvider(\n  provider: SingleProvider,\n  providers: Array<SingleProvider | InternalEnvironmentProviders>,\n  containerType: Type<unknown>,\n): void {\n  if (\n    isTypeProvider(provider) ||\n    isValueProvider(provider) ||\n    isFactoryProvider(provider) ||\n    isExistingProvider(provider)\n  ) {\n    return;\n  }\n\n  // Here we expect the provider to be a `useClass` provider (by elimination).\n  const classRef = resolveForwardRef(\n    provider && ((provider as StaticClassProvider | ClassProvider).useClass || provider.provide),\n  );\n  if (!classRef) {\n    throwInvalidProviderError(containerType, providers, provider);\n  }\n}\n\nfunction deepForEachProvider(\n  providers: Array<Provider | InternalEnvironmentProviders>,\n  fn: (provider: SingleProvider) => void,\n): void {\n  for (let provider of providers) {\n    if (isEnvironmentProviders(provider)) {\n      provider = provider.ɵproviders;\n    }\n    if (Array.isArray(provider)) {\n      deepForEachProvider(provider, fn);\n    } else {\n      fn(provider);\n    }\n  }\n}\n\nexport const USE_VALUE: string = getClosureSafeProperty<ValueProvider>({\n  provide: String,\n  useValue: getClosureSafeProperty,\n});\n\nexport function isValueProvider(value: SingleProvider): value is ValueProvider {\n  return value !== null && typeof value == 'object' && USE_VALUE in value;\n}\n\nexport function isExistingProvider(value: SingleProvider): value is ExistingProvider {\n  return !!(value && (value as ExistingProvider).useExisting);\n}\n\nexport function isFactoryProvider(value: SingleProvider): value is FactoryProvider {\n  return !!(value && (value as FactoryProvider).useFactory);\n}\n\nexport function isTypeProvider(value: SingleProvider): value is TypeProvider {\n  return typeof value === 'function';\n}\n\nexport function isClassProvider(value: SingleProvider): value is ClassProvider {\n  return !!(value as StaticClassProvider | ClassProvider).useClass;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InjectionToken} from './injection_token';\n\nexport type InjectorScope = 'root' | 'platform' | 'environment';\n\n/**\n * An internal token whose presence in an injector indicates that the injector should treat itself\n * as a root scoped injector when processing requests for unknown tokens which may indicate\n * they are provided in the root scope.\n */\nexport const INJECTOR_SCOPE = new InjectionToken<InjectorScope | null>(\n  typeof ngDevMode !== 'undefined' && ngDevMode ? 'Set Injector scope.' : '',\n);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport '../util/ng_dev_mode';\n\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {OnDestroy} from '../change_detection/lifecycle_hooks';\nimport {Type} from '../interface/type';\nimport {\n  emitInjectorToCreateInstanceEvent,\n  emitInstanceCreatedByInjectorEvent,\n  emitProviderConfiguredEvent,\n  InjectorProfilerContext,\n  runInInjectorProfilerContext,\n  setInjectorProfilerContext,\n} from '../render3/debug/injector_profiler';\nimport {FactoryFn, getFactoryDef} from '../render3/definition_factory';\nimport {\n  augmentRuntimeError,\n  cyclicDependencyError,\n  getRuntimeErrorCode,\n  prependTokenToDependencyPath,\n  throwInvalidProviderError,\n  throwMixedMultiProviderError,\n} from '../render3/errors_di';\nimport {NG_ENV_ID} from '../render3/fields';\nimport {newArray} from '../util/array_utils';\nimport {EMPTY_ARRAY} from '../util/empty';\nimport {stringify} from '../util/stringify';\n\nimport {resolveForwardRef} from './forward_ref';\nimport {ENVIRONMENT_INITIALIZER} from './initializer_token';\nimport {setInjectImplementation} from './inject_switch';\nimport {InjectionToken} from './injection_token';\nimport type {Injector} from './injector';\nimport {\n  BackwardsCompatibleInjector,\n  convertToBitFlags,\n  injectArgs,\n  setCurrentInjector,\n  THROW_IF_NOT_FOUND,\n  ɵɵinject,\n} from './injector_compatibility';\nimport {INJECTOR} from './injector_token';\nimport {\n  getInheritedInjectableDef,\n  getInjectableDef,\n  InjectorType,\n  ɵɵInjectableDeclaration,\n} from './interface/defs';\nimport {InternalInjectFlags, InjectOptions} from './interface/injector';\nimport {\n  ClassProvider,\n  ConstructorProvider,\n  EnvironmentProviders,\n  InternalEnvironmentProviders,\n  isEnvironmentProviders,\n  Provider,\n  StaticClassProvider,\n  TypeProvider,\n} from './interface/provider';\nimport {INJECTOR_DEF_TYPES} from './internal_tokens';\nimport {NullInjector} from './null_injector';\nimport {\n  isExistingProvider,\n  isFactoryProvider,\n  isTypeProvider,\n  isValueProvider,\n  SingleProvider,\n} from './provider_collection';\nimport {ProviderToken} from './provider_token';\nimport {INJECTOR_SCOPE, InjectorScope} from './scope';\nimport {setActiveConsumer} from '@angular/core/primitives/signals';\nimport {\n  Injector as PrimitivesInjector,\n  InjectionToken as PrimitivesInjectionToken,\n  NotFound,\n  isNotFound,\n} from '@angular/core/primitives/di';\n\n/**\n * Marker which indicates that a value has not yet been created from the factory function.\n */\nconst NOT_YET = {};\n\n/**\n * Marker which indicates that the factory function for a token is in the process of being called.\n *\n * If the injector is asked to inject a token with its value set to CIRCULAR, that indicates\n * injection of a dependency has recursively attempted to inject the original token, and there is\n * a circular dependency among the providers.\n */\nconst CIRCULAR = {};\n\n/**\n * A lazily initialized NullInjector.\n */\nlet NULL_INJECTOR: Injector | undefined = undefined;\n\nexport function getNullInjector(): Injector {\n  if (NULL_INJECTOR === undefined) {\n    NULL_INJECTOR = new NullInjector();\n  }\n  return NULL_INJECTOR;\n}\n\n/**\n * An entry in the injector which tracks information about the given token, including a possible\n * current value.\n */\ninterface Record<T> {\n  factory: ((_: undefined, flags?: InternalInjectFlags) => T) | undefined;\n  value: T | {};\n  multi: any[] | undefined;\n}\n\n/**\n * An `Injector` that's part of the environment injector hierarchy, which exists outside of the\n * component tree.\n *\n * @see [Types of injector hierarchies](guide/di/hierarchical-dependency-injection#types-of-injector-hierarchies)\n *\n * @publicApi\n */\nexport abstract class EnvironmentInjector implements Injector {\n  /**\n   * Retrieves an instance from the injector based on the provided token.\n   * @returns The instance from the injector if defined, otherwise the `notFoundValue`.\n   * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.\n   */\n  abstract get<T>(\n    token: ProviderToken<T>,\n    notFoundValue: undefined,\n    options: InjectOptions & {\n      optional?: false;\n    },\n  ): T;\n  /**\n   * Retrieves an instance from the injector based on the provided token.\n   * @returns The instance from the injector if defined, otherwise the `notFoundValue`.\n   * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.\n   */\n  abstract get<T>(\n    token: ProviderToken<T>,\n    notFoundValue: null | undefined,\n    options: InjectOptions,\n  ): T | null;\n  /**\n   * Retrieves an instance from the injector based on the provided token.\n   * @returns The instance from the injector if defined, otherwise the `notFoundValue`.\n   * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.\n   */\n  abstract get<T>(token: ProviderToken<T>, notFoundValue?: T, options?: InjectOptions): T;\n  /**\n   * @deprecated from v4.0.0 use ProviderToken<T>\n   * @suppress {duplicate}\n   */\n  abstract get<T>(token: string | ProviderToken<T>, notFoundValue?: any): any;\n\n  /**\n   * Runs the given function in the context of this `EnvironmentInjector`.\n   *\n   * Within the function's stack frame, [`inject`](api/core/inject) can be used to inject\n   * dependencies from this injector. Note that `inject` is only usable synchronously, and cannot be\n   * used in any asynchronous callbacks or after any `await` points.\n   *\n   * @param fn the closure to be run in the context of this injector\n   * @returns the return value of the function, if any\n   * @deprecated use the standalone function `runInInjectionContext` instead\n   */\n  abstract runInContext<ReturnT>(fn: () => ReturnT): ReturnT;\n\n  abstract destroy(): void;\n\n  /**\n   * Indicates whether the instance has already been destroyed.\n   */\n  abstract get destroyed(): boolean;\n\n  /**\n   * @internal\n   */\n  abstract onDestroy(callback: () => void): () => void;\n}\n\nexport class R3Injector extends EnvironmentInjector implements PrimitivesInjector {\n  /**\n   * Map of tokens to records which contain the instances of those tokens.\n   * - `null` value implies that we don't have the record. Used by tree-shakable injectors\n   * to prevent further searches.\n   */\n  private records = new Map<ProviderToken<any>, Record<any> | null>();\n\n  /**\n   * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.\n   */\n  private _ngOnDestroyHooks = new Set<OnDestroy>();\n\n  private _onDestroyHooks: Array<() => void> = [];\n\n  /**\n   * Flag indicating that this injector was previously destroyed.\n   */\n  override get destroyed(): boolean {\n    return this._destroyed;\n  }\n  private _destroyed = false;\n\n  private injectorDefTypes: Set<Type<unknown>>;\n\n  constructor(\n    providers: Array<Provider | EnvironmentProviders>,\n    readonly parent: Injector,\n    readonly source: string | null,\n    readonly scopes: Set<InjectorScope>,\n  ) {\n    super();\n    // Start off by creating Records for every provider.\n    forEachSingleProvider(providers as Array<Provider | InternalEnvironmentProviders>, (provider) =>\n      this.processProvider(provider),\n    );\n\n    // Make sure the INJECTOR token provides this injector.\n    this.records.set(INJECTOR, makeRecord(undefined, this));\n\n    // And `EnvironmentInjector` if the current injector is supposed to be env-scoped.\n    if (scopes.has('environment')) {\n      this.records.set(EnvironmentInjector, makeRecord(undefined, this));\n    }\n\n    // Detect whether this injector has the APP_ROOT_SCOPE token and thus should provide\n    // any injectable scoped to APP_ROOT_SCOPE.\n    const record = this.records.get(INJECTOR_SCOPE) as Record<InjectorScope | null>;\n    if (record != null && typeof record.value === 'string') {\n      this.scopes.add(record.value as InjectorScope);\n    }\n\n    this.injectorDefTypes = new Set(this.get(INJECTOR_DEF_TYPES, EMPTY_ARRAY, {self: true}));\n  }\n\n  retrieve<T>(token: PrimitivesInjectionToken<T>, options?: unknown): T | NotFound {\n    const flags: InternalInjectFlags =\n      convertToBitFlags(options as InjectOptions | undefined) || InternalInjectFlags.Default;\n    try {\n      return (this as BackwardsCompatibleInjector).get(\n        token as unknown as InjectionToken<T>,\n        // When a dependency is requested with an optional flag, DI returns null as the default value.\n        THROW_IF_NOT_FOUND as T,\n        flags,\n      );\n    } catch (e: any) {\n      if (isNotFound(e)) {\n        return e;\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * Destroy the injector and release references to every instance or provider associated with it.\n   *\n   * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a\n   * hook was found.\n   */\n  override destroy(): void {\n    assertNotDestroyed(this);\n\n    // Set destroyed = true first, in case lifecycle hooks re-enter destroy().\n    this._destroyed = true;\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      // Call all the lifecycle hooks.\n      for (const service of this._ngOnDestroyHooks) {\n        service.ngOnDestroy();\n      }\n      const onDestroyHooks = this._onDestroyHooks;\n      // Reset the _onDestroyHooks array before iterating over it to prevent hooks that unregister\n      // themselves from mutating the array during iteration.\n      this._onDestroyHooks = [];\n      for (const hook of onDestroyHooks) {\n        hook();\n      }\n    } finally {\n      // Release all references.\n      this.records.clear();\n      this._ngOnDestroyHooks.clear();\n      this.injectorDefTypes.clear();\n      setActiveConsumer(prevConsumer);\n    }\n  }\n\n  override onDestroy(callback: () => void): () => void {\n    assertNotDestroyed(this);\n    this._onDestroyHooks.push(callback);\n    return () => this.removeOnDestroy(callback);\n  }\n\n  override runInContext<ReturnT>(fn: () => ReturnT): ReturnT {\n    assertNotDestroyed(this);\n\n    const previousInjector = setCurrentInjector(this);\n    const previousInjectImplementation = setInjectImplementation(undefined);\n\n    let prevInjectContext: InjectorProfilerContext | undefined;\n    if (ngDevMode) {\n      prevInjectContext = setInjectorProfilerContext({injector: this, token: null});\n    }\n\n    try {\n      return fn();\n    } finally {\n      setCurrentInjector(previousInjector);\n      setInjectImplementation(previousInjectImplementation);\n      ngDevMode && setInjectorProfilerContext(prevInjectContext!);\n    }\n  }\n\n  override get<T>(\n    token: ProviderToken<T>,\n    notFoundValue: any = THROW_IF_NOT_FOUND,\n    options?: InjectOptions,\n  ): T {\n    assertNotDestroyed(this);\n\n    if (token.hasOwnProperty(NG_ENV_ID)) {\n      return (token as any)[NG_ENV_ID](this);\n    }\n\n    const flags = convertToBitFlags(options) as InternalInjectFlags;\n\n    // Set the injection context.\n    let prevInjectContext: InjectorProfilerContext;\n    if (ngDevMode) {\n      prevInjectContext = setInjectorProfilerContext({injector: this, token: token as Type<T>});\n    }\n    const previousInjector = setCurrentInjector(this);\n    const previousInjectImplementation = setInjectImplementation(undefined);\n    try {\n      // Check for the SkipSelf flag.\n      if (!(flags & InternalInjectFlags.SkipSelf)) {\n        // SkipSelf isn't set, check if the record belongs to this injector.\n        let record: Record<T> | undefined | null = this.records.get(token);\n        if (record === undefined) {\n          // No record, but maybe the token is scoped to this injector. Look for an injectable\n          // def with a scope matching this injector.\n          const def = couldBeInjectableType(token) && getInjectableDef(token);\n          if (def && this.injectableDefInScope(def)) {\n            // Found an injectable def and it's scoped to this injector. Pretend as if it was here\n            // all along.\n\n            if (ngDevMode) {\n              runInInjectorProfilerContext(this, token as Type<T>, () => {\n                emitProviderConfiguredEvent(token as TypeProvider);\n              });\n            }\n\n            record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);\n          } else {\n            record = null;\n          }\n          this.records.set(token, record);\n        }\n        // If a record was found, get the instance for it and return it.\n        if (record != null /* NOT null || undefined */) {\n          return this.hydrate(token, record, flags);\n        }\n      }\n\n      // Select the next injector based on the Self flag - if self is set, the next injector is\n      // the NullInjector, otherwise it's the parent.\n      const nextInjector = !(flags & InternalInjectFlags.Self) ? this.parent : getNullInjector();\n      // Set the notFoundValue based on the Optional flag - if optional is set and notFoundValue\n      // is undefined, the value is null, otherwise it's the notFoundValue.\n      notFoundValue =\n        flags & InternalInjectFlags.Optional && notFoundValue === THROW_IF_NOT_FOUND\n          ? null\n          : notFoundValue;\n      return nextInjector.get(token, notFoundValue);\n    } catch (error: any) {\n      // If there was a cyclic dependency error or a token was not found,\n      // an error is thrown at the level where the problem was detected.\n      // The error propagates up the call stack and the code below appends\n      // the current token into the path. As a result, the full path is assembled\n      // at the very top of the call stack, so the final error message can be\n      // formatted to include that path.\n      const errorCode = getRuntimeErrorCode(error);\n      if (\n        errorCode === RuntimeErrorCode.CYCLIC_DI_DEPENDENCY ||\n        errorCode === RuntimeErrorCode.PROVIDER_NOT_FOUND\n      ) {\n        // Note: we use `if (ngDevMode) { ... }` instead of an early return.\n        // ESBuild is conservative about removing dead code that follows `return;`\n        // inside a function body, so the block may remain in the bundle.\n        // Using a conditional ensures the dev-only logic is reliably tree-shaken\n        // in production builds.\n        if (ngDevMode) {\n          prependTokenToDependencyPath(error, token);\n\n          if (previousInjector) {\n            // We still have a parent injector, keep throwing\n            throw error;\n          } else {\n            // Format & throw the final error message when we don't have any previous injector\n            throw augmentRuntimeError(error, this.source);\n          }\n        } else {\n          throw new RuntimeError(errorCode, null);\n        }\n      } else {\n        throw error;\n      }\n    } finally {\n      // Lastly, restore the previous injection context.\n      setInjectImplementation(previousInjectImplementation);\n      setCurrentInjector(previousInjector);\n      ngDevMode && setInjectorProfilerContext(prevInjectContext!);\n    }\n  }\n\n  /** @internal */\n  resolveInjectorInitializers() {\n    const prevConsumer = setActiveConsumer(null);\n    const previousInjector = setCurrentInjector(this);\n    const previousInjectImplementation = setInjectImplementation(undefined);\n    let prevInjectContext: InjectorProfilerContext | undefined;\n    if (ngDevMode) {\n      prevInjectContext = setInjectorProfilerContext({injector: this, token: null});\n    }\n\n    try {\n      const initializers = this.get(ENVIRONMENT_INITIALIZER, EMPTY_ARRAY, {self: true});\n      if (ngDevMode && !Array.isArray(initializers)) {\n        throw new RuntimeError(\n          RuntimeErrorCode.INVALID_MULTI_PROVIDER,\n          'Unexpected type of the `ENVIRONMENT_INITIALIZER` token value ' +\n            `(expected an array, but got ${typeof initializers}). ` +\n            'Please check that the `ENVIRONMENT_INITIALIZER` token is configured as a ' +\n            '`multi: true` provider.',\n        );\n      }\n      for (const initializer of initializers) {\n        initializer();\n      }\n    } finally {\n      setCurrentInjector(previousInjector);\n      setInjectImplementation(previousInjectImplementation);\n      ngDevMode && setInjectorProfilerContext(prevInjectContext!);\n      setActiveConsumer(prevConsumer);\n    }\n  }\n\n  override toString() {\n    const tokens: string[] = [];\n    const records = this.records;\n    for (const token of records.keys()) {\n      tokens.push(stringify(token));\n    }\n    return `R3Injector[${tokens.join(', ')}]`;\n  }\n\n  /**\n   * Process a `SingleProvider` and add it.\n   */\n  private processProvider(provider: SingleProvider): void {\n    // Determine the token from the provider. Either it's its own token, or has a {provide: ...}\n    // property.\n    provider = resolveForwardRef(provider);\n    let token: any = isTypeProvider(provider)\n      ? provider\n      : resolveForwardRef(provider && provider.provide);\n\n    // Construct a `Record` for the provider.\n    const record = providerToRecord(provider);\n    if (ngDevMode) {\n      runInInjectorProfilerContext(this, token, () => {\n        // Emit InjectorProfilerEventType.Create if provider is a value provider because\n        // these are the only providers that do not go through the value hydration logic\n        // where this event would normally be emitted from.\n        if (isValueProvider(provider)) {\n          emitInjectorToCreateInstanceEvent(token);\n          emitInstanceCreatedByInjectorEvent(provider.useValue);\n        }\n\n        emitProviderConfiguredEvent(provider);\n      });\n    }\n\n    if (!isTypeProvider(provider) && provider.multi === true) {\n      // If the provider indicates that it's a multi-provider, process it specially.\n      // First check whether it's been defined already.\n      let multiRecord = this.records.get(token);\n      if (multiRecord) {\n        // It has. Throw a nice error if\n        if (ngDevMode && multiRecord.multi === undefined) {\n          throwMixedMultiProviderError();\n        }\n      } else {\n        multiRecord = makeRecord(undefined, NOT_YET, true);\n        multiRecord.factory = () => injectArgs(multiRecord!.multi!);\n        this.records.set(token, multiRecord);\n      }\n      token = provider;\n      multiRecord.multi!.push(provider);\n    } else {\n      if (ngDevMode) {\n        const existing = this.records.get(token);\n        if (existing && existing.multi !== undefined) {\n          throwMixedMultiProviderError();\n        }\n      }\n    }\n    this.records.set(token, record);\n  }\n\n  private hydrate<T>(token: ProviderToken<T>, record: Record<T>, flags: InternalInjectFlags): T {\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      if (record.value === CIRCULAR) {\n        throw cyclicDependencyError(stringify(token));\n      } else if (record.value === NOT_YET) {\n        record.value = CIRCULAR;\n\n        if (ngDevMode) {\n          runInInjectorProfilerContext(this, token as Type<T>, () => {\n            emitInjectorToCreateInstanceEvent(token);\n            record.value = record.factory!(undefined, flags);\n            emitInstanceCreatedByInjectorEvent(record.value);\n          });\n        } else {\n          record.value = record.factory!(undefined, flags);\n        }\n      }\n      if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) {\n        this._ngOnDestroyHooks.add(record.value);\n      }\n      return record.value as T;\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n  }\n\n  private injectableDefInScope(def: ɵɵInjectableDeclaration<any>): boolean {\n    if (!def.providedIn) {\n      return false;\n    }\n    const providedIn = resolveForwardRef(def.providedIn);\n    if (typeof providedIn === 'string') {\n      return providedIn === 'any' || this.scopes.has(providedIn);\n    } else {\n      return this.injectorDefTypes.has(providedIn);\n    }\n  }\n\n  private removeOnDestroy(callback: () => void): void {\n    const destroyCBIdx = this._onDestroyHooks.indexOf(callback);\n    if (destroyCBIdx !== -1) {\n      this._onDestroyHooks.splice(destroyCBIdx, 1);\n    }\n  }\n}\n\nfunction injectableDefOrInjectorDefFactory(token: ProviderToken<any>): FactoryFn<any> {\n  // Most tokens will have an injectable def directly on them, which specifies a factory directly.\n  const injectableDef = getInjectableDef(token);\n  const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);\n\n  if (factory !== null) {\n    return factory;\n  }\n\n  // InjectionTokens should have an injectable def (ɵprov) and thus should be handled above.\n  // If it's missing that, it's an error.\n  if (token instanceof InjectionToken) {\n    throw new RuntimeError(\n      RuntimeErrorCode.INVALID_INJECTION_TOKEN,\n      ngDevMode && `Token ${stringify(token)} is missing a ɵprov definition.`,\n    );\n  }\n\n  // Undecorated types can sometimes be created if they have no constructor arguments.\n  if (token instanceof Function) {\n    return getUndecoratedInjectableFactory(token);\n  }\n\n  // There was no way to resolve a factory for this token.\n  throw new RuntimeError(RuntimeErrorCode.INVALID_INJECTION_TOKEN, ngDevMode && 'unreachable');\n}\n\nfunction getUndecoratedInjectableFactory(token: Function) {\n  // If the token has parameters then it has dependencies that we cannot resolve implicitly.\n  const paramLength = token.length;\n  if (paramLength > 0) {\n    throw new RuntimeError(\n      RuntimeErrorCode.INVALID_INJECTION_TOKEN,\n      ngDevMode &&\n        `Can't resolve all parameters for ${stringify(token)}: (${newArray(paramLength, '?').join(\n          ', ',\n        )}).`,\n    );\n  }\n\n  // The constructor function appears to have no parameters.\n  // This might be because it inherits from a super-class. In which case, use an injectable\n  // def from an ancestor if there is one.\n  // Otherwise this really is a simple class with no dependencies, so return a factory that\n  // just instantiates the zero-arg constructor.\n  const inheritedInjectableDef = getInheritedInjectableDef(token);\n  if (inheritedInjectableDef !== null) {\n    return () => inheritedInjectableDef.factory(token as Type<any>);\n  } else {\n    return () => new (token as Type<any>)();\n  }\n}\n\nfunction providerToRecord(provider: SingleProvider): Record<any> {\n  if (isValueProvider(provider)) {\n    return makeRecord(undefined, provider.useValue);\n  } else {\n    const factory: ((type?: Type<unknown>, flags?: InternalInjectFlags) => any) | undefined =\n      providerToFactory(provider);\n    return makeRecord(factory, NOT_YET);\n  }\n}\n\n/**\n * Converts a `SingleProvider` into a factory function.\n *\n * @param provider provider to convert to factory\n */\nexport function providerToFactory(\n  provider: SingleProvider,\n  ngModuleType?: InjectorType<any>,\n  providers?: any[],\n): (type?: Type<unknown>, flags?: number) => any {\n  let factory: ((type?: Type<unknown>, flags?: InternalInjectFlags) => any) | undefined = undefined;\n  if (ngDevMode && isEnvironmentProviders(provider)) {\n    throwInvalidProviderError(undefined, providers, provider);\n  }\n\n  if (isTypeProvider(provider)) {\n    const unwrappedProvider = resolveForwardRef(provider);\n    return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);\n  } else {\n    if (isValueProvider(provider)) {\n      factory = () => resolveForwardRef(provider.useValue);\n    } else if (isFactoryProvider(provider)) {\n      factory = () => provider.useFactory(...injectArgs(provider.deps || []));\n    } else if (isExistingProvider(provider)) {\n      factory = (_, flags) =>\n        ɵɵinject(\n          resolveForwardRef(provider.useExisting),\n          flags !== undefined && flags & InternalInjectFlags.Optional\n            ? InternalInjectFlags.Optional\n            : undefined,\n        );\n    } else {\n      const classRef = resolveForwardRef(\n        provider &&\n          ((provider as StaticClassProvider | ClassProvider).useClass || provider.provide),\n      );\n      if (ngDevMode && !classRef) {\n        throwInvalidProviderError(ngModuleType, providers, provider);\n      }\n      if (hasDeps(provider)) {\n        factory = () => new classRef(...injectArgs(provider.deps));\n      } else {\n        return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);\n      }\n    }\n  }\n  return factory;\n}\n\nexport function assertNotDestroyed(injector: R3Injector): void {\n  if (injector.destroyed) {\n    throw new RuntimeError(\n      RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED,\n      ngDevMode && 'Injector has already been destroyed.',\n    );\n  }\n}\n\nfunction makeRecord<T>(\n  factory: (() => T) | undefined,\n  value: T | {},\n  multi: boolean = false,\n): Record<T> {\n  return {\n    factory: factory,\n    value: value,\n    multi: multi ? [] : undefined,\n  };\n}\n\nfunction hasDeps(\n  value: ClassProvider | ConstructorProvider | StaticClassProvider,\n): value is ClassProvider & {deps: any[]} {\n  return !!(value as any).deps;\n}\n\nfunction hasOnDestroy(value: any): value is OnDestroy {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof (value as OnDestroy).ngOnDestroy === 'function'\n  );\n}\n\nfunction couldBeInjectableType(value: any): value is ProviderToken<any> {\n  return (\n    typeof value === 'function' ||\n    (typeof value === 'object' && value.ngMetadataName === 'InjectionToken')\n  );\n}\n\nfunction forEachSingleProvider(\n  providers: Array<Provider | EnvironmentProviders>,\n  fn: (provider: SingleProvider) => void,\n): void {\n  for (const provider of providers) {\n    if (Array.isArray(provider)) {\n      forEachSingleProvider(provider, fn);\n    } else if (provider && isEnvironmentProviders(provider)) {\n      forEachSingleProvider(provider.ɵproviders, fn);\n    } else {\n      fn(provider as SingleProvider);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {\n  InjectorProfilerContext,\n  setInjectorProfilerContext,\n} from '../render3/debug/injector_profiler';\n\nimport {getInjectImplementation, setInjectImplementation} from './inject_switch';\nimport type {Injector} from './injector';\nimport {getCurrentInjector, setCurrentInjector, RetrievingInjector} from './injector_compatibility';\nimport {assertNotDestroyed, R3Injector} from './r3_injector';\nimport {Injector as PrimitivesInjector} from '@angular/core/primitives/di';\n\n/**\n * Runs the given function in the [context](guide/di/dependency-injection-context) of the given\n * `Injector`.\n *\n * Within the function's stack frame, [`inject`](api/core/inject) can be used to inject dependencies\n * from the given `Injector`. Note that `inject` is only usable synchronously, and cannot be used in\n * any asynchronous callbacks or after any `await` points.\n *\n * @see [Run within an injection context](guide/di/dependency-injection-context#run-within-an-injection-context)\n *\n * @param injector the injector which will satisfy calls to [`inject`](api/core/inject) while `fn`\n *     is executing\n * @param fn the closure to be run in the context of `injector`\n * @returns the return value of the function, if any\n * @publicApi\n */\nexport function runInInjectionContext<ReturnT>(injector: Injector, fn: () => ReturnT): ReturnT {\n  let internalInjector: PrimitivesInjector;\n  if (injector instanceof R3Injector) {\n    assertNotDestroyed(injector);\n    internalInjector = injector;\n  } else {\n    internalInjector = new RetrievingInjector(injector);\n  }\n\n  let prevInjectorProfilerContext: InjectorProfilerContext;\n  if (ngDevMode) {\n    prevInjectorProfilerContext = setInjectorProfilerContext({injector, token: null});\n  }\n  const prevInjector = setCurrentInjector(internalInjector);\n  const previousInjectImplementation = setInjectImplementation(undefined);\n  try {\n    return fn();\n  } finally {\n    setCurrentInjector(prevInjector);\n    ngDevMode && setInjectorProfilerContext(prevInjectorProfilerContext!);\n    setInjectImplementation(previousInjectImplementation);\n  }\n}\n\n/**\n * Whether the current stack frame is inside an injection context.\n */\nexport function isInInjectionContext(): boolean {\n  return getInjectImplementation() !== undefined || getCurrentInjector() != null;\n}\n/**\n * Asserts that the current stack frame is within an [injection\n * context](guide/di/dependency-injection-context) and has access to `inject`.\n *\n * @param debugFn a reference to the function making the assertion (used for the error message).\n *\n * @see [Asserts the context](guide/di/dependency-injection-context#asserts-the-context)\n *\n * @publicApi\n */\nexport function assertInInjectionContext(debugFn: Function): void {\n  // Taking a `Function` instead of a string name here prevents the unminified name of the function\n  // from being retained in the bundle regardless of minification.\n  if (!isInInjectionContext()) {\n    throw new RuntimeError(\n      RuntimeErrorCode.MISSING_INJECTION_CONTEXT,\n      ngDevMode &&\n        debugFn.name +\n          '() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`',\n    );\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {AnimationLViewData} from '../../animation/interfaces';\nimport type {ChangeDetectionScheduler} from '../../change_detection/scheduling/zoneless_scheduling';\nimport {TDeferBlockDetails} from '../../defer/interfaces';\nimport type {Injector} from '../../di/injector';\nimport {ProviderToken} from '../../di/provider_token';\nimport {DehydratedView} from '../../hydration/interfaces';\nimport {SchemaMetadata} from '../../metadata/schema';\nimport {Sanitizer} from '../../sanitization/sanitizer';\nimport type {AfterRenderSequence} from '../after_render/manager';\nimport type {ReactiveLViewConsumer} from '../reactive_lview_consumer';\nimport type {ViewEffectNode} from '../reactivity/effect';\n\nimport type {LContainer} from './container';\nimport {\n  ComponentDef,\n  ComponentTemplate,\n  DirectiveDef,\n  DirectiveDefList,\n  HostBindingsFunction,\n  PipeDef,\n  PipeDefList,\n  ViewQueriesFunction,\n} from './definition';\nimport {I18nUpdateOpCodes, TI18n, TIcu} from './i18n';\nimport {TConstants, TNode} from './node';\nimport type {LQueries, TQueries} from './query';\nimport {Renderer, RendererFactory} from './renderer';\nimport {RElement} from './renderer_dom';\nimport {TStylingKey, TStylingRange} from './styling';\n\n// Below are constants for LView indices to help us look up LView members\n// without having to remember the specific indices.\n// Uglify will inline these when minifying so there shouldn't be a cost.\nexport const HOST = 0;\nexport const TVIEW = 1;\n\n// Shared with LContainer\nexport const FLAGS = 2;\nexport const PARENT = 3;\nexport const NEXT = 4;\nexport const T_HOST = 5;\n// End shared with LContainer\n\nexport const HYDRATION = 6;\nexport const CLEANUP = 7;\nexport const CONTEXT = 8;\nexport const INJECTOR = 9;\nexport const ENVIRONMENT = 10;\nexport const RENDERER = 11;\nexport const CHILD_HEAD = 12;\nexport const CHILD_TAIL = 13;\n// FIXME(misko): Investigate if the three declarations aren't all same thing.\nexport const DECLARATION_VIEW = 14;\nexport const DECLARATION_COMPONENT_VIEW = 15;\nexport const DECLARATION_LCONTAINER = 16;\nexport const PREORDER_HOOK_FLAGS = 17;\nexport const QUERIES = 18;\nexport const ID = 19;\nexport const EMBEDDED_VIEW_INJECTOR = 20;\nexport const ON_DESTROY_HOOKS = 21;\nexport const EFFECTS_TO_SCHEDULE = 22;\nexport const EFFECTS = 23;\nexport const REACTIVE_TEMPLATE_CONSUMER = 24;\nexport const AFTER_RENDER_SEQUENCES_TO_ADD = 25;\nexport const ANIMATIONS = 26;\n\n/**\n * Size of LView's header. Necessary to adjust for it when setting slots.\n *\n * IMPORTANT: `HEADER_OFFSET` should only be referred to the in the `ɵɵ*` instructions to translate\n * instruction index into `LView` index. All other indexes should be in the `LView` index space and\n * there should be no need to refer to `HEADER_OFFSET` anywhere else.\n */\nexport const HEADER_OFFSET = 27;\n\n// This interface replaces the real LView interface if it is an arg or a\n// return value of a public instruction. This ensures we don't need to expose\n// the actual interface, which should be kept private.\nexport interface OpaqueViewState {\n  '__brand__': 'Brand for OpaqueViewState that nothing will match';\n}\n\n/**\n * `LView` stores all of the information needed to process the instructions as\n * they are invoked from the template. Each embedded view and component view has its\n * own `LView`. When processing a particular view, we set the `viewData` to that\n * `LView`. When that view is done processing, the `viewData` is set back to\n * whatever the original `viewData` was before (the parent `LView`).\n *\n * Keeping separate state for each view facilities view insertion / deletion, so we\n * don't have to edit the data array based on which views are present.\n */\nexport interface LView<T = unknown> extends Array<any> {\n  /**\n   * The node into which this `LView` is inserted.\n   */\n  [HOST]: RElement | null;\n\n  /**\n   * The static data for this view. We need a reference to this so we can easily walk up the\n   * node tree in DI and get the TView.data array associated with a node (where the\n   * directive defs are stored).\n   */\n  readonly [TVIEW]: TView;\n\n  /** Flags for this view. See LViewFlags for more info. */\n  [FLAGS]: LViewFlags;\n\n  /**\n   * This may store an {@link LView} or {@link LContainer}.\n   *\n   * `LView` - The parent view. This is needed when we exit the view and must restore the previous\n   * LView. Without this, the render method would have to keep a stack of\n   * views as it is recursively rendering templates.\n   *\n   * `LContainer` - The current view is part of a container, and is an embedded view.\n   */\n  [PARENT]: LView | LContainer | null;\n\n  /**\n   *\n   * The next sibling LView or LContainer.\n   *\n   * Allows us to propagate between sibling view states that aren't in the same\n   * container. Embedded views already have a node.next, but it is only set for\n   * views in the same container. We need a way to link component views and views\n   * across containers as well.\n   */\n  [NEXT]: LView | LContainer | null;\n\n  /** Queries active for this view - nodes from a view are reported to those queries. */\n  [QUERIES]: LQueries | null;\n\n  /**\n   * Store the `TNode` of the location where the current `LView` is inserted into.\n   *\n   * Given:\n   * ```html\n   * <div>\n   *   <ng-template><span></span></ng-template>\n   * </div>\n   * ```\n   *\n   * We end up with two `TView`s.\n   * - `parent` `TView` which contains `<div><!-- anchor --></div>`\n   * - `child` `TView` which contains `<span></span>`\n   *\n   * Typically the `child` is inserted into the declaration location of the `parent`, but it can be\n   * inserted anywhere. Because it can be inserted anywhere it is not possible to store the\n   * insertion information in the `TView` and instead we must store it in the `LView[T_HOST]`.\n   *\n   * So to determine where is our insertion parent we would execute:\n   * ```ts\n   * const parentLView = lView[PARENT];\n   * const parentTNode = lView[T_HOST];\n   * const insertionParent = parentLView[parentTNode.index];\n   * ```\n   *\n   *\n   * If `null`, this is the root view of an application (root component is in this view) and it has\n   * no parents.\n   */\n  [T_HOST]: TNode | null;\n\n  /**\n   * When a view is destroyed, listeners need to be released and outputs need to be\n   * unsubscribed. This context array stores both listener functions wrapped with\n   * their context and output subscription instances for a particular view.\n   *\n   * These change per LView instance, so they cannot be stored on TView. Instead,\n   * TView.cleanup saves an index to the necessary context in this array.\n   *\n   * After `LView` is created it is possible to attach additional instance specific functions at the\n   * end of the `lView[CLEANUP]` because we know that no more `T` level cleanup functions will be\n   * added here.\n   */\n  [CLEANUP]: any[] | null;\n\n  /**\n   * - For dynamic views, this is the context with which to render the template (e.g.\n   *   `NgForContext`), or `{}` if not defined explicitly.\n   * - For root view of the root component it's a reference to the component instance itself.\n   * - For components, the context is a reference to the component instance itself.\n   * - For inline views, the context is null.\n   */\n  [CONTEXT]: T;\n\n  /** A Module Injector to be used as fall back after Element Injectors are consulted. */\n  readonly [INJECTOR]: Injector;\n\n  /**\n   * Contextual data that is shared across multiple instances of `LView` in the same application.\n   */\n  [ENVIRONMENT]: LViewEnvironment;\n\n  /** Renderer to be used for this view. */\n  [RENDERER]: Renderer;\n\n  /**\n   * Reference to the first LView or LContainer beneath this LView in\n   * the hierarchy.\n   *\n   * Necessary to store this so views can traverse through their nested views\n   * to remove listeners and call onDestroy callbacks.\n   */\n  [CHILD_HEAD]: LView | LContainer | null;\n\n  /**\n   * The last LView or LContainer beneath this LView in the hierarchy.\n   *\n   * The tail allows us to quickly add a new state to the end of the view list\n   * without having to propagate starting from the first child.\n   */\n  [CHILD_TAIL]: LView | LContainer | null;\n\n  /**\n   * View where this view's template was declared.\n   *\n   * The template for a dynamically created view may be declared in a different view than\n   * it is inserted. We already track the \"insertion view\" (view where the template was\n   * inserted) in LView[PARENT], but we also need access to the \"declaration view\"\n   * (view where the template was declared). Otherwise, we wouldn't be able to call the\n   * view's template function with the proper contexts. Context should be inherited from\n   * the declaration view tree, not the insertion view tree.\n   *\n   * Example (AppComponent template):\n   *\n   * <ng-template #foo></ng-template>       <-- declared here -->\n   * <some-comp [tpl]=\"foo\"></some-comp>    <-- inserted inside this component -->\n   *\n   * The <ng-template> above is declared in the AppComponent template, but it will be passed into\n   * SomeComp and inserted there. In this case, the declaration view would be the AppComponent,\n   * but the insertion view would be SomeComp. When we are removing views, we would want to\n   * traverse through the insertion view to clean up listeners. When we are calling the\n   * template function during change detection, we need the declaration view to get inherited\n   * context.\n   */\n  [DECLARATION_VIEW]: LView | null;\n\n  /**\n   * Points to the declaration component view, used to track transplanted `LView`s.\n   *\n   * See: `DECLARATION_VIEW` which points to the actual `LView` where it was declared, whereas\n   * `DECLARATION_COMPONENT_VIEW` points to the component which may not be same as\n   * `DECLARATION_VIEW`.\n   *\n   * Example:\n   * ```html\n   * <#VIEW #myComp>\n   *  <div *ngIf=\"true\">\n   *   <ng-template #myTmpl>...</ng-template>\n   *  </div>\n   * </#VIEW>\n   * ```\n   * In the above case `DECLARATION_VIEW` for `myTmpl` points to the `LView` of `ngIf` whereas\n   * `DECLARATION_COMPONENT_VIEW` points to `LView` of the `myComp` which owns the template.\n   *\n   * The reason for this is that all embedded views are always check-always whereas the component\n   * view can be check-always or on-push. When we have a transplanted view it is important to\n   * determine if we have transplanted a view from check-always declaration to on-push insertion\n   * point. In such a case the transplanted view needs to be added to the `LContainer` in the\n   * declared `LView` and CD during the declared view CD (in addition to the CD at the insertion\n   * point.) (Any transplanted views which are intra Component are of no interest because the CD\n   * strategy of declaration and insertion will always be the same, because it is the same\n   * component.)\n   *\n   * Queries already track moved views in `LView[DECLARATION_LCONTAINER]` and\n   * `LContainer[MOVED_VIEWS]`. However the queries also track `LView`s which moved within the same\n   * component `LView`. Transplanted views are a subset of moved views, and we use\n   * `DECLARATION_COMPONENT_VIEW` to differentiate them. As in this example.\n   *\n   * Example showing intra component `LView` movement.\n   * ```html\n   * <#VIEW #myComp>\n   *   <div *ngIf=\"condition; then thenBlock else elseBlock\"></div>\n   *   <ng-template #thenBlock>Content to render when condition is true.</ng-template>\n   *   <ng-template #elseBlock>Content to render when condition is false.</ng-template>\n   * </#VIEW>\n   * ```\n   * The `thenBlock` and `elseBlock` is moved but not transplanted.\n   *\n   * Example showing inter component `LView` movement (transplanted view).\n   * ```html\n   * <#VIEW #myComp>\n   *   <ng-template #myTmpl>...</ng-template>\n   *   <insertion-component [template]=\"myTmpl\"></insertion-component>\n   * </#VIEW>\n   * ```\n   * In the above example `myTmpl` is passed into a different component. If `insertion-component`\n   * instantiates `myTmpl` and `insertion-component` is on-push then the `LContainer` needs to be\n   * marked as containing transplanted views and those views need to be CD as part of the\n   * declaration CD.\n   *\n   *\n   * When change detection runs, it iterates over `[MOVED_VIEWS]` and CDs any child `LView`s where\n   * the `DECLARATION_COMPONENT_VIEW` of the current component and the child `LView` does not match\n   * (it has been transplanted across components.)\n   *\n   * Note: `[DECLARATION_COMPONENT_VIEW]` points to itself if the LView is a component view (the\n   *       simplest / most common case).\n   *\n   * see also:\n   *   - https://hackmd.io/@mhevery/rJUJsvv9H write up of the problem\n   *   - `LContainer[HAS_TRANSPLANTED_VIEWS]` which marks which `LContainer` has transplanted views.\n   *   - `LContainer[TRANSPLANT_HEAD]` and `LContainer[TRANSPLANT_TAIL]` storage for transplanted\n   *   - `LView[DECLARATION_LCONTAINER]` similar problem for queries\n   *   - `LContainer[MOVED_VIEWS]` similar problem for queries\n   */\n  [DECLARATION_COMPONENT_VIEW]: LView;\n\n  /**\n   * A declaration point of embedded views (ones instantiated based on the content of a\n   * <ng-template>), null for other types of views.\n   *\n   * We need to track all embedded views created from a given declaration point so we can prepare\n   * query matches in a proper order (query matches are ordered based on their declaration point and\n   * _not_ the insertion point).\n   */\n  [DECLARATION_LCONTAINER]: LContainer | null;\n\n  /**\n   * More flags for this view. See PreOrderHookFlags for more info.\n   */\n  [PREORDER_HOOK_FLAGS]: PreOrderHookFlags;\n\n  /** Unique ID of the view. Used for `__ngContext__` lookups in the `LView` registry. */\n  [ID]: number;\n\n  /**\n   * A container related to hydration annotation information that's associated with this LView.\n   */\n  [HYDRATION]: DehydratedView | null;\n\n  /**\n   * Optional injector assigned to embedded views that takes\n   * precedence over the element and module injectors.\n   */\n  readonly [EMBEDDED_VIEW_INJECTOR]: Injector | null;\n\n  /**\n   * Effect scheduling operations that need to run during this views's update pass.\n   */\n  [EFFECTS_TO_SCHEDULE]: Array<() => void> | null;\n\n  [EFFECTS]: Set<ViewEffectNode> | null;\n\n  /**\n   * A collection of callbacks functions that are executed when a given LView is destroyed. Those\n   * are user defined, LView-specific destroy callbacks that don't have any corresponding TView\n   * entries.\n   */\n  [ON_DESTROY_HOOKS]: Array<() => void> | null;\n\n  /**\n   * The `Consumer` for this `LView`'s template so that signal reads can be tracked.\n   *\n   * This is initially `null` and gets assigned a consumer after template execution\n   * if any signals were read.\n   */\n  [REACTIVE_TEMPLATE_CONSUMER]: ReactiveLViewConsumer | null;\n\n  // AfterRenderSequences that need to be scheduled\n  [AFTER_RENDER_SEQUENCES_TO_ADD]: AfterRenderSequence[] | null;\n\n  // Enter animations that apply to nodes in this view\n  [ANIMATIONS]: AnimationLViewData | null;\n}\n\n/**\n * Contextual data that is shared across multiple instances of `LView` in the same application.\n */\nexport interface LViewEnvironment {\n  /** Factory to be used for creating Renderer. */\n  rendererFactory: RendererFactory;\n\n  /** An optional custom sanitizer. */\n  sanitizer: Sanitizer | null;\n\n  /** Scheduler for change detection to notify when application state changes. */\n  changeDetectionScheduler: ChangeDetectionScheduler | null;\n\n  /**\n   * Whether `ng-reflect-*` attributes should be produced in dev mode\n   * (always disabled in prod mode).\n   */\n  ngReflect: boolean;\n}\n\n/** Flags associated with an LView (saved in LView[FLAGS]) */\nexport const enum LViewFlags {\n  /** The state of the init phase on the first 2 bits */\n  InitPhaseStateIncrementer = 0b00000000001,\n  InitPhaseStateMask = 0b00000000011,\n\n  /**\n   * Whether or not the view is in creationMode.\n   *\n   * This must be stored in the view rather than using `data` as a marker so that\n   * we can properly support embedded views. Otherwise, when exiting a child view\n   * back into the parent view, `data` will be defined and `creationMode` will be\n   * improperly reported as false.\n   */\n  CreationMode = 1 << 2,\n\n  /**\n   * Whether or not this LView instance is on its first processing pass.\n   *\n   * An LView instance is considered to be on its \"first pass\" until it\n   * has completed one creation mode run and one update mode run. At this\n   * time, the flag is turned off.\n   */\n  FirstLViewPass = 1 << 3,\n\n  /** Whether this view has default change detection strategy (checks always) or onPush */\n  CheckAlways = 1 << 4,\n\n  /** Whether there are any i18n blocks inside this LView. */\n  HasI18n = 1 << 5,\n\n  /** Whether or not this view is currently dirty (needing check) */\n  Dirty = 1 << 6,\n\n  /** Whether or not this view is currently attached to change detection tree. */\n  Attached = 1 << 7,\n\n  /** Whether or not this view is destroyed. */\n  Destroyed = 1 << 8,\n\n  /** Whether or not this view is the root view */\n  IsRoot = 1 << 9,\n\n  /**\n   * Whether this moved LView needs to be refreshed. Similar to the Dirty flag, but used for\n   * transplanted and signal views where the parent/ancestor views are not marked dirty as well.\n   * i.e. \"Refresh just this view\". Used in conjunction with the HAS_CHILD_VIEWS_TO_REFRESH\n   * flag.\n   */\n  RefreshView = 1 << 10,\n\n  /** Indicates that the view **or any of its ancestors** have an embedded view injector. */\n  HasEmbeddedViewInjector = 1 << 11,\n\n  /** Indicates that the view was created with `signals: true`. */\n  SignalView = 1 << 12,\n\n  /**\n   * Indicates that this LView has a view underneath it that needs to be refreshed during change\n   * detection. This flag indicates that even if this view is not dirty itself, we still need to\n   * traverse its children during change detection.\n   */\n  HasChildViewsToRefresh = 1 << 13,\n\n  /**\n   * This is the count of the bits the 1 was shifted above (base 10)\n   */\n  IndexWithinInitPhaseShift = 14,\n\n  /**\n   * Index of the current init phase on last 21 bits\n   */\n  IndexWithinInitPhaseIncrementer = 1 << IndexWithinInitPhaseShift,\n\n  // Subtracting 1 gives all 1s to the right of the initial shift\n  // So `(1 << 3) - 1` would give 3 1s: 1 << 3 = 0b01000, subtract 1 = 0b00111\n  IndexWithinInitPhaseReset = (1 << IndexWithinInitPhaseShift) - 1,\n}\n\n/**\n * Possible states of the init phase:\n * - 00: OnInit hooks to be run.\n * - 01: AfterContentInit hooks to be run\n * - 10: AfterViewInit hooks to be run\n * - 11: All init hooks have been run\n */\nexport const enum InitPhaseState {\n  OnInitHooksToBeRun = 0b00,\n  AfterContentInitHooksToBeRun = 0b01,\n  AfterViewInitHooksToBeRun = 0b10,\n  InitPhaseCompleted = 0b11,\n}\n\n/** More flags associated with an LView (saved in LView[PREORDER_HOOK_FLAGS]) */\nexport const enum PreOrderHookFlags {\n  /**\n     The index of the next pre-order hook to be called in the hooks array, on the first 16\n     bits\n   */\n  IndexOfTheNextPreOrderHookMaskMask = 0b01111111111111111,\n\n  /**\n   * The number of init hooks that have already been called, on the last 16 bits\n   */\n  NumberOfInitHooksCalledIncrementer = 0b010000000000000000,\n  NumberOfInitHooksCalledShift = 16,\n  NumberOfInitHooksCalledMask = 0b11111111111111110000000000000000,\n}\n\n/**\n * Stores a set of OpCodes to process `HostBindingsFunction` associated with a current view.\n *\n * In order to invoke `HostBindingsFunction` we need:\n * 1. 'elementIdx`: Index to the element associated with the `HostBindingsFunction`.\n * 2. 'directiveIdx`: Index to the directive associated with the `HostBindingsFunction`. (This will\n *    become the context for the `HostBindingsFunction` invocation.)\n * 3. `bindingRootIdx`: Location where the bindings for the `HostBindingsFunction` start. Internally\n *    `HostBindingsFunction` binding indexes start from `0` so we need to add `bindingRootIdx` to\n *    it.\n * 4. `HostBindingsFunction`: A host binding function to execute.\n *\n * The above information needs to be encoded into the `HostBindingOpCodes` in an efficient manner.\n *\n * 1. `elementIdx` is encoded into the `HostBindingOpCodes` as `~elementIdx` (so a negative number);\n * 2. `directiveIdx`\n * 3. `bindingRootIdx`\n * 4. `HostBindingsFunction` is passed in as is.\n *\n * The `HostBindingOpCodes` array contains:\n * - negative number to select the element index.\n * - followed by 1 or more of:\n *    - a number to select the directive index\n *    - a number to select the bindingRoot index\n *    - and a function to invoke.\n *\n * ## Example\n *\n * ```ts\n * const hostBindingOpCodes = [\n *   ~30,                               // Select element 30\n *   40, 45, MyDir.ɵdir.hostBindings    // Invoke host bindings on MyDir on element 30;\n *                                      // directiveIdx = 40; bindingRootIdx = 45;\n *   50, 55, OtherDir.ɵdir.hostBindings // Invoke host bindings on OtherDire on element 30\n *                                      // directiveIdx = 50; bindingRootIdx = 55;\n * ]\n * ```\n *\n * ## Pseudocode\n * ```ts\n * const hostBindingOpCodes = tView.hostBindingOpCodes;\n * if (hostBindingOpCodes === null) return;\n * for (let i = 0; i < hostBindingOpCodes.length; i++) {\n *   const opCode = hostBindingOpCodes[i] as number;\n *   if (opCode < 0) {\n *     // Negative numbers are element indexes.\n *     setSelectedIndex(~opCode);\n *   } else {\n *     // Positive numbers are NumberTuple which store bindingRootIndex and directiveIndex.\n *     const directiveIdx = opCode;\n *     const bindingRootIndx = hostBindingOpCodes[++i] as number;\n *     const hostBindingFn = hostBindingOpCodes[++i] as HostBindingsFunction<any>;\n *     setBindingRootForHostBindings(bindingRootIndx, directiveIdx);\n *     const context = lView[directiveIdx];\n *     hostBindingFn(RenderFlags.Update, context);\n *   }\n * }\n * ```\n *\n */\nexport interface HostBindingOpCodes extends Array<number | HostBindingsFunction<any>> {\n  __brand__: 'HostBindingOpCodes';\n  debug?: string[];\n}\n\n/**\n * Explicitly marks `TView` as a specific type in `ngDevMode`\n *\n * It is useful to know conceptually what time of `TView` we are dealing with when\n * debugging an application (even if the runtime does not need it.) For this reason\n * we store this information in the `ngDevMode` `TView` and than use it for\n * better debugging experience.\n */\nexport const enum TViewType {\n  /**\n   * Root `TView` is the used to bootstrap components into. It is used in conjunction with\n   * `LView` which takes an existing DOM node not owned by Angular and wraps it in `TView`/`LView`\n   * so that other components can be loaded into it.\n   */\n  Root = 0,\n\n  /**\n   * `TView` associated with a Component. This would be the `TView` directly associated with the\n   * component view (as opposed an `Embedded` `TView` which would be a child of `Component` `TView`)\n   */\n  Component = 1,\n\n  /**\n   * `TView` associated with a template. Such as `*ngIf`, `<ng-template>` etc... A `Component`\n   * can have zero or more `Embedded` `TView`s.\n   */\n  Embedded = 2,\n}\n\n/**\n * The static data for an LView (shared between all templates of a\n * given type).\n *\n * Stored on the `ComponentDef.tView`.\n */\nexport interface TView {\n  /**\n   * Type of `TView` (`Root`|`Component`|`Embedded`).\n   */\n  type: TViewType;\n\n  /**\n   * This is a blueprint used to generate LView instances for this TView. Copying this\n   * blueprint is faster than creating a new LView from scratch.\n   */\n  blueprint: LView;\n\n  /**\n   * The template function used to refresh the view of dynamically created views\n   * and components. Will be null for inline views.\n   */\n  template: ComponentTemplate<{}> | null;\n\n  /**\n   * A function containing query-related instructions.\n   */\n  viewQuery: ViewQueriesFunction<{}> | null;\n\n  /**\n   * A `TNode` representing the declaration location of this `TView` (not part of this TView).\n   */\n  declTNode: TNode | null;\n\n  // FIXME(misko): Why does `TView` not have `declarationTView` property?\n\n  /** Whether or not this template has been processed in creation mode. */\n  firstCreatePass: boolean;\n\n  /**\n   *  Whether or not this template has been processed in update mode (e.g. change detected)\n   *\n   * `firstUpdatePass` is used by styling to set up `TData` to contain metadata about the styling\n   * instructions. (Mainly to build up a linked list of styling priority order.)\n   *\n   * Typically this function gets cleared after first execution. If exception is thrown then this\n   * flag can remain turned un until there is first successful (no exception) pass. This means that\n   * individual styling instructions keep track of if they have already been added to the linked\n   * list to prevent double adding.\n   */\n  firstUpdatePass: boolean;\n\n  /** Static data equivalent of LView.data[]. Contains TNodes, PipeDefInternal or TI18n. */\n  data: TData;\n\n  /**\n   * The binding start index is the index at which the data array\n   * starts to store bindings only. Saving this value ensures that we\n   * will begin reading bindings at the correct point in the array when\n   * we are in update mode.\n   *\n   * -1 means that it has not been initialized.\n   */\n  bindingStartIndex: number;\n\n  /**\n   * The index where the \"expando\" section of `LView` begins. The expando\n   * section contains injectors, directive instances, and host binding values.\n   * Unlike the \"decls\" and \"vars\" sections of `LView`, the length of this\n   * section cannot be calculated at compile-time because directives are matched\n   * at runtime to preserve locality.\n   *\n   * We store this start index so we know where to start checking host bindings\n   * in `setHostBindings`.\n   */\n  expandoStartIndex: number;\n\n  /**\n   * Whether or not there are any static view queries tracked on this view.\n   *\n   * We store this so we know whether or not we should do a view query\n   * refresh after creation mode to collect static query results.\n   */\n  staticViewQueries: boolean;\n\n  /**\n   * Whether or not there are any static content queries tracked on this view.\n   *\n   * We store this so we know whether or not we should do a content query\n   * refresh after creation mode to collect static query results.\n   */\n  staticContentQueries: boolean;\n\n  /**\n   * A reference to the first child node located in the view.\n   */\n  firstChild: TNode | null;\n\n  /**\n   * Stores the OpCodes to be replayed during change-detection to process the `HostBindings`\n   *\n   * See `HostBindingOpCodes` for encoding details.\n   */\n  hostBindingOpCodes: HostBindingOpCodes | null;\n\n  /**\n   * Full registry of directives and components that may be found in this view.\n   *\n   * It's necessary to keep a copy of the full def list on the TView so it's possible\n   * to render template functions without a host component.\n   */\n  directiveRegistry: DirectiveDefList | null;\n\n  /**\n   * Full registry of pipes that may be found in this view.\n   *\n   * The property is either an array of `PipeDefs`s or a function which returns the array of\n   * `PipeDefs`s. The function is necessary to be able to support forward declarations.\n   *\n   * It's necessary to keep a copy of the full def list on the TView so it's possible\n   * to render template functions without a host component.\n   */\n  pipeRegistry: PipeDefList | null;\n\n  /**\n   * Array of ngOnInit, ngOnChanges and ngDoCheck hooks that should be executed for this view in\n   * creation mode.\n   *\n   * This array has a flat structure and contains TNode indices, directive indices (where an\n   * instance can be found in `LView`) and hook functions. TNode index is followed by the directive\n   * index and a hook function. If there are multiple hooks for a given TNode, the TNode index is\n   * not repeated and the next lifecycle hook information is stored right after the previous hook\n   * function. This is done so that at runtime the system can efficiently iterate over all of the\n   * functions to invoke without having to make any decisions/lookups.\n   */\n  preOrderHooks: HookData | null;\n\n  /**\n   * Array of ngOnChanges and ngDoCheck hooks that should be executed for this view in update mode.\n   *\n   * This array has the same structure as the `preOrderHooks` one.\n   */\n  preOrderCheckHooks: HookData | null;\n\n  /**\n   * Array of ngAfterContentInit and ngAfterContentChecked hooks that should be executed\n   * for this view in creation mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  contentHooks: HookData | null;\n\n  /**\n   * Array of ngAfterContentChecked hooks that should be executed for this view in update\n   * mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  contentCheckHooks: HookData | null;\n\n  /**\n   * Array of ngAfterViewInit and ngAfterViewChecked hooks that should be executed for\n   * this view in creation mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  viewHooks: HookData | null;\n\n  /**\n   * Array of ngAfterViewChecked hooks that should be executed for this view in\n   * update mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  viewCheckHooks: HookData | null;\n\n  /**\n   * Array of ngOnDestroy hooks that should be executed when this view is destroyed.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  destroyHooks: DestroyHookData | null;\n\n  /**\n   * When a view is destroyed, listeners need to be released and outputs need to be\n   * unsubscribed. This cleanup array stores both listener data (in chunks of 4)\n   * and output data (in chunks of 2) for a particular view. Combining the arrays\n   * saves on memory (70 bytes per array) and on a few bytes of code size (for two\n   * separate for loops).\n   *\n   * If it's a native DOM listener or output subscription being stored:\n   * 1st index is: event name  `name = tView.cleanup[i+0]`\n   * 2nd index is: index of native element or a function that retrieves global target (window,\n   *               document or body) reference based on the native element:\n   *    `typeof idxOrTargetGetter === 'function'`: global target getter function\n   *    `typeof idxOrTargetGetter === 'number'`: index of native element\n   *\n   * 3rd index is: index of listener function `listener = lView[CLEANUP][tView.cleanup[i+2]]`\n   * 4th index is: `useCaptureOrIndx = tView.cleanup[i+3]`\n   *    `typeof useCaptureOrIndx == 'boolean' : useCapture boolean\n   *    `typeof useCaptureOrIndx == 'number':\n   *         `useCaptureOrIndx >= 0` `removeListener = LView[CLEANUP][useCaptureOrIndx]`\n   *         `useCaptureOrIndx <  0` `subscription = LView[CLEANUP][-useCaptureOrIndx]`\n   *\n   * If it's an output subscription or query list destroy hook:\n   * 1st index is: output unsubscribe function / query list destroy function\n   * 2nd index is: index of function context in LView.cleanupInstances[]\n   *               `tView.cleanup[i+0].call(lView[CLEANUP][tView.cleanup[i+1]])`\n   */\n  cleanup: any[] | null;\n\n  /**\n   * A list of element indices for child components that will need to be\n   * refreshed when the current view has finished its check. These indices have\n   * already been adjusted for the HEADER_OFFSET.\n   *\n   */\n  components: number[] | null;\n\n  /**\n   * A collection of queries tracked in a given view.\n   */\n  queries: TQueries | null;\n\n  /**\n   * An array of indices pointing to directives with content queries alongside with the\n   * corresponding query index. Each entry in this array is a tuple of:\n   * - index of the first content query index declared by a given directive;\n   * - index of a directive.\n   *\n   * We are storing those indexes so we can refresh content queries as part of a view refresh\n   * process.\n   */\n  contentQueries: number[] | null;\n\n  /**\n   * Set of schemas that declare elements to be allowed inside the view.\n   */\n  schemas: SchemaMetadata[] | null;\n\n  /**\n   * Array of constants for the view. Includes attribute arrays, local definition arrays etc.\n   * Used for directive matching, attribute bindings, local definitions and more.\n   */\n  consts: TConstants | null;\n\n  /**\n   * Indicates that there was an error before we managed to complete the first create pass of the\n   * view. This means that the view is likely corrupted and we should try to recover it.\n   */\n  incompleteFirstPass: boolean;\n\n  /**\n   * Unique id of this TView for hydration purposes:\n   * - TViewType.Embedded: a unique id generated during serialization on the server\n   * - TViewType.Component: an id generated based on component properties\n   *                        (see `getComponentId` function for details)\n   */\n  ssrId: string | null;\n}\n\n/** Single hook callback function. */\nexport type HookFn = () => void;\n\n/**\n * Information necessary to call a hook. E.g. the callback that\n * needs to invoked and the index at which to find its context.\n */\nexport type HookEntry = number | HookFn;\n\n/**\n * Array of hooks that should be executed for a view and their directive indices.\n *\n * For each node of the view, the following data is stored:\n * 1) Node index (optional)\n * 2) A series of number/function pairs where:\n *  - even indices are directive indices\n *  - odd indices are hook functions\n *\n * Special cases:\n *  - a negative directive index flags an init hook (ngOnInit, ngAfterContentInit, ngAfterViewInit)\n */\nexport type HookData = HookEntry[];\n\n/**\n * Array of destroy hooks that should be executed for a view and their directive indices.\n *\n * The array is set up as a series of number/function or number/(number|function)[]:\n * - Even indices represent the context with which hooks should be called.\n * - Odd indices are the hook functions themselves. If a value at an odd index is an array,\n *   it represents the destroy hooks of a `multi` provider where:\n *     - Even indices represent the index of the provider for which we've registered a destroy hook,\n *       inside of the `multi` provider array.\n *     - Odd indices are the destroy hook functions.\n * For example:\n * LView: `[0, 1, 2, AService, 4, [BService, CService, DService]]`\n * destroyHooks: `[3, AService.ngOnDestroy, 5, [0, BService.ngOnDestroy, 2, DService.ngOnDestroy]]`\n *\n * In the example above `AService` is a type provider with an `ngOnDestroy`, whereas `BService`,\n * `CService` and `DService` are part of a `multi` provider where only `BService` and `DService`\n * have an `ngOnDestroy` hook.\n */\nexport type DestroyHookData = (HookEntry | HookData)[];\n\n/**\n * Static data that corresponds to the instance-specific data array on an LView.\n *\n * Each node's static data is stored in tData at the same index that it's stored\n * in the data array.  Any nodes that do not have static data store a null value in\n * tData to avoid a sparse array.\n *\n * Each pipe's definition is stored here at the same index as its pipe instance in\n * the data array.\n *\n * Each host property's name is stored here at the same index as its value in the\n * data array.\n *\n * Each property binding name is stored here at the same index as its value in\n * the data array. If the binding is an interpolation, the static string values\n * are stored parallel to the dynamic values. Example:\n *\n * id=\"prefix {{ v0 }} a {{ v1 }} b {{ v2 }} suffix\"\n *\n * LView       |   TView.data\n *------------------------\n *  v0 value   |   'a'\n *  v1 value   |   'b'\n *  v2 value   |   id � prefix � suffix\n *\n * Injector bloom filters are also stored here.\n */\nexport type TData = (\n  | TNode\n  | PipeDef<any>\n  | DirectiveDef<any>\n  | ComponentDef<any>\n  | number\n  | TStylingRange\n  | TStylingKey\n  | ProviderToken<any>\n  | TI18n\n  | I18nUpdateOpCodes\n  | TIcu\n  | null\n  | string\n  | TDeferBlockDetails\n)[];\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DehydratedContainerView} from '../../hydration/interfaces';\n\nimport {TNode} from './node';\nimport {RComment, RElement} from './renderer_dom';\nimport {FLAGS, HOST, LView, NEXT, PARENT, T_HOST} from './view';\n\n/**\n * Special location which allows easy identification of type. If we have an array which was\n * retrieved from the `LView` and that array has `true` at `TYPE` location, we know it is\n * `LContainer`.\n */\nexport const TYPE = 1;\n\n/**\n * Below are constants for LContainer indices to help us look up LContainer members\n * without having to remember the specific indices.\n * Uglify will inline these when minifying so there shouldn't be a cost.\n */\n\n// FLAGS, PARENT, NEXT, and T_HOST are indices 2, 3, 4, and 5\n// As we already have these constants in LView, we don't need to re-create them.\n\nexport const DEHYDRATED_VIEWS = 6;\nexport const NATIVE = 7;\nexport const VIEW_REFS = 8;\nexport const MOVED_VIEWS = 9;\n\n/**\n * Size of LContainer's header. Represents the index after which all views in the\n * container will be inserted. We need to keep a record of current views so we know\n * which views are already in the DOM (and don't need to be re-added) and so we can\n * remove views from the DOM when they are no longer required.\n */\nexport const CONTAINER_HEADER_OFFSET = 10;\n\n/**\n * The state associated with a container.\n *\n * This is an array so that its structure is closer to LView. This helps\n * when traversing the view tree (which is a mix of containers and component\n * views), so we can jump to viewOrContainer[NEXT] in the same way regardless\n * of type.\n */\nexport interface LContainer extends Array<any> {\n  /**\n   * The host element of this LContainer.\n   *\n   * The host could be an LView if this container is on a component node.\n   * In that case, the component LView is its HOST.\n   */\n  readonly [HOST]: RElement | RComment | LView;\n\n  /**\n   * This is a type field which allows us to differentiate `LContainer` from `StylingContext` in an\n   * efficient way. The value is always set to `true`\n   */\n  [TYPE]: true;\n\n  /** Flags for this container. See LContainerFlags for more info. */\n  [FLAGS]: LContainerFlags;\n\n  /**\n   * Access to the parent view is necessary so we can propagate back\n   * up from inside a container to parent[NEXT].\n   */\n  [PARENT]: LView;\n\n  /**\n   * This allows us to jump from a container to a sibling container or component\n   * view with the same parent, so we can remove listeners efficiently.\n   */\n  [NEXT]: LView | LContainer | null;\n\n  /**\n   * A collection of views created based on the underlying `<ng-template>` element but inserted into\n   * a different `LContainer`. We need to track views created from a given declaration point since\n   * queries collect matches from the embedded view declaration point and _not_ the insertion point.\n   */\n  [MOVED_VIEWS]: LView[] | null;\n\n  /**\n   * Pointer to the `TNode` which represents the host of the container.\n   */\n  [T_HOST]: TNode;\n\n  /** The comment element that serves as an anchor for this LContainer. */\n  [NATIVE]: RComment;\n\n  /**\n   * Array of `ViewRef`s used by any `ViewContainerRef`s that point to this container.\n   *\n   * This is lazily initialized by `ViewContainerRef` when the first view is inserted.\n   *\n   * NOTE: This is stored as `any[]` because render3 should really not be aware of `ViewRef` and\n   * doing so creates circular dependency.\n   */\n  [VIEW_REFS]: unknown[] | null;\n\n  /**\n   * Array of dehydrated views within this container.\n   *\n   * This information is used during the hydration process on the client.\n   * The hydration logic tries to find a matching dehydrated view, \"claim\" it\n   * and use this information to do further matching. After that, this \"claimed\"\n   * view is removed from the list. The remaining \"unclaimed\" views are\n   * \"garbage-collected\" later on, i.e. removed from the DOM once the hydration\n   * logic finishes.\n   */\n  [DEHYDRATED_VIEWS]: DehydratedContainerView[] | null;\n}\n\n/** Flags associated with an LContainer (saved in LContainer[FLAGS]) */\nexport const enum LContainerFlags {\n  None = 0,\n  /**\n   * Flag to signify that this `LContainer` may have transplanted views which need to be change\n   * detected. (see: `LView[DECLARATION_COMPONENT_VIEW])`.\n   *\n   * This flag, once set, is never unset for the `LContainer`.\n   */\n  HasTransplantedViews = 1 << 1,\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {LContainer, TYPE} from './container';\nimport {ComponentDef, DirectiveDef} from './definition';\nimport {TNode, TNodeFlags, TNodeType} from './node';\nimport {RNode} from './renderer_dom';\nimport {FLAGS, LView, LViewFlags} from './view';\n\n/**\n * True if `value` is `LView`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nexport function isLView(value: RNode | LView | LContainer | {} | null): value is LView {\n  return Array.isArray(value) && typeof value[TYPE] === 'object';\n}\n\n/**\n * True if `value` is `LContainer`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nexport function isLContainer(value: RNode | LView | LContainer | {} | null): value is LContainer {\n  return Array.isArray(value) && value[TYPE] === true;\n}\n\nexport function isContentQueryHost(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.hasContentQuery) !== 0;\n}\n\nexport function isComponentHost(tNode: TNode): boolean {\n  return tNode.componentOffset > -1;\n}\n\nexport function isDirectiveHost(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.isDirectiveHost) === TNodeFlags.isDirectiveHost;\n}\n\nexport function isComponentDef<T>(def: DirectiveDef<T>): def is ComponentDef<T> {\n  return !!(def as ComponentDef<T>).template;\n}\n\nexport function isRootView(target: LView): boolean {\n  // Determines whether a given LView is marked as a root view.\n  return (target[FLAGS] & LViewFlags.IsRoot) !== 0;\n}\n\nexport function isProjectionTNode(tNode: TNode): boolean {\n  return (tNode.type & TNodeType.Projection) === TNodeType.Projection;\n}\n\nexport function hasI18n(lView: LView): boolean {\n  return (lView[FLAGS] & LViewFlags.HasI18n) === LViewFlags.HasI18n;\n}\n\nexport function isDestroyed(lView: LView): boolean {\n  // Determines whether a given LView is marked as destroyed.\n  return (lView[FLAGS] & LViewFlags.Destroyed) === LViewFlags.Destroyed;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {\n  assertDefined,\n  assertEqual,\n  assertIndexInRange,\n  assertLessThan,\n  assertNumber,\n  throwError,\n} from '../util/assert';\n\nimport {getComponentDef, getNgModuleDef} from './def_getters';\nimport {LContainer} from './interfaces/container';\nimport {DirectiveDef} from './interfaces/definition';\nimport {TIcu} from './interfaces/i18n';\nimport {NodeInjectorOffset} from './interfaces/injector';\nimport {TNode} from './interfaces/node';\nimport {isLContainer, isLView} from './interfaces/type_checks';\nimport {\n  DECLARATION_COMPONENT_VIEW,\n  FLAGS,\n  HEADER_OFFSET,\n  LView,\n  LViewFlags,\n  T_HOST,\n  TVIEW,\n  TView,\n} from './interfaces/view';\n\n// [Assert functions do not constraint type when they are guarded by a truthy\n// expression.](https://github.com/microsoft/TypeScript/issues/37295)\n\nexport function assertTNodeForLView(tNode: TNode, lView: LView) {\n  assertTNodeForTView(tNode, lView[TVIEW]);\n}\n\nexport function assertTNodeCreationIndex(lView: LView, index: number) {\n  const adjustedIndex = index + HEADER_OFFSET;\n  assertIndexInRange(lView, adjustedIndex);\n  assertLessThan(\n    adjustedIndex,\n    lView[TVIEW].bindingStartIndex,\n    'TNodes should be created before any bindings',\n  );\n}\n\nexport function assertTNodeForTView(tNode: TNode, tView: TView) {\n  assertTNode(tNode);\n  const tData = tView.data;\n  for (let i = HEADER_OFFSET; i < tData.length; i++) {\n    if (tData[i] === tNode) {\n      return;\n    }\n  }\n  throwError('This TNode does not belong to this TView.');\n}\n\nexport function assertTNode(tNode: TNode) {\n  assertDefined(tNode, 'TNode must be defined');\n  if (!(tNode && typeof tNode === 'object' && tNode.hasOwnProperty('directiveStylingLast'))) {\n    throwError('Not of type TNode, got: ' + tNode);\n  }\n}\n\nexport function assertTIcu(tIcu: TIcu) {\n  assertDefined(tIcu, 'Expected TIcu to be defined');\n  if (!(typeof tIcu.currentCaseLViewIndex === 'number')) {\n    throwError('Object is not of TIcu type.');\n  }\n}\n\nexport function assertComponentType(\n  actual: any,\n  msg: string = \"Type passed in is not ComponentType, it does not have 'ɵcmp' property.\",\n) {\n  if (!getComponentDef(actual)) {\n    throwError(msg);\n  }\n}\n\nexport function assertNgModuleType(\n  actual: any,\n  msg: string = \"Type passed in is not NgModuleType, it does not have 'ɵmod' property.\",\n) {\n  if (!getNgModuleDef(actual)) {\n    throwError(msg);\n  }\n}\n\nexport function assertCurrentTNodeIsParent(isParent: boolean) {\n  assertEqual(isParent, true, 'currentTNode should be a parent');\n}\n\nexport function assertHasParent(tNode: TNode | null) {\n  assertDefined(tNode, 'currentTNode should exist!');\n  assertDefined(tNode!.parent, 'currentTNode should have a parent');\n}\n\nexport function assertLContainer(value: any): asserts value is LContainer {\n  assertDefined(value, 'LContainer must be defined');\n  assertEqual(isLContainer(value), true, 'Expecting LContainer');\n}\n\nexport function assertLViewOrUndefined(value: any): asserts value is LView | null | undefined {\n  value && assertEqual(isLView(value), true, 'Expecting LView or undefined or null');\n}\n\nexport function assertLView(value: any): asserts value is LView {\n  assertDefined(value, 'LView must be defined');\n  assertEqual(isLView(value), true, 'Expecting LView');\n}\n\nexport function assertFirstCreatePass(tView: TView, errMessage?: string) {\n  assertEqual(\n    tView.firstCreatePass,\n    true,\n    errMessage || 'Should only be called in first create pass.',\n  );\n}\n\nexport function assertFirstUpdatePass(tView: TView, errMessage?: string) {\n  assertEqual(\n    tView.firstUpdatePass,\n    true,\n    errMessage || 'Should only be called in first update pass.',\n  );\n}\n\n/**\n * This is a basic sanity check that an object is probably a directive def. DirectiveDef is\n * an interface, so we can't do a direct instanceof check.\n */\nexport function assertDirectiveDef<T>(obj: any): asserts obj is DirectiveDef<T> {\n  if (obj.type === undefined || obj.selectors == undefined || obj.inputs === undefined) {\n    throwError(\n      `Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`,\n    );\n  }\n}\n\nexport function assertIndexInDeclRange(tView: TView, index: number) {\n  assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);\n}\n\nexport function assertIndexInExpandoRange(lView: LView, index: number) {\n  const tView = lView[1];\n  assertBetween(tView.expandoStartIndex, lView.length, index);\n}\n\nexport function assertBetween(lower: number, upper: number, index: number) {\n  if (!(lower <= index && index < upper)) {\n    throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);\n  }\n}\n\nexport function assertProjectionSlots(lView: LView, errMessage?: string) {\n  assertDefined(lView[DECLARATION_COMPONENT_VIEW], 'Component views should exist.');\n  assertDefined(\n    lView[DECLARATION_COMPONENT_VIEW][T_HOST]!.projection,\n    errMessage ||\n      'Components with projection nodes (<ng-content>) must have projection slots defined.',\n  );\n}\n\nexport function assertParentView(lView: LView | null, errMessage?: string) {\n  assertDefined(\n    lView,\n    errMessage || \"Component views should always have a parent view (component's host view)\",\n  );\n}\n\nexport function assertNoDuplicateDirectives(directives: DirectiveDef<unknown>[]): void {\n  // The array needs at least two elements in order to have duplicates.\n  if (directives.length < 2) {\n    return;\n  }\n\n  const seenDirectives = new Set<DirectiveDef<unknown>>();\n\n  for (const current of directives) {\n    if (seenDirectives.has(current)) {\n      throw new RuntimeError(\n        RuntimeErrorCode.DUPLICATE_DIRECTIVE,\n        `Directive ${current.type.name} matches multiple times on the same element. ` +\n          `Directives can only match an element once.`,\n      );\n    }\n    seenDirectives.add(current);\n  }\n}\n\n/**\n * This is a basic sanity check that the `injectorIndex` seems to point to what looks like a\n * NodeInjector data structure.\n *\n * @param lView `LView` which should be checked.\n * @param injectorIndex index into the `LView` where the `NodeInjector` is expected.\n */\nexport function assertNodeInjector(lView: LView, injectorIndex: number) {\n  assertIndexInExpandoRange(lView, injectorIndex);\n  assertIndexInExpandoRange(lView, injectorIndex + NodeInjectorOffset.PARENT);\n  assertNumber(lView[injectorIndex + 0], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 1], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 2], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 3], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 4], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 5], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 6], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 7], 'injectorIndex should point to a bloom filter');\n  assertNumber(\n    lView[injectorIndex + NodeInjectorOffset.PARENT],\n    'injectorIndex should point to parent injector',\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nexport const SVG_NAMESPACE = 'svg';\nexport const MATH_ML_NAMESPACE = 'math';\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {NotificationSource} from '../../change_detection/scheduling/zoneless_scheduling';\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {\n  assertDefined,\n  assertGreaterThan,\n  assertGreaterThanOrEqual,\n  assertIndexInRange,\n  assertLessThan,\n} from '../../util/assert';\nimport {assertLView, assertTNode, assertTNodeForLView} from '../assert';\nimport {LContainer, TYPE} from '../interfaces/container';\nimport {TConstants, TNode} from '../interfaces/node';\nimport {RNode} from '../interfaces/renderer_dom';\nimport {isDestroyed, isLContainer, isLView} from '../interfaces/type_checks';\nimport {\n  CLEANUP,\n  DECLARATION_VIEW,\n  ENVIRONMENT,\n  FLAGS,\n  HEADER_OFFSET,\n  HOST,\n  LView,\n  LViewFlags,\n  ON_DESTROY_HOOKS,\n  PARENT,\n  PREORDER_HOOK_FLAGS,\n  PreOrderHookFlags,\n  REACTIVE_TEMPLATE_CONSUMER,\n  TData,\n  TView,\n} from '../interfaces/view';\n\n/**\n * For efficiency reasons we often put several different data types (`RNode`, `LView`, `LContainer`)\n * in same location in `LView`. This is because we don't want to pre-allocate space for it\n * because the storage is sparse. This file contains utilities for dealing with such data types.\n *\n * How do we know what is stored at a given location in `LView`.\n * - `Array.isArray(value) === false` => `RNode` (The normal storage value)\n * - `Array.isArray(value) === true` => then the `value[0]` represents the wrapped value.\n *   - `typeof value[TYPE] === 'object'` => `LView`\n *      - This happens when we have a component at a given location\n *   - `typeof value[TYPE] === true` => `LContainer`\n *      - This happens when we have `LContainer` binding at a given location.\n *\n *\n * NOTE: it is assumed that `Array.isArray` and `typeof` operations are very efficient.\n */\n\n/**\n * Returns `RNode`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nexport function unwrapRNode(value: RNode | LView | LContainer): RNode {\n  while (Array.isArray(value)) {\n    value = value[HOST] as any;\n  }\n  return value as RNode;\n}\n\n/**\n * Returns `LView` or `null` if not found.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nexport function unwrapLView(value: RNode | LView | LContainer): LView | null {\n  while (Array.isArray(value)) {\n    // This check is same as `isLView()` but we don't call at as we don't want to call\n    // `Array.isArray()` twice and give JITer more work for inlining.\n    if (typeof value[TYPE] === 'object') return value as LView;\n    value = value[HOST] as any;\n  }\n  return null;\n}\n\n/**\n * Retrieves an element value from the provided `viewData`, by unwrapping\n * from any containers, component views, or style contexts.\n */\nexport function getNativeByIndex(index: number, lView: LView): RNode {\n  ngDevMode && assertIndexInRange(lView, index);\n  ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Expected to be past HEADER_OFFSET');\n  return unwrapRNode(lView[index]);\n}\n\n/**\n * Retrieve an `RNode` for a given `TNode` and `LView`.\n *\n * This function guarantees in dev mode to retrieve a non-null `RNode`.\n *\n * @param tNode\n * @param lView\n */\nexport function getNativeByTNode(tNode: TNode, lView: LView): RNode {\n  ngDevMode && assertTNodeForLView(tNode, lView);\n  ngDevMode && assertIndexInRange(lView, tNode.index);\n  const node: RNode = unwrapRNode(lView[tNode.index]);\n  return node;\n}\n\n/**\n * Retrieve an `RNode` or `null` for a given `TNode` and `LView`.\n *\n * Some `TNode`s don't have associated `RNode`s. For example `Projection`\n *\n * @param tNode\n * @param lView\n */\nexport function getNativeByTNodeOrNull(tNode: TNode | null, lView: LView): RNode | null {\n  const index = tNode === null ? -1 : tNode.index;\n  if (index !== -1) {\n    ngDevMode && assertTNodeForLView(tNode!, lView);\n    const node: RNode | null = unwrapRNode(lView[index]);\n    return node;\n  }\n  return null;\n}\n\n// fixme(misko): The return Type should be `TNode|null`\nexport function getTNode(tView: TView, index: number): TNode {\n  ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');\n  ngDevMode && assertLessThan(index, tView.data.length, 'wrong index for TNode');\n  const tNode = tView.data[index] as TNode;\n  ngDevMode && tNode !== null && assertTNode(tNode);\n  return tNode;\n}\n\n/** Retrieves a value from any `LView` or `TData`. */\nexport function load<T>(view: LView | TData, index: number): T {\n  ngDevMode && assertIndexInRange(view, index);\n  return view[index];\n}\n\n/** Store a value in the `data` at a given `index`. */\nexport function store<T>(tView: TView, lView: LView, index: number, value: T): void {\n  // We don't store any static data for local variables, so the first time\n  // we see the template, we should store as null to avoid a sparse array\n  if (index >= tView.data.length) {\n    tView.data[index] = null;\n    tView.blueprint[index] = null;\n  }\n  lView[index] = value;\n}\n\nexport function getComponentLViewByIndex(nodeIndex: number, hostView: LView): LView {\n  // Could be an LView or an LContainer. If LContainer, unwrap to find LView.\n  ngDevMode && assertIndexInRange(hostView, nodeIndex);\n  const slotValue = hostView[nodeIndex];\n  const lView = isLView(slotValue) ? slotValue : slotValue[HOST];\n  return lView;\n}\n\n/** Checks whether a given view is in creation mode */\nexport function isCreationMode(view: LView): boolean {\n  return (view[FLAGS] & LViewFlags.CreationMode) === LViewFlags.CreationMode;\n}\n\n/**\n * Returns a boolean for whether the view is attached to the change detection tree.\n *\n * Note: This determines whether a view should be checked, not whether it's inserted\n * into a container. For that, you'll want `viewAttachedToContainer` below.\n */\nexport function viewAttachedToChangeDetector(view: LView): boolean {\n  return (view[FLAGS] & LViewFlags.Attached) === LViewFlags.Attached;\n}\n\n/** Returns a boolean for whether the view is attached to a container. */\nexport function viewAttachedToContainer(view: LView): boolean {\n  return isLContainer(view[PARENT]);\n}\n\n/** Returns a constant from `TConstants` instance. */\nexport function getConstant<T>(consts: TConstants | null, index: null | undefined): null;\nexport function getConstant<T>(consts: TConstants, index: number): T | null;\nexport function getConstant<T>(\n  consts: TConstants | null,\n  index: number | null | undefined,\n): T | null;\nexport function getConstant<T>(\n  consts: TConstants | null,\n  index: number | null | undefined,\n): T | null {\n  if (index === null || index === undefined) return null;\n  ngDevMode && assertIndexInRange(consts!, index);\n  return consts![index] as unknown as T;\n}\n\n/**\n * Resets the pre-order hook flags of the view.\n * @param lView the LView on which the flags are reset\n */\nexport function resetPreOrderHookFlags(lView: LView) {\n  lView[PREORDER_HOOK_FLAGS] = 0 as PreOrderHookFlags;\n}\n\n/**\n * Adds the `RefreshView` flag from the lView and updates HAS_CHILD_VIEWS_TO_REFRESH flag of\n * parents.\n */\nexport function markViewForRefresh(lView: LView) {\n  if (lView[FLAGS] & LViewFlags.RefreshView) {\n    return;\n  }\n  lView[FLAGS] |= LViewFlags.RefreshView;\n  if (viewAttachedToChangeDetector(lView)) {\n    markAncestorsForTraversal(lView);\n  }\n}\n\n/**\n * Walks up the LView hierarchy.\n * @param nestingLevel Number of times to walk up in hierarchy.\n * @param currentView View from which to start the lookup.\n */\nexport function walkUpViews(nestingLevel: number, currentView: LView): LView {\n  while (nestingLevel > 0) {\n    ngDevMode &&\n      assertDefined(\n        currentView[DECLARATION_VIEW],\n        'Declaration view should be defined if nesting level is greater than 0.',\n      );\n    currentView = currentView[DECLARATION_VIEW]!;\n    nestingLevel--;\n  }\n  return currentView;\n}\n\nexport function requiresRefreshOrTraversal(lView: LView) {\n  return !!(\n    lView[FLAGS] & (LViewFlags.RefreshView | LViewFlags.HasChildViewsToRefresh) ||\n    lView[REACTIVE_TEMPLATE_CONSUMER]?.dirty\n  );\n}\n\n/**\n * Updates the `HasChildViewsToRefresh` flag on the parents of the `LView` as well as the\n * parents above.\n */\nexport function updateAncestorTraversalFlagsOnAttach(lView: LView) {\n  lView[ENVIRONMENT].changeDetectionScheduler?.notify(NotificationSource.ViewAttached);\n  if (lView[FLAGS] & LViewFlags.Dirty) {\n    lView[FLAGS] |= LViewFlags.RefreshView;\n  }\n  if (requiresRefreshOrTraversal(lView)) {\n    markAncestorsForTraversal(lView);\n  }\n}\n\n/**\n * Ensures views above the given `lView` are traversed during change detection even when they are\n * not dirty.\n *\n * This is done by setting the `HAS_CHILD_VIEWS_TO_REFRESH` flag up to the root, stopping when the\n * flag is already `true` or the `lView` is detached.\n */\nexport function markAncestorsForTraversal(lView: LView) {\n  lView[ENVIRONMENT].changeDetectionScheduler?.notify(NotificationSource.MarkAncestorsForTraversal);\n  let parent = getLViewParent(lView);\n  while (parent !== null) {\n    // We stop adding markers to the ancestors once we reach one that already has the marker. This\n    // is to avoid needlessly traversing all the way to the root when the marker already exists.\n    if (parent[FLAGS] & LViewFlags.HasChildViewsToRefresh) {\n      break;\n    }\n\n    parent[FLAGS] |= LViewFlags.HasChildViewsToRefresh;\n    if (!viewAttachedToChangeDetector(parent)) {\n      break;\n    }\n    parent = getLViewParent(parent);\n  }\n}\n\n/**\n * Stores a LView-specific destroy callback.\n */\nexport function storeLViewOnDestroy(lView: LView, onDestroyCallback: () => void) {\n  if (isDestroyed(lView)) {\n    throw new RuntimeError(\n      RuntimeErrorCode.VIEW_ALREADY_DESTROYED,\n      ngDevMode && 'View has already been destroyed.',\n    );\n  }\n  if (lView[ON_DESTROY_HOOKS] === null) {\n    lView[ON_DESTROY_HOOKS] = [];\n  }\n  lView[ON_DESTROY_HOOKS].push(onDestroyCallback);\n}\n\n/**\n * Removes previously registered LView-specific destroy callback.\n */\nexport function removeLViewOnDestroy(lView: LView, onDestroyCallback: () => void) {\n  if (lView[ON_DESTROY_HOOKS] === null) return;\n\n  const destroyCBIdx = lView[ON_DESTROY_HOOKS].indexOf(onDestroyCallback);\n  if (destroyCBIdx !== -1) {\n    lView[ON_DESTROY_HOOKS].splice(destroyCBIdx, 1);\n  }\n}\n\n/**\n * Gets the parent LView of the passed LView, if the PARENT is an LContainer, will get the parent of\n * that LContainer, which is an LView\n * @param lView the lView whose parent to get\n */\nexport function getLViewParent(lView: LView): LView | null {\n  ngDevMode && assertLView(lView);\n  const parent = lView[PARENT];\n  return isLContainer(parent) ? parent[PARENT] : parent;\n}\n\nexport function getOrCreateLViewCleanup(view: LView): any[] {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return (view[CLEANUP] ??= []);\n}\n\nexport function getOrCreateTViewCleanup(tView: TView): any[] {\n  return (tView.cleanup ??= []);\n}\n\n/**\n * Saves context for this cleanup function in LView.cleanupInstances.\n *\n * On the first template pass, saves in TView:\n * - Cleanup function\n * - Index of context we just saved in LView.cleanupInstances\n */\nexport function storeCleanupWithContext(\n  tView: TView,\n  lView: LView,\n  context: any,\n  cleanupFn: Function,\n): void {\n  const lCleanup = getOrCreateLViewCleanup(lView);\n\n  // Historically the `storeCleanupWithContext` was used to register both framework-level and\n  // user-defined cleanup callbacks, but over time those two types of cleanups were separated.\n  // This dev mode checks assures that user-level cleanup callbacks are _not_ stored in data\n  // structures reserved for framework-specific hooks.\n  ngDevMode &&\n    assertDefined(\n      context,\n      'Cleanup context is mandatory when registering framework-level destroy hooks',\n    );\n  lCleanup.push(context);\n\n  if (tView.firstCreatePass) {\n    getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);\n  } else {\n    // Make sure that no new framework-level cleanup functions are registered after the first\n    // template pass is done (and TView data structures are meant to fully constructed).\n    if (ngDevMode) {\n      Object.freeze(getOrCreateTViewCleanup(tView));\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InternalInjectFlags} from '../di/interface/injector';\nimport {\n  assertDefined,\n  assertEqual,\n  assertGreaterThanOrEqual,\n  assertLessThan,\n  assertNotEqual,\n  throwError,\n} from '../util/assert';\n\nimport {assertLViewOrUndefined, assertTNodeForLView, assertTNodeForTView} from './assert';\nimport {DirectiveDef} from './interfaces/definition';\nimport {TNode, TNodeType} from './interfaces/node';\nimport {\n  CONTEXT,\n  DECLARATION_VIEW,\n  HEADER_OFFSET,\n  LView,\n  OpaqueViewState,\n  T_HOST,\n  TData,\n  TVIEW,\n  TView,\n  TViewType,\n} from './interfaces/view';\nimport {MATH_ML_NAMESPACE, SVG_NAMESPACE} from './namespaces';\nimport {getTNode, walkUpViews} from './util/view_utils';\n\n/**\n *\n */\ninterface LFrame {\n  /**\n   * Parent LFrame.\n   *\n   * This is needed when `leaveView` is called to restore the previous state.\n   */\n  parent: LFrame;\n\n  /**\n   * Child LFrame.\n   *\n   * This is used to cache existing LFrames to relieve the memory pressure.\n   */\n  child: LFrame | null;\n\n  /**\n   * State of the current view being processed.\n   *\n   * An array of nodes (text, element, container, etc), pipes, their bindings, and\n   * any local variables that need to be stored between invocations.\n   */\n  lView: LView;\n\n  /**\n   * Current `TView` associated with the `LFrame.lView`.\n   *\n   * One can get `TView` from `lFrame[TVIEW]` however because it is so common it makes sense to\n   * store it in `LFrame` for perf reasons.\n   */\n  tView: TView;\n\n  /**\n   * Used to set the parent property when nodes are created and track query results.\n   *\n   * This is used in conjunction with `isParent`.\n   */\n  currentTNode: TNode | null;\n\n  /**\n   * If `isParent` is:\n   *  - `true`: then `currentTNode` points to a parent node.\n   *  - `false`: then `currentTNode` points to previous node (sibling).\n   */\n  isParent: boolean;\n\n  /**\n   * Index of currently selected element in LView.\n   *\n   * Used by binding instructions. Updated as part of advance instruction.\n   */\n  selectedIndex: number;\n\n  /**\n   * Current pointer to the binding index.\n   */\n  bindingIndex: number;\n\n  /**\n   * The last viewData retrieved by nextContext().\n   * Allows building nextContext() and reference() calls.\n   *\n   * e.g. const inner = x().$implicit; const outer = x().$implicit;\n   */\n  contextLView: LView | null;\n\n  /**\n   * Store the element depth count. This is used to identify the root elements of the template\n   * so that we can then attach patch data `LView` to only those elements. We know that those\n   * are the only places where the patch data could change, this way we will save on number\n   * of places where tha patching occurs.\n   */\n  elementDepthCount: number;\n\n  /**\n   * Current namespace to be used when creating elements\n   */\n  currentNamespace: string | null;\n\n  /**\n   * The root index from which pure function instructions should calculate their binding\n   * indices. In component views, this is TView.bindingStartIndex. In a host binding\n   * context, this is the TView.expandoStartIndex + any dirs/hostVars before the given dir.\n   */\n  bindingRootIndex: number;\n\n  /**\n   * Current index of a View or Content Query which needs to be processed next.\n   * We iterate over the list of Queries and increment current query index at every step.\n   */\n  currentQueryIndex: number;\n\n  /**\n   * When host binding is executing this points to the directive index.\n   * `TView.data[currentDirectiveIndex]` is `DirectiveDef`\n   * `LView[currentDirectiveIndex]` is directive instance.\n   */\n  currentDirectiveIndex: number;\n\n  /**\n   * Are we currently in i18n block as denoted by `ɵɵelementStart` and `ɵɵelementEnd`.\n   *\n   * This information is needed because while we are in i18n block all elements must be pre-declared\n   * in the translation. (i.e. `Hello �#2�World�/#2�!` pre-declares element at `�#2�` location.)\n   * This allocates `TNodeType.Placeholder` element at location `2`. If translator removes `�#2�`\n   * from translation than the runtime must also ensure tha element at `2` does not get inserted\n   * into the DOM. The translation does not carry information about deleted elements. Therefor the\n   * only way to know that an element is deleted is that it was not pre-declared in the translation.\n   *\n   * This flag works by ensuring that elements which are created without pre-declaration\n   * (`TNodeType.Placeholder`) are not inserted into the DOM render tree. (It does mean that the\n   * element still gets instantiated along with all of its behavior [directives])\n   */\n  inI18n: boolean;\n}\n\n/**\n * All implicit instruction state is stored here.\n *\n * It is useful to have a single object where all of the state is stored as a mental model\n * (rather it being spread across many different variables.)\n *\n * PERF NOTE: Turns out that writing to a true global variable is slower than\n * having an intermediate object with properties.\n */\ninterface InstructionState {\n  /**\n   * Current `LFrame`\n   *\n   * `null` if we have not called `enterView`\n   */\n  lFrame: LFrame;\n\n  /**\n   * Stores whether directives should be matched to elements.\n   *\n   * When template contains `ngNonBindable` then we need to prevent the runtime from matching\n   * directives on children of that element.\n   *\n   * Example:\n   * ```html\n   * <my-comp my-directive>\n   *   Should match component / directive.\n   * </my-comp>\n   * <div ngNonBindable>\n   *   <my-comp my-directive>\n   *     Should not match component / directive because we are in ngNonBindable.\n   *   </my-comp>\n   * </div>\n   * ```\n   */\n  bindingsEnabled: boolean;\n\n  /**\n   * Stores the root TNode that has the 'ngSkipHydration' attribute on it for later reference.\n   *\n   * Example:\n   * ```html\n   * <my-comp ngSkipHydration>\n   *   Should reference this root node\n   * </my-comp>\n   * ```\n   */\n  skipHydrationRootTNode: TNode | null;\n}\n\nconst instructionState: InstructionState = {\n  lFrame: createLFrame(null),\n  bindingsEnabled: true,\n  skipHydrationRootTNode: null,\n};\n\nexport enum CheckNoChangesMode {\n  Off,\n  Exhaustive,\n  OnlyDirtyViews,\n}\n\n/**\n * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.\n *\n * Necessary to support ChangeDetectorRef.checkNoChanges().\n *\n * The `checkNoChanges` function is invoked only in ngDevMode=true and verifies that no unintended\n * changes exist in the change detector or its children.\n */\nlet _checkNoChangesMode: CheckNoChangesMode = 0; /* CheckNoChangesMode.Off */\n\n/**\n * Flag used to indicate that we are in the middle running change detection on a view\n *\n * @see detectChangesInViewWhileDirty\n */\nlet _isRefreshingViews = false;\n\n/**\n * Returns true if the instruction state stack is empty.\n *\n * Intended to be called from tests only (tree shaken otherwise).\n */\nexport function specOnlyIsInstructionStateEmpty(): boolean {\n  return instructionState.lFrame.parent === null;\n}\n\nexport function getElementDepthCount() {\n  return instructionState.lFrame.elementDepthCount;\n}\n\nexport function increaseElementDepthCount() {\n  instructionState.lFrame.elementDepthCount++;\n}\n\nexport function decreaseElementDepthCount() {\n  instructionState.lFrame.elementDepthCount--;\n}\n\nexport function getBindingsEnabled(): boolean {\n  return instructionState.bindingsEnabled;\n}\n\n/**\n * Returns true if currently inside a skip hydration block.\n * @returns boolean\n */\nexport function isInSkipHydrationBlock(): boolean {\n  return instructionState.skipHydrationRootTNode !== null;\n}\n\n/**\n * Returns true if this is the root TNode of the skip hydration block.\n * @param tNode the current TNode\n * @returns boolean\n */\nexport function isSkipHydrationRootTNode(tNode: TNode): boolean {\n  return instructionState.skipHydrationRootTNode === tNode;\n}\n\n/**\n * Enables directive matching on elements.\n *\n *  * Example:\n * ```html\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- ɵɵdisableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- ɵɵenableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\nexport function ɵɵenableBindings(): void {\n  instructionState.bindingsEnabled = true;\n}\n\n/**\n * Sets a flag to specify that the TNode is in a skip hydration block.\n * @param tNode the current TNode\n */\nexport function enterSkipHydrationBlock(tNode: TNode): void {\n  instructionState.skipHydrationRootTNode = tNode;\n}\n\n/**\n * Disables directive matching on element.\n *\n *  * Example:\n * ```html\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- ɵɵdisableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- ɵɵenableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\nexport function ɵɵdisableBindings(): void {\n  instructionState.bindingsEnabled = false;\n}\n\n/**\n * Clears the root skip hydration node when leaving a skip hydration block.\n */\nexport function leaveSkipHydrationBlock(): void {\n  instructionState.skipHydrationRootTNode = null;\n}\n\n/**\n * Return the current `LView`.\n */\nexport function getLView<T>(): LView<T> {\n  return instructionState.lFrame.lView as LView<T>;\n}\n\n/**\n * Return the current `TView`.\n */\nexport function getTView(): TView {\n  return instructionState.lFrame.tView;\n}\n\n/**\n * Restores `contextViewData` to the given OpaqueViewState instance.\n *\n * Used in conjunction with the getCurrentView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @param viewToRestore The OpaqueViewState instance to restore.\n * @returns Context of the restored OpaqueViewState instance.\n *\n * @codeGenApi\n */\nexport function ɵɵrestoreView<T = any>(viewToRestore: OpaqueViewState): T {\n  instructionState.lFrame.contextLView = viewToRestore as any as LView;\n  return (viewToRestore as any as LView)[CONTEXT] as unknown as T;\n}\n\n/**\n * Clears the view set in `ɵɵrestoreView` from memory. Returns the passed in\n * value so that it can be used as a return value of an instruction.\n *\n * @codeGenApi\n */\nexport function ɵɵresetView<T>(value?: T): T | undefined {\n  instructionState.lFrame.contextLView = null;\n  return value;\n}\n\nexport function getCurrentTNode(): TNode | null {\n  let currentTNode = getCurrentTNodePlaceholderOk();\n  while (currentTNode !== null && currentTNode.type === TNodeType.Placeholder) {\n    currentTNode = currentTNode.parent;\n  }\n  return currentTNode;\n}\n\nexport function getCurrentTNodePlaceholderOk(): TNode | null {\n  return instructionState.lFrame.currentTNode;\n}\n\nexport function getCurrentParentTNode(): TNode | null {\n  const lFrame = instructionState.lFrame;\n  const currentTNode = lFrame.currentTNode;\n  return lFrame.isParent ? currentTNode : currentTNode!.parent;\n}\n\nexport function setCurrentTNode(tNode: TNode | null, isParent: boolean) {\n  ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);\n  const lFrame = instructionState.lFrame;\n  lFrame.currentTNode = tNode;\n  lFrame.isParent = isParent;\n}\n\nexport function isCurrentTNodeParent(): boolean {\n  return instructionState.lFrame.isParent;\n}\n\nexport function setCurrentTNodeAsNotParent(): void {\n  instructionState.lFrame.isParent = false;\n}\n\nexport function getContextLView(): LView {\n  const contextLView = instructionState.lFrame.contextLView;\n  ngDevMode && assertDefined(contextLView, 'contextLView must be defined.');\n  return contextLView!;\n}\n\nexport function isInCheckNoChangesMode(): boolean {\n  !ngDevMode && throwError('Must never be called in production mode');\n  return _checkNoChangesMode !== CheckNoChangesMode.Off;\n}\n\nexport function isExhaustiveCheckNoChanges(): boolean {\n  !ngDevMode && throwError('Must never be called in production mode');\n  return _checkNoChangesMode === CheckNoChangesMode.Exhaustive;\n}\n\nexport function setIsInCheckNoChangesMode(mode: CheckNoChangesMode): void {\n  !ngDevMode && throwError('Must never be called in production mode');\n  _checkNoChangesMode = mode;\n}\n\nexport function isRefreshingViews(): boolean {\n  return _isRefreshingViews;\n}\n\nexport function setIsRefreshingViews(mode: boolean): boolean {\n  const prev = _isRefreshingViews;\n  _isRefreshingViews = mode;\n  return prev;\n}\n\n// top level variables should not be exported for performance reasons (PERF_NOTES.md)\nexport function getBindingRoot() {\n  const lFrame = instructionState.lFrame;\n  let index = lFrame.bindingRootIndex;\n  if (index === -1) {\n    index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;\n  }\n  return index;\n}\n\nexport function getBindingIndex(): number {\n  return instructionState.lFrame.bindingIndex;\n}\n\nexport function setBindingIndex(value: number): number {\n  return (instructionState.lFrame.bindingIndex = value);\n}\n\nexport function nextBindingIndex(): number {\n  return instructionState.lFrame.bindingIndex++;\n}\n\nexport function incrementBindingIndex(count: number): number {\n  const lFrame = instructionState.lFrame;\n  const index = lFrame.bindingIndex;\n  lFrame.bindingIndex = lFrame.bindingIndex + count;\n  return index;\n}\n\nexport function isInI18nBlock() {\n  return instructionState.lFrame.inI18n;\n}\n\nexport function setInI18nBlock(isInI18nBlock: boolean): void {\n  instructionState.lFrame.inI18n = isInI18nBlock;\n}\n\n/**\n * Set a new binding root index so that host template functions can execute.\n *\n * Bindings inside the host template are 0 index. But because we don't know ahead of time\n * how many host bindings we have we can't pre-compute them. For this reason they are all\n * 0 index and we just shift the root so that they match next available location in the LView.\n *\n * @param bindingRootIndex Root index for `hostBindings`\n * @param currentDirectiveIndex `TData[currentDirectiveIndex]` will point to the current directive\n *        whose `hostBindings` are being processed.\n */\nexport function setBindingRootForHostBindings(\n  bindingRootIndex: number,\n  currentDirectiveIndex: number,\n) {\n  const lFrame = instructionState.lFrame;\n  lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;\n  setCurrentDirectiveIndex(currentDirectiveIndex);\n}\n\n/**\n * When host binding is executing this points to the directive index.\n * `TView.data[getCurrentDirectiveIndex()]` is `DirectiveDef`\n * `LView[getCurrentDirectiveIndex()]` is directive instance.\n */\nexport function getCurrentDirectiveIndex(): number {\n  return instructionState.lFrame.currentDirectiveIndex;\n}\n\n/**\n * Sets an index of a directive whose `hostBindings` are being processed.\n *\n * @param currentDirectiveIndex `TData` index where current directive instance can be found.\n */\nexport function setCurrentDirectiveIndex(currentDirectiveIndex: number): void {\n  instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;\n}\n\n/**\n * Retrieve the current `DirectiveDef` which is active when `hostBindings` instruction is being\n * executed.\n *\n * @param tData Current `TData` where the `DirectiveDef` will be looked up at.\n */\nexport function getCurrentDirectiveDef(tData: TData): DirectiveDef<any> | null {\n  const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;\n  return currentDirectiveIndex === -1 ? null : (tData[currentDirectiveIndex] as DirectiveDef<any>);\n}\n\nexport function getCurrentQueryIndex(): number {\n  return instructionState.lFrame.currentQueryIndex;\n}\n\nexport function setCurrentQueryIndex(value: number): void {\n  instructionState.lFrame.currentQueryIndex = value;\n}\n\n/**\n * Returns a `TNode` of the location where the current `LView` is declared at.\n *\n * @param lView an `LView` that we want to find parent `TNode` for.\n */\nfunction getDeclarationTNode(lView: LView): TNode | null {\n  const tView = lView[TVIEW];\n\n  // Return the declaration parent for embedded views\n  if (tView.type === TViewType.Embedded) {\n    ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');\n    return tView.declTNode;\n  }\n\n  // Components don't have `TView.declTNode` because each instance of component could be\n  // inserted in different location, hence `TView.declTNode` is meaningless.\n  // Falling back to `T_HOST` in case we cross component boundary.\n  if (tView.type === TViewType.Component) {\n    return lView[T_HOST];\n  }\n\n  // Remaining TNode type is `TViewType.Root` which doesn't have a parent TNode.\n  return null;\n}\n\n/**\n * This is a light weight version of the `enterView` which is needed by the DI system.\n *\n * @param lView `LView` location of the DI context.\n * @param tNode `TNode` for DI context\n * @param flags DI context flags. if `SkipSelf` flag is set than we walk up the declaration\n *     tree from `tNode`  until we find parent declared `TElementNode`.\n * @returns `true` if we have successfully entered DI associated with `tNode` (or with declared\n *     `TNode` if `flags` has  `SkipSelf`). Failing to enter DI implies that no associated\n *     `NodeInjector` can be found and we should instead use `ModuleInjector`.\n *     - If `true` than this call must be fallowed by `leaveDI`\n *     - If `false` than this call failed and we should NOT call `leaveDI`\n */\nexport function enterDI(lView: LView, tNode: TNode, flags: InternalInjectFlags) {\n  ngDevMode && assertLViewOrUndefined(lView);\n\n  if (flags & InternalInjectFlags.SkipSelf) {\n    ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);\n\n    let parentTNode = tNode as TNode | null;\n    let parentLView = lView;\n\n    while (true) {\n      ngDevMode && assertDefined(parentTNode, 'Parent TNode should be defined');\n      parentTNode = parentTNode!.parent as TNode | null;\n      if (parentTNode === null && !(flags & InternalInjectFlags.Host)) {\n        parentTNode = getDeclarationTNode(parentLView);\n        if (parentTNode === null) break;\n\n        // In this case, a parent exists and is definitely an element. So it will definitely\n        // have an existing lView as the declaration view, which is why we can assume it's defined.\n        ngDevMode && assertDefined(parentLView, 'Parent LView should be defined');\n        parentLView = parentLView[DECLARATION_VIEW]!;\n\n        // In Ivy there are Comment nodes that correspond to ngIf and NgFor embedded directives\n        // We want to skip those and look only at Elements and ElementContainers to ensure\n        // we're looking at true parent nodes, and not content or other types.\n        if (parentTNode.type & (TNodeType.Element | TNodeType.ElementContainer)) {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n    if (parentTNode === null) {\n      // If we failed to find a parent TNode this means that we should use module injector.\n      return false;\n    } else {\n      tNode = parentTNode;\n      lView = parentLView;\n    }\n  }\n\n  ngDevMode && assertTNodeForLView(tNode, lView);\n  const lFrame = (instructionState.lFrame = allocLFrame());\n  lFrame.currentTNode = tNode;\n  lFrame.lView = lView;\n\n  return true;\n}\n\n/**\n * Swap the current lView with a new lView.\n *\n * For performance reasons we store the lView in the top level of the module.\n * This way we minimize the number of properties to read. Whenever a new view\n * is entered we have to store the lView for later, and when the view is\n * exited the state has to be restored\n *\n * @param newView New lView to become active\n * @returns the previously active lView;\n */\nexport function enterView(newView: LView): void {\n  ngDevMode && assertNotEqual(newView[0], newView[1] as any, '????');\n  ngDevMode && assertLViewOrUndefined(newView);\n  const newLFrame = allocLFrame();\n  if (ngDevMode) {\n    assertEqual(newLFrame.isParent, true, 'Expected clean LFrame');\n    assertEqual(newLFrame.lView, null, 'Expected clean LFrame');\n    assertEqual(newLFrame.tView, null, 'Expected clean LFrame');\n    assertEqual(newLFrame.selectedIndex, -1, 'Expected clean LFrame');\n    assertEqual(newLFrame.elementDepthCount, 0, 'Expected clean LFrame');\n    assertEqual(newLFrame.currentDirectiveIndex, -1, 'Expected clean LFrame');\n    assertEqual(newLFrame.currentNamespace, null, 'Expected clean LFrame');\n    assertEqual(newLFrame.bindingRootIndex, -1, 'Expected clean LFrame');\n    assertEqual(newLFrame.currentQueryIndex, 0, 'Expected clean LFrame');\n  }\n  const tView = newView[TVIEW];\n  instructionState.lFrame = newLFrame;\n  ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);\n  newLFrame.currentTNode = tView.firstChild!;\n  newLFrame.lView = newView;\n  newLFrame.tView = tView;\n  newLFrame.contextLView = newView;\n  newLFrame.bindingIndex = tView.bindingStartIndex;\n  newLFrame.inI18n = false;\n}\n\n/**\n * Allocates next free LFrame. This function tries to reuse the `LFrame`s to lower memory pressure.\n */\nfunction allocLFrame() {\n  const currentLFrame = instructionState.lFrame;\n  const childLFrame = currentLFrame === null ? null : currentLFrame.child;\n  const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;\n  return newLFrame;\n}\n\nfunction createLFrame(parent: LFrame | null): LFrame {\n  const lFrame: LFrame = {\n    currentTNode: null,\n    isParent: true,\n    lView: null!,\n    tView: null!,\n    selectedIndex: -1,\n    contextLView: null,\n    elementDepthCount: 0,\n    currentNamespace: null,\n    currentDirectiveIndex: -1,\n    bindingRootIndex: -1,\n    bindingIndex: -1,\n    currentQueryIndex: 0,\n    parent: parent!,\n    child: null,\n    inI18n: false,\n  };\n  parent !== null && (parent.child = lFrame); // link the new LFrame for reuse.\n  return lFrame;\n}\n\n/**\n * A lightweight version of leave which is used with DI.\n *\n * This function only resets `currentTNode` and `LView` as those are the only properties\n * used with DI (`enterDI()`).\n *\n * NOTE: This function is reexported as `leaveDI`. However `leaveDI` has return type of `void` where\n * as `leaveViewLight` has `LFrame`. This is so that `leaveViewLight` can be used in `leaveView`.\n */\nfunction leaveViewLight(): LFrame {\n  const oldLFrame = instructionState.lFrame;\n  instructionState.lFrame = oldLFrame.parent;\n  oldLFrame.currentTNode = null!;\n  oldLFrame.lView = null!;\n  return oldLFrame;\n}\n\n/**\n * This is a lightweight version of the `leaveView` which is needed by the DI system.\n *\n * NOTE: this function is an alias so that we can change the type of the function to have `void`\n * return type.\n */\nexport const leaveDI: () => void = leaveViewLight;\n\n/**\n * Leave the current `LView`\n *\n * This pops the `LFrame` with the associated `LView` from the stack.\n *\n * IMPORTANT: We must zero out the `LFrame` values here otherwise they will be retained. This is\n * because for performance reasons we don't release `LFrame` but rather keep it for next use.\n */\nexport function leaveView() {\n  const oldLFrame = leaveViewLight();\n  oldLFrame.isParent = true;\n  oldLFrame.tView = null!;\n  oldLFrame.selectedIndex = -1;\n  oldLFrame.contextLView = null;\n  oldLFrame.elementDepthCount = 0;\n  oldLFrame.currentDirectiveIndex = -1;\n  oldLFrame.currentNamespace = null;\n  oldLFrame.bindingRootIndex = -1;\n  oldLFrame.bindingIndex = -1;\n  oldLFrame.currentQueryIndex = 0;\n}\n\nexport function nextContextImpl<T = any>(level: number): T {\n  const contextLView = (instructionState.lFrame.contextLView = walkUpViews(\n    level,\n    instructionState.lFrame.contextLView!,\n  ));\n  return contextLView[CONTEXT] as unknown as T;\n}\n\n/**\n * Gets the currently selected element index.\n *\n * Used with {@link property} instruction (and more in the future) to identify the index in the\n * current `LView` to act on.\n */\nexport function getSelectedIndex() {\n  return instructionState.lFrame.selectedIndex;\n}\n\n/**\n * Sets the most recent index passed to {@link select}\n *\n * Used with {@link property} instruction (and more in the future) to identify the index in the\n * current `LView` to act on.\n *\n * (Note that if an \"exit function\" was set earlier (via `setElementExitFn()`) then that will be\n * run if and when the provided `index` value is different from the current selected index value.)\n */\nexport function setSelectedIndex(index: number) {\n  ngDevMode &&\n    index !== -1 &&\n    assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Index must be past HEADER_OFFSET (or -1).');\n  ngDevMode &&\n    assertLessThan(\n      index,\n      instructionState.lFrame.lView.length,\n      \"Can't set index passed end of LView\",\n    );\n  instructionState.lFrame.selectedIndex = index;\n}\n\n/**\n * Gets the `tNode` that represents currently selected element.\n */\nexport function getSelectedTNode() {\n  const lFrame = instructionState.lFrame;\n  return getTNode(lFrame.tView, lFrame.selectedIndex);\n}\n\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/2000/svg'` in global state.\n *\n * @codeGenApi\n */\nexport function ɵɵnamespaceSVG() {\n  instructionState.lFrame.currentNamespace = SVG_NAMESPACE;\n}\n\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/1998/MathML/'` in global state.\n *\n * @codeGenApi\n */\nexport function ɵɵnamespaceMathML() {\n  instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;\n}\n\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n *\n * @codeGenApi\n */\nexport function ɵɵnamespaceHTML() {\n  namespaceHTMLInternal();\n}\n\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n */\nexport function namespaceHTMLInternal() {\n  instructionState.lFrame.currentNamespace = null;\n}\n\nexport function getNamespace(): string | null {\n  return instructionState.lFrame.currentNamespace;\n}\n\nlet _wasLastNodeCreated = true;\n\n/**\n * Retrieves a global flag that indicates whether the most recent DOM node\n * was created or hydrated.\n */\nexport function wasLastNodeCreated(): boolean {\n  return _wasLastNodeCreated;\n}\n\n/**\n * Sets a global flag to indicate whether the most recent DOM node\n * was created or hydrated.\n */\nexport function lastNodeWasCreated(flag: boolean): void {\n  _wasLastNodeCreated = flag;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {EMPTY_ARRAY} from '../util/empty';\nimport {stringify} from '../util/stringify';\n\nimport type {Injector} from './injector';\nimport type {EnvironmentProviders, Provider, StaticProvider} from './interface/provider';\nimport {importProvidersFrom} from './provider_collection';\nimport {getNullInjector, R3Injector} from './r3_injector';\nimport {InjectorScope} from './scope';\n\n/**\n * Create a new `Injector` which is configured using a `defType` of `InjectorType<any>`s.\n */\nexport function createInjector(\n  defType: /* InjectorType<any> */ any,\n  parent: Injector | null = null,\n  additionalProviders: Array<Provider | StaticProvider> | null = null,\n  name?: string,\n): Injector {\n  const injector = createInjectorWithoutInjectorInstances(\n    defType,\n    parent,\n    additionalProviders,\n    name,\n  );\n  injector.resolveInjectorInitializers();\n  return injector;\n}\n\n/**\n * Creates a new injector without eagerly resolving its injector types. Can be used in places\n * where resolving the injector types immediately can lead to an infinite loop. The injector types\n * should be resolved at a later point by calling `_resolveInjectorDefTypes`.\n */\nexport function createInjectorWithoutInjectorInstances(\n  defType: /* InjectorType<any> */ any,\n  parent: Injector | null = null,\n  additionalProviders: Array<Provider | EnvironmentProviders> | null = null,\n  name?: string,\n  scopes = new Set<InjectorScope>(),\n): R3Injector {\n  const providers = [additionalProviders || EMPTY_ARRAY, importProvidersFrom(defType)];\n  name = name || (typeof defType === 'object' ? undefined : stringify(defType));\n\n  return new R3Injector(providers, parent || getNullInjector(), name || null, scopes);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {createInjector} from './create_injector';\nimport {THROW_IF_NOT_FOUND, ɵɵinject} from './injector_compatibility';\nimport {InjectorMarkers} from './injector_marker';\nimport {INJECTOR} from './injector_token';\nimport {ɵɵdefineInjectable} from './interface/defs';\nimport {InjectOptions} from './interface/injector';\nimport {Provider, StaticProvider} from './interface/provider';\nimport {NullInjector} from './null_injector';\nimport {ProviderToken} from './provider_token';\n\n/**\n * Concrete injectors implement this interface. Injectors are configured\n * with [providers](guide/di/dependency-injection-providers) that associate\n * dependencies of various types with [injection tokens](guide/di/dependency-injection-providers).\n *\n * @see [DI Providers](guide/di/dependency-injection-providers).\n * @see {@link StaticProvider}\n *\n * @usageNotes\n *\n *  The following example creates a service injector instance.\n *\n * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\n *\n * ### Usage example\n *\n * {@example core/di/ts/injector_spec.ts region='Injector'}\n *\n * `Injector` returns itself when given `Injector` as a token:\n *\n * {@example core/di/ts/injector_spec.ts region='injectInjector'}\n *\n * @see [Types of injector hierarchies](guide/di/hierarchical-dependency-injection#types-of-injector-hierarchies)\n *\n * @publicApi\n */\nexport abstract class Injector {\n  static THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;\n  static NULL: Injector = /* @__PURE__ */ new NullInjector();\n\n  /**\n   * Retrieves an instance from the injector based on the provided token.\n   * @returns The instance from the injector if defined, otherwise the `notFoundValue`.\n   * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.\n   */\n  abstract get<T>(\n    token: ProviderToken<T>,\n    notFoundValue: undefined,\n    options: InjectOptions & {\n      optional?: false;\n    },\n  ): T;\n  /**\n   * Retrieves an instance from the injector based on the provided token.\n   * @returns The instance from the injector if defined, otherwise the `notFoundValue`.\n   * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.\n   */\n  abstract get<T>(\n    token: ProviderToken<T>,\n    notFoundValue: null | undefined,\n    options: InjectOptions,\n  ): T | null;\n  /**\n   * Retrieves an instance from the injector based on the provided token.\n   * @returns The instance from the injector if defined, otherwise the `notFoundValue`.\n   * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.\n   */\n  abstract get<T>(token: ProviderToken<T>, notFoundValue?: T, options?: InjectOptions): T;\n  /**\n   * @deprecated from v4.0.0 use ProviderToken<T>\n   * @suppress {duplicate}\n   */\n  abstract get<T>(token: string | ProviderToken<T>, notFoundValue?: any): any;\n\n  /**\n   * @deprecated from v5 use the new signature Injector.create(options)\n   */\n  static create(providers: StaticProvider[], parent?: Injector): Injector;\n\n  /**\n   * Creates a new injector instance that provides one or more dependencies,\n   * according to a given type or types of `StaticProvider`.\n   *\n   * @param options An object with the following properties:\n   * * `providers`: An array of providers of the [StaticProvider type](api/core/StaticProvider).\n   * * `parent`: (optional) A parent injector.\n   * * `name`: (optional) A developer-defined identifying name for the new injector.\n   *\n   * @returns The new injector instance.\n   *\n   */\n  static create(options: {\n    providers: Array<Provider | StaticProvider>;\n    parent?: Injector;\n    name?: string;\n  }): DestroyableInjector;\n\n  static create(\n    options:\n      | StaticProvider[]\n      | {providers: Array<Provider | StaticProvider>; parent?: Injector; name?: string},\n    parent?: Injector,\n  ): Injector {\n    if (Array.isArray(options)) {\n      return createInjector({name: ''}, parent, options, '');\n    } else {\n      const name = options.name ?? '';\n      return createInjector({name}, options.parent, options.providers, name);\n    }\n  }\n\n  /** @nocollapse */\n  static ɵprov = /** @pureOrBreakMyCode */ /* @__PURE__ */ ɵɵdefineInjectable({\n    token: Injector,\n    providedIn: 'any',\n    factory: () => ɵɵinject(INJECTOR),\n  });\n\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ELEMENT_ID__ = InjectorMarkers.Injector;\n}\n\n/**\n * An Injector that the owner can destroy and trigger the DestroyRef.destroy hooks.\n *\n * @publicApi\n */\nexport interface DestroyableInjector extends Injector {\n  destroy(): void;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InjectionToken} from './di';\n\n/**\n * A DI Token representing the main rendering context.\n * In a browser and SSR this is the DOM Document.\n * When using SSR, that document is created by [Domino](https://github.com/angular/domino).\n *\n * @see [Accessing Document via DI](guide/ssr#accessing-document-via-di)\n *\n * @publicApi\n */\nexport const DOCUMENT = new InjectionToken<Document>(\n  typeof ngDevMode !== 'undefined' && ngDevMode ? 'DocumentToken' : '',\n);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {EnvironmentInjector} from '../di';\nimport {isDestroyed} from '../render3/interfaces/type_checks';\nimport {LView} from '../render3/interfaces/view';\nimport {getLView} from '../render3/state';\nimport {removeLViewOnDestroy, storeLViewOnDestroy} from '../render3/util/view_utils';\n\n/**\n * `DestroyRef` lets you set callbacks to run for any cleanup or destruction behavior.\n * The scope of this destruction depends on where `DestroyRef` is injected. If `DestroyRef`\n * is injected in a component or directive, the callbacks run when that component or\n * directive is destroyed. Otherwise the callbacks run when a corresponding injector is destroyed.\n *\n * @see [Lifecycle DestroyRef](guide/components/lifecycle#destroyref)\n *\n * @publicApi\n */\nexport abstract class DestroyRef {\n  // Here the `DestroyRef` acts primarily as a DI token. There are (currently) types of objects that\n  // can be returned from the injector when asking for this token:\n  // - `NodeInjectorDestroyRef` when retrieved from a node injector;\n  // - `EnvironmentInjector` when retrieved from an environment injector\n\n  /**\n   * Registers a destroy callback in a given lifecycle scope.  Returns a cleanup function that can\n   * be invoked to unregister the callback.\n   *\n   * @usageNotes\n   * ### Example\n   * ```ts\n   * const destroyRef = inject(DestroyRef);\n   *\n   * // register a destroy callback\n   * const unregisterFn = destroyRef.onDestroy(() => doSomethingOnDestroy());\n   *\n   * // stop the destroy callback from executing if needed\n   * unregisterFn();\n   * ```\n   *\n   * @see [Lifecycle DestroyRef](guide/components/lifecycle#destroyref)\n   *\n   */\n  abstract onDestroy(callback: () => void): () => void;\n\n  /**\n   * Indicates whether the instance has already been destroyed.\n   *\n   * @see [Detecting instance destruction](guide/components/lifecycle#detecting-instance-destruction)\n   *\n   */\n  abstract get destroyed(): boolean;\n\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ELEMENT_ID__: () => DestroyRef = injectDestroyRef;\n\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ENV_ID__: (injector: EnvironmentInjector) => DestroyRef = (injector) => injector;\n}\n\nexport class NodeInjectorDestroyRef extends DestroyRef {\n  constructor(readonly _lView: LView) {\n    super();\n  }\n\n  override get destroyed() {\n    return isDestroyed(this._lView);\n  }\n\n  override onDestroy(callback: () => void): () => void {\n    const lView = this._lView;\n\n    storeLViewOnDestroy(lView, callback);\n    return () => removeLViewOnDestroy(lView, callback);\n  }\n}\n\nfunction injectDestroyRef(): DestroyRef {\n  return new NodeInjectorDestroyRef(getLView());\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nexport const SCHEDULE_IN_ROOT_ZONE_DEFAULT = false;\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {BehaviorSubject, Observable} from 'rxjs';\n\nimport {ɵɵdefineInjectable} from './di/interface/defs';\nimport {OnDestroy} from './change_detection/lifecycle_hooks';\n\n/**\n * Internal implementation of the pending tasks service.\n */\n\nexport class PendingTasksInternal implements OnDestroy {\n  private taskId = 0;\n  private pendingTasks = new Set<number>();\n  private destroyed = false;\n\n  private pendingTask = new BehaviorSubject<boolean>(false);\n\n  get hasPendingTasks(): boolean {\n    // Accessing the value of a closed `BehaviorSubject` throws an error.\n    return this.destroyed ? false : this.pendingTask.value;\n  }\n\n  /**\n   * In case the service is about to be destroyed, return a self-completing observable.\n   * Otherwise, return the observable that emits the current state of pending tasks.\n   */\n  get hasPendingTasksObservable(): Observable<boolean> {\n    if (this.destroyed) {\n      // Manually creating the observable pulls less symbols from RxJS than `of(false)`.\n      return new Observable<boolean>((subscriber) => {\n        subscriber.next(false);\n        subscriber.complete();\n      });\n    }\n\n    return this.pendingTask;\n  }\n\n  add(): number {\n    // Emitting a value to a closed subject throws an error.\n    if (!this.hasPendingTasks && !this.destroyed) {\n      this.pendingTask.next(true);\n    }\n    const taskId = this.taskId++;\n    this.pendingTasks.add(taskId);\n    return taskId;\n  }\n\n  has(taskId: number): boolean {\n    return this.pendingTasks.has(taskId);\n  }\n\n  remove(taskId: number): void {\n    this.pendingTasks.delete(taskId);\n    if (this.pendingTasks.size === 0 && this.hasPendingTasks) {\n      this.pendingTask.next(false);\n    }\n  }\n\n  ngOnDestroy(): void {\n    this.pendingTasks.clear();\n    if (this.hasPendingTasks) {\n      this.pendingTask.next(false);\n    }\n    // We call `unsubscribe()` to release observers, as users may forget to\n    // unsubscribe manually when subscribing to `isStable`. We do not call\n    // `complete()` because it is unsafe; if someone subscribes using the `first`\n    // operator and the observable completes before emitting a value,\n    // RxJS will throw an error.\n    this.destroyed = true;\n    this.pendingTask.unsubscribe();\n  }\n\n  /** @nocollapse */\n  static ɵprov = /** @pureOrBreakMyCode */ /* @__PURE__ */ ɵɵdefineInjectable({\n    token: PendingTasksInternal,\n    providedIn: 'root',\n    factory: () => new PendingTasksInternal(),\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {setActiveConsumer} from '../primitives/signals';\nimport {PartialObserver, Subject, Subscription} from 'rxjs';\n\nimport {OutputRef} from './authoring/output/output_ref';\nimport {isInInjectionContext} from './di/contextual';\nimport {inject} from './di/injector_compatibility';\nimport {DestroyRef} from './linker/destroy_ref';\nimport {PendingTasksInternal} from './pending_tasks_internal';\n\n/**\n * Use in components with the `@Output` directive to emit custom events\n * synchronously or asynchronously, and register handlers for those events\n * by subscribing to an instance.\n *\n * @usageNotes\n *\n * Extends\n * [RxJS `Subject`](https://rxjs.dev/api/index/class/Subject)\n * for Angular by adding the `emit()` method.\n *\n * In the following example, a component defines two output properties\n * that create event emitters. When the title is clicked, the emitter\n * emits an open or close event to toggle the current visibility state.\n *\n * ```angular-ts\n * @Component({\n *   selector: 'zippy',\n *   template: `\n *   <div class=\"zippy\">\n *     <div (click)=\"toggle()\">Toggle</div>\n *     <div [hidden]=\"!visible\">\n *       <ng-content></ng-content>\n *     </div>\n *  </div>`})\n * export class Zippy {\n *   visible: boolean = true;\n *   @Output() open: EventEmitter<any> = new EventEmitter();\n *   @Output() close: EventEmitter<any> = new EventEmitter();\n *\n *   toggle() {\n *     this.visible = !this.visible;\n *     if (this.visible) {\n *       this.open.emit(null);\n *     } else {\n *       this.close.emit(null);\n *     }\n *   }\n * }\n * ```\n *\n * Access the event object with the `$event` argument passed to the output event\n * handler:\n *\n * ```html\n * <zippy (open)=\"onOpen($event)\" (close)=\"onClose($event)\"></zippy>\n * ```\n *\n * @see [Declaring outputs with the @Output decorator](guide/components/outputs#declaring-outputs-with-the-output-decorator)\n *\n * @publicApi\n */\nexport interface EventEmitter<T> extends Subject<T>, OutputRef<T> {\n  /**\n   * @internal\n   */\n  __isAsync: boolean;\n\n  /**\n   * Creates an instance of this class that can\n   * deliver events synchronously or asynchronously.\n   *\n   * @param [isAsync=false] When true, deliver events asynchronously.\n   *\n   */\n  new (isAsync?: boolean): EventEmitter<T>;\n\n  /**\n   * Emits an event containing a given value.\n   * @param value The value to emit.\n   */\n  emit(value?: T): void;\n\n  /**\n   * Registers handlers for events emitted by this instance.\n   * @param next When supplied, a custom handler for emitted events.\n   * @param error When supplied, a custom handler for an error notification from this emitter.\n   * @param complete When supplied, a custom handler for a completion notification from this\n   *     emitter.\n   */\n  subscribe(\n    next?: (value: T) => void,\n    error?: (error: any) => void,\n    complete?: () => void,\n  ): Subscription;\n  /**\n   * Registers handlers for events emitted by this instance.\n   * @param observerOrNext When supplied, a custom handler for emitted events, or an observer\n   *     object.\n   * @param error When supplied, a custom handler for an error notification from this emitter.\n   * @param complete When supplied, a custom handler for a completion notification from this\n   *     emitter.\n   */\n  subscribe(observerOrNext?: any, error?: any, complete?: any): Subscription;\n}\n\nclass EventEmitter_ extends Subject<any> implements OutputRef<any> {\n  // tslint:disable-next-line:require-internal-with-underscore\n  __isAsync: boolean;\n  destroyRef: DestroyRef | undefined = undefined;\n  private readonly pendingTasks: PendingTasksInternal | undefined = undefined;\n\n  constructor(isAsync: boolean = false) {\n    super();\n    this.__isAsync = isAsync;\n\n    // Attempt to retrieve a `DestroyRef` and `PendingTasks` optionally.\n    // For backwards compatibility reasons, this cannot be required.\n    if (isInInjectionContext()) {\n      // `DestroyRef` is optional because it is not available in all contexts.\n      // But it is useful to properly complete the `EventEmitter` if used with `outputToObservable`\n      // when the component/directive is destroyed. (See `outputToObservable` for more details.)\n      this.destroyRef = inject(DestroyRef, {optional: true}) ?? undefined;\n      this.pendingTasks = inject(PendingTasksInternal, {optional: true}) ?? undefined;\n    }\n  }\n\n  emit(value?: any) {\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      super.next(value);\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n  }\n\n  override subscribe(observerOrNext?: any, error?: any, complete?: any): Subscription {\n    let nextFn = observerOrNext;\n    let errorFn = error || (() => null);\n    let completeFn = complete;\n\n    if (observerOrNext && typeof observerOrNext === 'object') {\n      const observer = observerOrNext as PartialObserver<unknown>;\n      nextFn = observer.next?.bind(observer);\n      errorFn = observer.error?.bind(observer);\n      completeFn = observer.complete?.bind(observer);\n    }\n\n    if (this.__isAsync) {\n      errorFn = this.wrapInTimeout(errorFn);\n\n      if (nextFn) {\n        nextFn = this.wrapInTimeout(nextFn);\n      }\n\n      if (completeFn) {\n        completeFn = this.wrapInTimeout(completeFn);\n      }\n    }\n\n    const sink = super.subscribe({next: nextFn, error: errorFn, complete: completeFn});\n\n    if (observerOrNext instanceof Subscription) {\n      observerOrNext.add(sink);\n    }\n\n    return sink;\n  }\n\n  private wrapInTimeout(fn: (value: unknown) => any) {\n    return (value: unknown) => {\n      const taskId = this.pendingTasks?.add();\n      setTimeout(() => {\n        try {\n          fn(value);\n        } finally {\n          if (taskId !== undefined) {\n            this.pendingTasks?.remove(taskId);\n          }\n        }\n      });\n    };\n  }\n}\n\n/**\n * @publicApi\n */\nexport const EventEmitter: {\n  new (isAsync?: boolean): EventEmitter<any>;\n  new <T>(isAsync?: boolean): EventEmitter<T>;\n  readonly prototype: EventEmitter<any>;\n} = EventEmitter_ as any;\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nexport function noop(...args: any[]): any {\n  // Do nothing.\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {noop} from './noop';\n\n/**\n * Gets a scheduling function that runs the callback after the first of setTimeout and\n * requestAnimationFrame resolves.\n *\n * - `requestAnimationFrame` ensures that change detection runs ahead of a browser repaint.\n * This ensures that the create and update passes of a change detection always happen\n * in the same frame.\n * - When the browser is resource-starved, `rAF` can execute _before_ a `setTimeout` because\n * rendering is a very high priority process. This means that `setTimeout` cannot guarantee\n * same-frame create and update pass, when `setTimeout` is used to schedule the update phase.\n * - While `rAF` gives us the desirable same-frame updates, it has two limitations that\n * prevent it from being used alone. First, it does not run in background tabs, which would\n * prevent Angular from initializing an application when opened in a new tab (for example).\n * Second, repeated calls to requestAnimationFrame will execute at the refresh rate of the\n * hardware (~16ms for a 60Hz display). This would cause significant slowdown of tests that\n * are written with several updates and asserts in the form of \"update; await stable; assert;\".\n * - Both `setTimeout` and `rAF` are able to \"coalesce\" several events from a single user\n * interaction into a single change detection. Importantly, this reduces view tree traversals when\n * compared to an alternative timing mechanism like `queueMicrotask`, where change detection would\n * then be interleaves between each event.\n *\n * By running change detection after the first of `setTimeout` and `rAF` to execute, we get the\n * best of both worlds.\n *\n * @returns a function to cancel the scheduled callback\n */\nexport function scheduleCallbackWithRafRace(callback: Function): () => void {\n  let timeoutId: number;\n  let animationFrameId: number;\n  function cleanup() {\n    callback = noop;\n    try {\n      if (animationFrameId !== undefined && typeof cancelAnimationFrame === 'function') {\n        cancelAnimationFrame(animationFrameId);\n      }\n      if (timeoutId !== undefined) {\n        clearTimeout(timeoutId);\n      }\n    } catch {\n      // Clearing/canceling can fail in tests due to the timing of functions being patched and unpatched\n      // Just ignore the errors - we protect ourselves from this issue by also making the callback a no-op.\n    }\n  }\n  timeoutId = setTimeout(() => {\n    callback();\n    cleanup();\n  }) as unknown as number;\n  if (typeof requestAnimationFrame === 'function') {\n    animationFrameId = requestAnimationFrame(() => {\n      callback();\n      cleanup();\n    });\n  }\n\n  return () => cleanup();\n}\n\nexport function scheduleCallbackWithMicrotask(callback: Function): () => void {\n  queueMicrotask(() => callback());\n\n  return () => {\n    callback = noop;\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\ninterface ConsoleWithAsyncTagging {\n  createTask(name: string): ConsoleTask;\n}\n\ninterface ConsoleTask {\n  run<T>(f: () => T): T;\n}\n\ninterface ZoneConsoleTask extends Task {\n  consoleTask?: ConsoleTask;\n}\n\nexport class AsyncStackTaggingZoneSpec implements ZoneSpec {\n  createTask: ConsoleWithAsyncTagging['createTask'];\n\n  constructor(\n    namePrefix: string,\n    consoleAsyncStackTaggingImpl: ConsoleWithAsyncTagging = console as any,\n  ) {\n    this.name = 'asyncStackTagging for ' + namePrefix;\n    this.createTask = consoleAsyncStackTaggingImpl?.createTask ?? (() => null);\n  }\n\n  // ZoneSpec implementation below.\n  name: string;\n\n  onScheduleTask(\n    delegate: ZoneDelegate,\n    _current: Zone,\n    target: Zone,\n    task: ZoneConsoleTask,\n  ): Task {\n    task.consoleTask = this.createTask(`Zone - ${task.source || task.type}`);\n    return delegate.scheduleTask(target, task);\n  }\n\n  onInvokeTask(\n    delegate: ZoneDelegate,\n    _currentZone: Zone,\n    targetZone: Zone,\n    task: ZoneConsoleTask,\n    applyThis: any,\n    applyArgs?: any[],\n  ) {\n    let ret;\n    if (task.consoleTask) {\n      ret = task.consoleTask.run(() => delegate.invokeTask(targetZone, task, applyThis, applyArgs));\n    } else {\n      ret = delegate.invokeTask(targetZone, task, applyThis, applyArgs);\n    }\n    return ret;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n// Needed for the global `Zone` ambient types to be available.\nimport type {} from 'zone.js';\n\nimport {SCHEDULE_IN_ROOT_ZONE_DEFAULT} from '../change_detection/scheduling/flags';\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {EventEmitter} from '../event_emitter';\nimport {scheduleCallbackWithRafRace} from '../util/callback_scheduler';\nimport {noop} from '../util/noop';\n\nimport {AsyncStackTaggingZoneSpec} from './async-stack-tagging';\n\n// The below is needed as otherwise a number of targets fail in G3 due to:\n// ERROR - [JSC_UNDEFINED_VARIABLE] variable Zone is undeclared\ndeclare const Zone: any;\n\nconst isAngularZoneProperty = 'isAngularZone';\nexport const angularZoneInstanceIdProperty = isAngularZoneProperty + '_ID';\n\nlet ngZoneInstanceId = 0;\n\n/**\n * An injectable service for executing work inside or outside of the Angular zone.\n *\n * The most common use of this service is to optimize performance when starting a work consisting of\n * one or more asynchronous tasks that don't require UI updates or error handling to be handled by\n * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks\n * can reenter the Angular zone via {@link #run}.\n *\n * <!-- TODO: add/fix links to:\n *   - docs explaining zones and the use of zones in Angular and change-detection\n *   - link to runOutsideAngular/run (throughout this file!)\n *   -->\n *\n * @usageNotes\n * ### Example\n *\n * ```ts\n * import {Component, NgZone} from '@angular/core';\n *\n * @Component({\n *   selector: 'ng-zone-demo',\n *   template: `\n *     <h2>Demo: NgZone</h2>\n *\n *     <p>Progress: {{progress}}%</p>\n *     @if(progress >= 100) {\n *        <p>Done processing {{label}} of Angular zone!</p>\n *     }\n *\n *     <button (click)=\"processWithinAngularZone()\">Process within Angular zone</button>\n *     <button (click)=\"processOutsideOfAngularZone()\">Process outside of Angular zone</button>\n *   `,\n * })\n * export class NgZoneDemo {\n *   progress: number = 0;\n *   label: string;\n *\n *   constructor(private _ngZone: NgZone) {}\n *\n *   // Loop inside the Angular zone\n *   // so the UI DOES refresh after each setTimeout cycle\n *   processWithinAngularZone() {\n *     this.label = 'inside';\n *     this.progress = 0;\n *     this._increaseProgress(() => console.log('Inside Done!'));\n *   }\n *\n *   // Loop outside of the Angular zone\n *   // so the UI DOES NOT refresh after each setTimeout cycle\n *   processOutsideOfAngularZone() {\n *     this.label = 'outside';\n *     this.progress = 0;\n *     this._ngZone.runOutsideAngular(() => {\n *       this._increaseProgress(() => {\n *         // reenter the Angular zone and display done\n *         this._ngZone.run(() => { console.log('Outside Done!'); });\n *       });\n *     });\n *   }\n *\n *   _increaseProgress(doneCallback: () => void) {\n *     this.progress += 1;\n *     console.log(`Current progress: ${this.progress}%`);\n *\n *     if (this.progress < 100) {\n *       window.setTimeout(() => this._increaseProgress(doneCallback), 10);\n *     } else {\n *       doneCallback();\n *     }\n *   }\n * }\n * ```\n *\n * @see [Resolving zone pollution](best-practices/zone-pollution#run-tasks-outside-ngzone)\n *\n * @publicApi\n */\nexport class NgZone {\n  readonly hasPendingMacrotasks: boolean = false;\n  readonly hasPendingMicrotasks: boolean = false;\n\n  /**\n   * Whether there are no outstanding microtasks or macrotasks.\n   */\n  readonly isStable: boolean = true;\n\n  /**\n   * Notifies when code enters Angular Zone. This gets fired first on VM Turn.\n   */\n  readonly onUnstable: EventEmitter<any> = new EventEmitter(false);\n\n  /**\n   * Notifies when there is no more microtasks enqueued in the current VM Turn.\n   * This is a hint for Angular to do change detection, which may enqueue more microtasks.\n   * For this reason this event can fire multiple times per VM Turn.\n   */\n  readonly onMicrotaskEmpty: EventEmitter<any> = new EventEmitter(false);\n\n  /**\n   * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which\n   * implies we are about to relinquish VM turn.\n   * This event gets called just once.\n   */\n  readonly onStable: EventEmitter<any> = new EventEmitter(false);\n\n  /**\n   * Notifies that an error has been delivered.\n   */\n  readonly onError: EventEmitter<any> = new EventEmitter(false);\n\n  constructor(options: {\n    enableLongStackTrace?: boolean;\n    shouldCoalesceEventChangeDetection?: boolean;\n    shouldCoalesceRunChangeDetection?: boolean;\n  }) {\n    const {\n      enableLongStackTrace = false,\n      shouldCoalesceEventChangeDetection = false,\n      shouldCoalesceRunChangeDetection = false,\n      scheduleInRootZone = SCHEDULE_IN_ROOT_ZONE_DEFAULT,\n    } = options as InternalNgZoneOptions;\n\n    if (typeof Zone == 'undefined') {\n      throw new RuntimeError(\n        RuntimeErrorCode.MISSING_ZONEJS,\n        ngDevMode && `In this configuration Angular requires Zone.js`,\n      );\n    }\n\n    Zone.assertZonePatched();\n    const self = this as any as NgZonePrivate;\n    self._nesting = 0;\n\n    self._outer = self._inner = Zone.current;\n\n    // AsyncStackTaggingZoneSpec provides `linked stack traces` to show\n    // where the async operation is scheduled. For more details, refer\n    // to this article, https://developer.chrome.com/blog/devtools-better-angular-debugging/\n    // And we only import this AsyncStackTaggingZoneSpec in development mode,\n    // in the production mode, the AsyncStackTaggingZoneSpec will be tree shaken away.\n    if (ngDevMode) {\n      self._inner = self._inner.fork(new AsyncStackTaggingZoneSpec('Angular'));\n    }\n\n    if ((Zone as any)['TaskTrackingZoneSpec']) {\n      self._inner = self._inner.fork(new ((Zone as any)['TaskTrackingZoneSpec'] as any)());\n    }\n\n    if (enableLongStackTrace && (Zone as any)['longStackTraceZoneSpec']) {\n      self._inner = self._inner.fork((Zone as any)['longStackTraceZoneSpec']);\n    }\n    // if shouldCoalesceRunChangeDetection is true, all tasks including event tasks will be\n    // coalesced, so shouldCoalesceEventChangeDetection option is not necessary and can be skipped.\n    self.shouldCoalesceEventChangeDetection =\n      !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;\n    self.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;\n    self.callbackScheduled = false;\n    self.scheduleInRootZone = scheduleInRootZone;\n    forkInnerZoneWithAngularBehavior(self);\n  }\n\n  /**\n    This method checks whether the method call happens within an Angular Zone instance.\n  */\n  static isInAngularZone(): boolean {\n    // Zone needs to be checked, because this method might be called even when NoopNgZone is used.\n    return typeof Zone !== 'undefined' && Zone.current.get(isAngularZoneProperty) === true;\n  }\n\n  /**\n    Assures that the method is called within the Angular Zone, otherwise throws an error.\n  */\n  static assertInAngularZone(): void {\n    if (!NgZone.isInAngularZone()) {\n      throw new RuntimeError(\n        RuntimeErrorCode.UNEXPECTED_ZONE_STATE,\n        ngDevMode && 'Expected to be in Angular Zone, but it is not!',\n      );\n    }\n  }\n\n  /**\n    Assures that the method is called outside of the Angular Zone, otherwise throws an error.\n  */\n  static assertNotInAngularZone(): void {\n    if (NgZone.isInAngularZone()) {\n      throw new RuntimeError(\n        RuntimeErrorCode.UNEXPECTED_ZONE_STATE,\n        ngDevMode && 'Expected to not be in Angular Zone, but it is!',\n      );\n    }\n  }\n\n  /**\n   * Executes the `fn` function synchronously within the Angular zone and returns value returned by\n   * the function.\n   *\n   * Running functions via `run` allows you to reenter Angular zone from a task that was executed\n   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * within the Angular zone.\n   *\n   * If a synchronous error happens it will be rethrown and not reported via `onError`.\n   */\n  run<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T {\n    return (this as any as NgZonePrivate)._inner.run(fn, applyThis, applyArgs);\n  }\n\n  /**\n   * Executes the `fn` function synchronously within the Angular zone as a task and returns value\n   * returned by the function.\n   *\n   * Running functions via `runTask` allows you to reenter Angular zone from a task that was executed\n   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * within the Angular zone.\n   *\n   * If a synchronous error happens it will be rethrown and not reported via `onError`.\n   */\n  runTask<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[], name?: string): T {\n    const zone = (this as any as NgZonePrivate)._inner;\n    const task = zone.scheduleEventTask('NgZoneEvent: ' + name, fn, EMPTY_PAYLOAD, noop, noop);\n    try {\n      return zone.runTask(task, applyThis, applyArgs);\n    } finally {\n      zone.cancelTask(task);\n    }\n  }\n\n  /**\n   * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not\n   * rethrown.\n   */\n  runGuarded<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T {\n    return (this as any as NgZonePrivate)._inner.runGuarded(fn, applyThis, applyArgs);\n  }\n\n  /**\n   * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by\n   * the function.\n   *\n   * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do\n   * work that\n   * doesn't trigger Angular change-detection or is subject to Angular's error handling.\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * outside of the Angular zone.\n   *\n   * Use {@link #run} to reenter the Angular zone and do work that updates the application model.\n   */\n  runOutsideAngular<T>(fn: (...args: any[]) => T): T {\n    return (this as any as NgZonePrivate)._outer.run(fn);\n  }\n}\n\nconst EMPTY_PAYLOAD = {};\n\nexport interface NgZonePrivate extends NgZone {\n  _outer: Zone;\n  _inner: Zone;\n  _nesting: number;\n  _hasPendingMicrotasks: boolean;\n\n  hasPendingMacrotasks: boolean;\n  hasPendingMicrotasks: boolean;\n  callbackScheduled: boolean;\n  /**\n   * A flag to indicate if NgZone is currently inside\n   * checkStable and to prevent re-entry. The flag is\n   * needed because it is possible to invoke the change\n   * detection from within change detection leading to\n   * incorrect behavior.\n   *\n   * For detail, please refer here,\n   * https://github.com/angular/angular/pull/40540\n   */\n  isCheckStableRunning: boolean;\n  isStable: boolean;\n  /**\n   * Optionally specify coalescing event change detections or not.\n   * Consider the following case.\n   *\n   * <div (click)=\"doSomething()\">\n   *   <button (click)=\"doSomethingElse()\"></button>\n   * </div>\n   *\n   * When button is clicked, because of the event bubbling, both\n   * event handlers will be called and 2 change detections will be\n   * triggered. We can coalesce such kind of events to trigger\n   * change detection only once.\n   *\n   * By default, this option will be false. So the events will not be\n   * coalesced and the change detection will be triggered multiple times.\n   * And if this option be set to true, the change detection will be\n   * triggered async by scheduling it in an animation frame. So in the case above,\n   * the change detection will only be trigged once.\n   */\n  shouldCoalesceEventChangeDetection: boolean;\n  /**\n   * Optionally specify if `NgZone#run()` method invocations should be coalesced\n   * into a single change detection.\n   *\n   * Consider the following case.\n   *\n   * for (let i = 0; i < 10; i ++) {\n   *   ngZone.run(() => {\n   *     // do something\n   *   });\n   * }\n   *\n   * This case triggers the change detection multiple times.\n   * With ngZoneRunCoalescing options, all change detections in an event loops trigger only once.\n   * In addition, the change detection executes in requestAnimation.\n   *\n   */\n  shouldCoalesceRunChangeDetection: boolean;\n\n  /**\n   * Whether to schedule the coalesced change detection in the root zone\n   */\n  scheduleInRootZone: boolean;\n}\n\nfunction checkStable(zone: NgZonePrivate) {\n  // TODO: @JiaLiPassion, should check zone.isCheckStableRunning to prevent\n  // re-entry. The case is:\n  //\n  // @Component({...})\n  // export class AppComponent {\n  // constructor(private ngZone: NgZone) {\n  //   this.ngZone.onStable.subscribe(() => {\n  //     this.ngZone.run(() => console.log('stable'););\n  //   });\n  // }\n  //\n  // The onStable subscriber run another function inside ngZone\n  // which causes `checkStable()` re-entry.\n  // But this fix causes some issues in g3, so this fix will be\n  // launched in another PR.\n  if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {\n    try {\n      zone._nesting++;\n      zone.onMicrotaskEmpty.emit(null);\n    } finally {\n      zone._nesting--;\n      if (!zone.hasPendingMicrotasks) {\n        try {\n          zone.runOutsideAngular(() => zone.onStable.emit(null));\n        } finally {\n          zone.isStable = true;\n        }\n      }\n    }\n  }\n}\n\nfunction delayChangeDetectionForEvents(zone: NgZonePrivate) {\n  /**\n   * We also need to check _nesting here\n   * Consider the following case with shouldCoalesceRunChangeDetection = true\n   *\n   * ngZone.run(() => {});\n   * ngZone.run(() => {});\n   *\n   * We want the two `ngZone.run()` only trigger one change detection\n   * when shouldCoalesceRunChangeDetection is true.\n   * And because in this case, change detection run in async way(requestAnimationFrame),\n   * so we also need to check the _nesting here to prevent multiple\n   * change detections.\n   */\n  if (zone.isCheckStableRunning || zone.callbackScheduled) {\n    return;\n  }\n  zone.callbackScheduled = true;\n  function scheduleCheckStable() {\n    scheduleCallbackWithRafRace(() => {\n      zone.callbackScheduled = false;\n      updateMicroTaskStatus(zone);\n      zone.isCheckStableRunning = true;\n      checkStable(zone);\n      zone.isCheckStableRunning = false;\n    });\n  }\n  if (zone.scheduleInRootZone) {\n    Zone.root.run(() => {\n      scheduleCheckStable();\n    });\n  } else {\n    zone._outer.run(() => {\n      scheduleCheckStable();\n    });\n  }\n  updateMicroTaskStatus(zone);\n}\n\nfunction forkInnerZoneWithAngularBehavior(zone: NgZonePrivate) {\n  const delayChangeDetectionForEventsDelegate = () => {\n    delayChangeDetectionForEvents(zone);\n  };\n  const instanceId = ngZoneInstanceId++;\n  zone._inner = zone._inner.fork({\n    name: 'angular',\n    properties: <any>{\n      [isAngularZoneProperty]: true,\n      [angularZoneInstanceIdProperty]: instanceId,\n      [angularZoneInstanceIdProperty + instanceId]: true,\n    },\n    onInvokeTask: (\n      delegate: ZoneDelegate,\n      current: Zone,\n      target: Zone,\n      task: Task,\n      applyThis: any,\n      applyArgs: any,\n    ): any => {\n      // Prevent triggering change detection when the flag is detected.\n      if (shouldBeIgnoredByZone(applyArgs)) {\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      }\n\n      try {\n        onEnter(zone);\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      } finally {\n        if (\n          (zone.shouldCoalesceEventChangeDetection && task.type === 'eventTask') ||\n          zone.shouldCoalesceRunChangeDetection\n        ) {\n          delayChangeDetectionForEventsDelegate();\n        }\n        onLeave(zone);\n      }\n    },\n\n    onInvoke: (\n      delegate: ZoneDelegate,\n      current: Zone,\n      target: Zone,\n      callback: Function,\n      applyThis: any,\n      applyArgs?: any[],\n      source?: string,\n    ): any => {\n      try {\n        onEnter(zone);\n        return delegate.invoke(target, callback, applyThis, applyArgs, source);\n      } finally {\n        if (\n          zone.shouldCoalesceRunChangeDetection &&\n          // Do not delay change detection when the task is the scheduler's tick.\n          // We need to synchronously trigger the stability logic so that the\n          // zone-based scheduler can prevent a duplicate ApplicationRef.tick\n          // by first checking if the scheduler tick is running. This does seem a bit roundabout,\n          // but we _do_ still want to trigger all the correct events when we exit the zone.run\n          // (`onMicrotaskEmpty` and `onStable` _should_ emit; developers can have code which\n          // relies on these events happening after change detection runs).\n          // Note: `zone.callbackScheduled` is already in delayChangeDetectionForEventsDelegate\n          // but is added here as well to prevent reads of applyArgs when not necessary\n          !zone.callbackScheduled &&\n          !isSchedulerTick(applyArgs)\n        ) {\n          delayChangeDetectionForEventsDelegate();\n        }\n        onLeave(zone);\n      }\n    },\n\n    onHasTask: (\n      delegate: ZoneDelegate,\n      current: Zone,\n      target: Zone,\n      hasTaskState: HasTaskState,\n    ) => {\n      delegate.hasTask(target, hasTaskState);\n      if (current === target) {\n        // We are only interested in hasTask events which originate from our zone\n        // (A child hasTask event is not interesting to us)\n        if (hasTaskState.change == 'microTask') {\n          zone._hasPendingMicrotasks = hasTaskState.microTask;\n          updateMicroTaskStatus(zone);\n          checkStable(zone);\n        } else if (hasTaskState.change == 'macroTask') {\n          zone.hasPendingMacrotasks = hasTaskState.macroTask;\n        }\n      }\n    },\n\n    onHandleError: (delegate: ZoneDelegate, current: Zone, target: Zone, error: any): boolean => {\n      delegate.handleError(target, error);\n      zone.runOutsideAngular(() => zone.onError.emit(error));\n      return false;\n    },\n  });\n}\n\nfunction updateMicroTaskStatus(zone: NgZonePrivate) {\n  if (\n    zone._hasPendingMicrotasks ||\n    ((zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) &&\n      zone.callbackScheduled === true)\n  ) {\n    zone.hasPendingMicrotasks = true;\n  } else {\n    zone.hasPendingMicrotasks = false;\n  }\n}\n\nfunction onEnter(zone: NgZonePrivate) {\n  zone._nesting++;\n  if (zone.isStable) {\n    zone.isStable = false;\n    zone.onUnstable.emit(null);\n  }\n}\n\nfunction onLeave(zone: NgZonePrivate) {\n  zone._nesting--;\n  checkStable(zone);\n}\n\n/**\n * Provides a noop implementation of `NgZone` which does nothing. This zone requires explicit calls\n * to framework to perform rendering.\n */\nexport class NoopNgZone implements NgZone {\n  readonly hasPendingMicrotasks = false;\n  readonly hasPendingMacrotasks = false;\n  readonly isStable = true;\n  readonly onUnstable = new EventEmitter<any>();\n  readonly onMicrotaskEmpty = new EventEmitter<any>();\n  readonly onStable = new EventEmitter<any>();\n  readonly onError = new EventEmitter<any>();\n\n  run<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any): T {\n    return fn.apply(applyThis, applyArgs);\n  }\n\n  runGuarded<T>(fn: (...args: any[]) => any, applyThis?: any, applyArgs?: any): T {\n    return fn.apply(applyThis, applyArgs);\n  }\n\n  runOutsideAngular<T>(fn: (...args: any[]) => T): T {\n    return fn();\n  }\n\n  runTask<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any, name?: string): T {\n    return fn.apply(applyThis, applyArgs);\n  }\n}\n\nfunction shouldBeIgnoredByZone(applyArgs: unknown): boolean {\n  return hasApplyArgsData(applyArgs, '__ignore_ng_zone__');\n}\n\nfunction isSchedulerTick(applyArgs: unknown): boolean {\n  return hasApplyArgsData(applyArgs, '__scheduler_tick__');\n}\n\nfunction hasApplyArgsData(applyArgs: unknown, key: string) {\n  if (!Array.isArray(applyArgs)) {\n    return false;\n  }\n\n  // We should only ever get 1 arg passed through to invokeTask.\n  // Short circuit here incase that behavior changes.\n  if (applyArgs.length !== 1) {\n    return false;\n  }\n\n  return applyArgs[0]?.data?.[key] === true;\n}\n\n// Set of options recognized by the NgZone.\nexport interface InternalNgZoneOptions {\n  enableLongStackTrace?: boolean;\n  shouldCoalesceEventChangeDetection?: boolean;\n  shouldCoalesceRunChangeDetection?: boolean;\n  scheduleInRootZone?: boolean;\n}\n\nexport function getNgZone(\n  ngZoneToUse: NgZone | 'zone.js' | 'noop' = 'zone.js',\n  options: InternalNgZoneOptions,\n): NgZone {\n  if (ngZoneToUse === 'noop') {\n    return new NoopNgZone();\n  }\n  if (ngZoneToUse === 'zone.js') {\n    return new NgZone(options);\n  }\n  return ngZoneToUse;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ENVIRONMENT_INITIALIZER} from './di/initializer_token';\nimport {InjectionToken} from './di/injection_token';\nimport {inject} from './di/injector_compatibility';\nimport type {EnvironmentProviders} from './di/interface/provider';\nimport {makeEnvironmentProviders, provideEnvironmentInitializer} from './di/provider_collection';\nimport {EnvironmentInjector} from './di/r3_injector';\nimport {DOCUMENT} from './document';\nimport {RuntimeError, RuntimeErrorCode} from './errors';\nimport {DestroyRef} from './linker/destroy_ref';\nimport {NgZone} from './zone/ng_zone';\n\n/**\n * Provides a hook for centralized exception handling.\n *\n * The default implementation of `ErrorHandler` prints error messages to the `console`. To\n * intercept error handling, write a custom exception handler that replaces this default as\n * appropriate for your app.\n *\n * @usageNotes\n * ### Example\n *\n * ```ts\n * class MyErrorHandler implements ErrorHandler {\n *   handleError(error) {\n *     // do something with the exception\n *   }\n * }\n *\n * // Provide in standalone apps\n * bootstrapApplication(AppComponent, {\n *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]\n * })\n *\n * // Provide in module-based apps\n * @NgModule({\n *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]\n * })\n * class MyModule {}\n * ```\n *\n * @publicApi\n *\n * @see [Unhandled errors in Angular](best-practices/error-handling)\n *\n */\nexport class ErrorHandler {\n  /**\n   * @internal\n   */\n  _console: Console = console;\n\n  handleError(error: any): void {\n    this._console.error('ERROR', error);\n  }\n}\n\n/**\n * `InjectionToken` used to configure how to call the `ErrorHandler`.\n */\nexport const INTERNAL_APPLICATION_ERROR_HANDLER = new InjectionToken<(e: any) => void>(\n  typeof ngDevMode === 'undefined' || ngDevMode ? 'internal error handler' : '',\n  {\n    factory: () => {\n      // The user's error handler may depend on things that create a circular dependency\n      // so we inject it lazily.\n      const zone = inject(NgZone);\n      const injector = inject(EnvironmentInjector);\n      let userErrorHandler: ErrorHandler;\n      return (e: unknown) => {\n        zone.runOutsideAngular(() => {\n          if (injector.destroyed && !userErrorHandler) {\n            setTimeout(() => {\n              throw e;\n            });\n          } else {\n            userErrorHandler ??= injector.get(ErrorHandler);\n            userErrorHandler.handleError(e);\n          }\n        });\n      };\n    },\n  },\n);\n\nexport const errorHandlerEnvironmentInitializer = {\n  provide: ENVIRONMENT_INITIALIZER,\n  useValue: () => {\n    const handler = inject(ErrorHandler, {optional: true});\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && handler === null) {\n      throw new RuntimeError(\n        RuntimeErrorCode.MISSING_REQUIRED_INJECTABLE_IN_BOOTSTRAP,\n        `A required Injectable was not found in the dependency injection tree. ` +\n          'If you are bootstrapping an NgModule, make sure that the `BrowserModule` is imported.',\n      );\n    }\n  },\n  multi: true,\n};\n\nconst globalErrorListeners = new InjectionToken<void>(\n  typeof ngDevMode !== 'undefined' && ngDevMode ? 'GlobalErrorListeners' : '',\n  {\n    factory: () => {\n      if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n        return;\n      }\n      const window = inject(DOCUMENT).defaultView;\n      if (!window) {\n        return;\n      }\n\n      const errorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);\n      const rejectionListener = (e: PromiseRejectionEvent) => {\n        errorHandler(e.reason);\n        e.preventDefault();\n      };\n      const errorListener = (e: ErrorEvent) => {\n        if (e.error) {\n          errorHandler(e.error);\n        } else {\n          errorHandler(\n            new Error(\n              ngDevMode\n                ? `An ErrorEvent with no error occurred. See Error.cause for details: ${e.message}`\n                : e.message,\n              {cause: e},\n            ),\n          );\n        }\n        e.preventDefault();\n      };\n\n      const setupEventListeners = () => {\n        window.addEventListener('unhandledrejection', rejectionListener);\n        window.addEventListener('error', errorListener);\n      };\n\n      // Angular doesn't have to run change detection whenever any asynchronous tasks are invoked in\n      // the scope of this functionality.\n      if (typeof Zone !== 'undefined') {\n        Zone.root.run(setupEventListeners);\n      } else {\n        setupEventListeners();\n      }\n\n      inject(DestroyRef).onDestroy(() => {\n        window.removeEventListener('error', errorListener);\n        window.removeEventListener('unhandledrejection', rejectionListener);\n      });\n    },\n  },\n);\n\n/**\n * Provides an environment initializer which forwards unhandled errors to the ErrorHandler.\n *\n * The listeners added are for the window's 'unhandledrejection' and 'error' events.\n *\n * @see [Global error listeners](best-practices/error-handling#global-error-listeners)\n *\n * @publicApi\n */\nexport function provideBrowserGlobalErrorListeners(): EnvironmentProviders {\n  return makeEnvironmentProviders([\n    provideEnvironmentInitializer(() => void inject(globalErrorListeners)),\n  ]);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {createSignal, SIGNAL, SignalGetter, SignalNode} from '../../../primitives/signals';\n\nimport {Signal, ValueEqualityFn} from './api';\n\n/** Symbol used distinguish `WritableSignal` from other non-writable signals and functions. */\nexport const ɵWRITABLE_SIGNAL: unique symbol = /* @__PURE__ */ Symbol('WRITABLE_SIGNAL');\n\n/**\n * A `Signal` with a value that can be mutated via a setter interface.\n *\n * @publicApi 17.0\n */\nexport interface WritableSignal<T> extends Signal<T> {\n  [ɵWRITABLE_SIGNAL]: T;\n\n  /**\n   * Directly set the signal to a new value, and notify any dependents.\n   */\n  set(value: T): void;\n\n  /**\n   * Update the value of the signal based on its current value, and\n   * notify any dependents.\n   */\n  update(updateFn: (value: T) => T): void;\n\n  /**\n   * Returns a readonly version of this signal. Readonly signals can be accessed to read their value\n   * but can't be changed using set or update methods. The readonly signals do _not_ have\n   * any built-in mechanism that would prevent deep-mutation of their value.\n   */\n  asReadonly(): Signal<T>;\n}\n\n/**\n * Utility function used during template type checking to extract the value from a `WritableSignal`.\n * @codeGenApi\n */\nexport function ɵunwrapWritableSignal<T>(value: T | {[ɵWRITABLE_SIGNAL]: T}): T {\n  // Note: the function uses `WRITABLE_SIGNAL` as a brand instead of `WritableSignal<T>`,\n  // because the latter incorrectly unwraps non-signal getter functions.\n  return null!;\n}\n\n/**\n * Options passed to the `signal` creation function.\n */\nexport interface CreateSignalOptions<T> {\n  /**\n   * A comparison function which defines equality for signal values.\n   */\n  equal?: ValueEqualityFn<T>;\n\n  /**\n   * A debug name for the signal. Used in Angular DevTools to identify the signal.\n   */\n  debugName?: string;\n}\n\n/**\n * Create a `Signal` that can be set or updated directly.\n * @see [Angular Signals](guide/signals)\n */\nexport function signal<T>(initialValue: T, options?: CreateSignalOptions<T>): WritableSignal<T> {\n  const [get, set, update] = createSignal(initialValue, options?.equal);\n\n  const signalFn = get as SignalGetter<T> & WritableSignal<T>;\n  const node = signalFn[SIGNAL];\n\n  signalFn.set = set;\n  signalFn.update = update;\n  signalFn.asReadonly = signalAsReadonlyFn.bind(signalFn as any) as () => Signal<T>;\n\n  if (ngDevMode) {\n    signalFn.toString = () => `[Signal: ${signalFn()}]`;\n    node.debugName = options?.debugName;\n  }\n\n  return signalFn as WritableSignal<T>;\n}\n\nexport function signalAsReadonlyFn<T>(this: SignalGetter<T>): Signal<T> {\n  const node = this[SIGNAL] as SignalNode<T> & {readonlyFn?: Signal<T>};\n  if (node.readonlyFn === undefined) {\n    const readonlyFn = () => this();\n    (readonlyFn as any)[SIGNAL] = node;\n    node.readonlyFn = readonlyFn as Signal<T>;\n  }\n  return node.readonlyFn;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {getActiveConsumer} from '../../../primitives/signals';\n\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\n\n/**\n * Asserts that the current stack frame is not within a reactive context. Useful\n * to disallow certain code from running inside a reactive context (see {@link /api/core/rxjs-interop/toSignal toSignal})\n *\n * @param debugFn a reference to the function making the assertion (used for the error message).\n * @see [Asserts the reactive context](guide/signals#asserts-the-reactive-context)\n *\n * @publicApi\n */\nexport function assertNotInReactiveContext(debugFn: Function, extraContext?: string): void {\n  // Taking a `Function` instead of a string name here prevents the un-minified name of the function\n  // from being retained in the bundle regardless of minification.\n  if (getActiveConsumer() !== null) {\n    throw new RuntimeError(\n      RuntimeErrorCode.ASSERTION_NOT_INSIDE_REACTIVE_CONTEXT,\n      ngDevMode &&\n        `${debugFn.name}() cannot be called from within a reactive context.${\n          extraContext ? ` ${extraContext}` : ''\n        }`,\n    );\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {TNode} from './interfaces/node';\nimport type {LView} from './interfaces/view';\nimport {getCurrentTNode, getLView} from './state';\n\nexport class ViewContext {\n  constructor(\n    readonly view: LView,\n    readonly node: TNode,\n  ) {}\n\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ELEMENT_ID__ = injectViewContext;\n}\n\nexport function injectViewContext(): ViewContext {\n  return new ViewContext(getLView()!, getCurrentTNode()!);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InjectionToken} from '../../di/injection_token';\n\nexport const enum NotificationSource {\n  // Change detection needs to run in order to synchronize application state\n  // with the DOM when the following notifications are received:\n  // This operation indicates that a subtree needs to be traversed during change detection.\n  MarkAncestorsForTraversal,\n  // A component/directive gets a new input.\n  SetInput,\n  // Defer block state updates need change detection to fully render the state.\n  DeferBlockStateUpdate,\n  // Debugging tools updated state and have requested change detection.\n  DebugApplyChanges,\n  // ChangeDetectorRef.markForCheck indicates the component is dirty/needs to refresh.\n  MarkForCheck,\n\n  // Bound listener callbacks execute and can update state without causing other notifications from\n  // above.\n  Listener,\n\n  // Custom elements do sometimes require checking directly.\n  CustomElement,\n\n  // The following notifications do not require views to be refreshed\n  // but we should execute render hooks:\n  // Render hooks are guaranteed to execute with the schedulers timing.\n  RenderHook,\n  // Views might be created outside and manipulated in ways that\n  // we cannot be aware of. When a view is attached, Angular now \"knows\"\n  // about it and we now know that DOM might have changed (and we should\n  // run render hooks). If the attached view is dirty, the `MarkAncestorsForTraversal`\n  // notification should also be received.\n  ViewAttached,\n  // When DOM removal happens, render hooks may be interested in the new\n  // DOM state but we do not need to refresh any views unless. If change\n  // detection is required after DOM removal, another notification should\n  // be received (i.e. `markForCheck`).\n  ViewDetachedFromDOM,\n  // Applying animations might result in new DOM state and should rerun render hooks\n  AsyncAnimationsLoaded,\n  // The scheduler is notified when a pending task is removed via the public API.\n  // This allows us to make stability async, delayed until the next application tick.\n  PendingTaskRemoved,\n  // An `effect()` outside of the view tree became dirty and might need to run.\n  RootEffect,\n  // An `effect()` within the view tree became dirty.\n  ViewEffect,\n}\n\n/**\n * Injectable that is notified when an `LView` is made aware of changes to application state.\n */\nexport abstract class ChangeDetectionScheduler {\n  abstract notify(source: NotificationSource): void;\n  abstract runningTick: boolean;\n}\n\n/** Token used to indicate if zoneless was enabled via provideZonelessChangeDetection(). */\nexport const ZONELESS_ENABLED = new InjectionToken<boolean>(\n  typeof ngDevMode === 'undefined' || ngDevMode ? 'Zoneless enabled' : '',\n  {factory: () => true},\n);\n\n/** Token used to indicate `provideZonelessChangeDetection` was used. */\nexport const PROVIDED_ZONELESS = new InjectionToken<boolean>(\n  typeof ngDevMode === 'undefined' || ngDevMode ? 'Zoneless provided' : '',\n  {factory: () => false},\n);\n\n// TODO(atscott): Remove in v19. Scheduler should be done with runOutsideAngular.\nexport const SCHEDULE_IN_ROOT_ZONE = new InjectionToken<boolean>(\n  typeof ngDevMode === 'undefined' || ngDevMode ? 'run changes outside zone in root' : '',\n);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {inject} from './di/injector_compatibility';\nimport {ɵɵdefineInjectable} from './di/interface/defs';\nimport {\n  ChangeDetectionScheduler,\n  NotificationSource,\n} from './change_detection/scheduling/zoneless_scheduling';\nimport {INTERNAL_APPLICATION_ERROR_HANDLER} from './error_handler';\nimport {PendingTasksInternal} from './pending_tasks_internal';\n\n/**\n * Service that keeps track of pending tasks contributing to the stableness of Angular\n * application. While several existing Angular services (ex.: `HttpClient`) will internally manage\n * tasks influencing stability, this API gives control over stability to library and application\n * developers for specific cases not covered by Angular internals.\n *\n * The concept of stability comes into play in several important scenarios:\n * - SSR process needs to wait for the application stability before serializing and sending rendered\n * HTML;\n * - tests might want to delay assertions until the application becomes stable;\n *\n * @usageNotes\n * ```ts\n * const pendingTasks = inject(PendingTasks);\n * const taskCleanup = pendingTasks.add();\n * // do work that should block application's stability and then:\n * taskCleanup();\n * ```\n *\n *\n * @see [PendingTasks for Server Side Rendering (SSR)](guide/zoneless#pendingtasks-for-server-side-rendering-ssr)\n *\n * @publicApi 20.0\n */\nexport class PendingTasks {\n  private readonly internalPendingTasks = inject(PendingTasksInternal);\n  private readonly scheduler = inject(ChangeDetectionScheduler);\n  private readonly errorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);\n  /**\n   * Adds a new task that should block application's stability.\n   * @returns A cleanup function that removes a task when called.\n   */\n  add(): () => void {\n    const taskId = this.internalPendingTasks.add();\n    return () => {\n      if (!this.internalPendingTasks.has(taskId)) {\n        // This pending task has already been cleared.\n        return;\n      }\n      // Notifying the scheduler will hold application stability open until the next tick.\n      this.scheduler.notify(NotificationSource.PendingTaskRemoved);\n      this.internalPendingTasks.remove(taskId);\n    };\n  }\n\n  /**\n   * Runs an asynchronous function and blocks the application's stability until the function completes.\n   *\n   * ```ts\n   * pendingTasks.run(async () => {\n   *   const userData = await fetch('/api/user');\n   *   this.userData.set(userData);\n   * });\n   * ```\n   *\n   * @param fn The asynchronous function to execute\n   * @developerPreview 19.0\n   */\n  run(fn: () => Promise<unknown>): void {\n    const removeTask = this.add();\n    fn().catch(this.errorHandler).finally(removeTask);\n  }\n\n  /** @nocollapse */\n  static ɵprov = /** @pureOrBreakMyCode */ /* @__PURE__ */ ɵɵdefineInjectable({\n    token: PendingTasks,\n    providedIn: 'root',\n    factory: () => new PendingTasks(),\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ɵɵdefineInjectable} from '../../di/interface/defs';\n\n/**\n * Abstraction that encompasses any kind of effect that can be scheduled.\n */\nexport interface SchedulableEffect {\n  run(): void;\n  zone: {\n    run<T>(fn: () => T): T;\n  } | null;\n  dirty: boolean;\n}\n\n/**\n * A scheduler which manages the execution of effects.\n */\nexport abstract class EffectScheduler {\n  abstract add(e: SchedulableEffect): void;\n\n  /**\n   * Schedule the given effect to be executed at a later time.\n   *\n   * It is an error to attempt to execute any effects synchronously during a scheduling operation.\n   */\n  abstract schedule(e: SchedulableEffect): void;\n\n  /**\n   * Run any scheduled effects.\n   */\n  abstract flush(): void;\n\n  /** Remove a scheduled effect */\n  abstract remove(e: SchedulableEffect): void;\n\n  /** @nocollapse */\n  static ɵprov = /** @pureOrBreakMyCode */ /* @__PURE__ */ ɵɵdefineInjectable({\n    token: EffectScheduler,\n    providedIn: 'root',\n    factory: () => new ZoneAwareEffectScheduler(),\n  });\n}\n\n/**\n * A wrapper around `ZoneAwareQueueingScheduler` that schedules flushing via the microtask queue\n * when.\n */\nexport class ZoneAwareEffectScheduler implements EffectScheduler {\n  private dirtyEffectCount = 0;\n  private queues = new Map<Zone | null, Set<SchedulableEffect>>();\n\n  add(handle: SchedulableEffect): void {\n    this.enqueue(handle);\n    this.schedule(handle);\n  }\n\n  schedule(handle: SchedulableEffect): void {\n    if (!handle.dirty) {\n      return;\n    }\n    this.dirtyEffectCount++;\n  }\n\n  remove(handle: SchedulableEffect): void {\n    const zone = handle.zone as Zone | null;\n    const queue = this.queues.get(zone)!;\n    if (!queue.has(handle)) {\n      return;\n    }\n\n    queue.delete(handle);\n    if (handle.dirty) {\n      this.dirtyEffectCount--;\n    }\n  }\n\n  private enqueue(handle: SchedulableEffect): void {\n    const zone = handle.zone as Zone | null;\n    if (!this.queues.has(zone)) {\n      this.queues.set(zone, new Set());\n    }\n\n    const queue = this.queues.get(zone)!;\n    if (queue.has(handle)) {\n      return;\n    }\n    queue.add(handle);\n  }\n\n  /**\n   * Run all scheduled effects.\n   *\n   * Execution order of effects within the same zone is guaranteed to be FIFO, but there is no\n   * ordering guarantee between effects scheduled in different zones.\n   */\n  flush(): void {\n    while (this.dirtyEffectCount > 0) {\n      let ranOneEffect = false;\n      for (const [zone, queue] of this.queues) {\n        // `zone` here must be defined.\n        if (zone === null) {\n          ranOneEffect ||= this.flushQueue(queue);\n        } else {\n          ranOneEffect ||= zone.run(() => this.flushQueue(queue));\n        }\n      }\n\n      // Safeguard against infinite looping if somehow our dirty effect count gets out of sync with\n      // the dirty flag across all the effects.\n      if (!ranOneEffect) {\n        this.dirtyEffectCount = 0;\n      }\n    }\n  }\n\n  private flushQueue(queue: Set<SchedulableEffect>): boolean {\n    let ranOneEffect = false;\n    for (const handle of queue) {\n      if (!handle.dirty) {\n        continue;\n      }\n      this.dirtyEffectCount--;\n      ranOneEffect = true;\n\n      // TODO: what happens if this throws an error?\n      handle.run();\n    }\n    return ranOneEffect;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  SIGNAL,\n  consumerDestroy,\n  isInNotificationPhase,\n  setActiveConsumer,\n  BaseEffectNode,\n  BASE_EFFECT_NODE,\n  runEffect,\n} from '../../../primitives/signals';\nimport {FLAGS, LViewFlags, LView, EFFECTS} from '../interfaces/view';\nimport {markAncestorsForTraversal} from '../util/view_utils';\nimport {inject} from '../../di/injector_compatibility';\nimport {Injector} from '../../di/injector';\nimport {assertNotInReactiveContext} from './asserts';\nimport {assertInInjectionContext} from '../../di/contextual';\nimport {DestroyRef, NodeInjectorDestroyRef} from '../../linker/destroy_ref';\nimport {ViewContext} from '../view_context';\nimport {\n  ChangeDetectionScheduler,\n  NotificationSource,\n} from '../../change_detection/scheduling/zoneless_scheduling';\nimport {setIsRefreshingViews} from '../state';\nimport {EffectScheduler, SchedulableEffect} from './root_effect_scheduler';\n\nimport {emitEffectCreatedEvent, setInjectorProfilerContext} from '../debug/injector_profiler';\n\n/**\n * A global reactive effect, which can be manually destroyed.\n *\n * @publicApi 20.0\n */\nexport interface EffectRef {\n  /**\n   * Shut down the effect, removing it from any upcoming scheduled executions.\n   */\n  destroy(): void;\n}\n\nexport class EffectRefImpl implements EffectRef {\n  [SIGNAL]: EffectNode;\n\n  constructor(node: EffectNode) {\n    this[SIGNAL] = node;\n  }\n\n  destroy(): void {\n    this[SIGNAL].destroy();\n  }\n}\n\n/**\n * Options passed to the `effect` function.\n *\n * @publicApi 20.0\n */\nexport interface CreateEffectOptions {\n  /**\n   * The `Injector` in which to create the effect.\n   *\n   * If this is not provided, the current [injection context](guide/di/dependency-injection-context)\n   * will be used instead (via `inject`).\n   */\n  injector?: Injector;\n\n  /**\n   * Whether the `effect` should require manual cleanup.\n   *\n   * If this is `false` (the default) the effect will automatically register itself to be cleaned up\n   * with the current `DestroyRef`.\n   *\n   * If this is `true` and you want to use the effect outside an injection context, you still\n   * need to provide an `Injector` to the effect.\n   */\n  manualCleanup?: boolean;\n\n  /**\n   * @deprecated no longer required, signal writes are allowed by default.\n   */\n  allowSignalWrites?: boolean;\n\n  /**\n   * A debug name for the effect. Used in Angular DevTools to identify the effect.\n   */\n  debugName?: string;\n}\n\n/**\n * An effect can, optionally, register a cleanup function. If registered, the cleanup is executed\n * before the next effect run. The cleanup function makes it possible to \"cancel\" any work that the\n * previous effect run might have started.\n *\n * @see [Effect cleanup functions](guide/signals#effect-cleanup-functions)\n *\n * @publicApi 20.0\n */\nexport type EffectCleanupFn = () => void;\n\n/**\n * A callback passed to the effect function that makes it possible to register cleanup logic.\n *\n * @see [Effect cleanup functions](guide/signals#effect-cleanup-functions)\n *\n * @publicApi 20.0\n */\nexport type EffectCleanupRegisterFn = (cleanupFn: EffectCleanupFn) => void;\n\n/**\n * Registers an \"effect\" that will be scheduled & executed whenever the signals that it reads\n * changes.\n *\n * Angular has two different kinds of effect: component effects and root effects. Component effects\n * are created when `effect()` is called from a component, directive, or within a service of a\n * component/directive. Root effects are created when `effect()` is called from outside the\n * component tree, such as in a root service.\n *\n * The two effect types differ in their timing. Component effects run as a component lifecycle\n * event during Angular's synchronization (change detection) process, and can safely read input\n * signals or create/destroy views that depend on component state. Root effects run as microtasks\n * and have no connection to the component tree or change detection.\n *\n * `effect()` must be run in injection context, unless the `injector` option is manually specified.\n *\n * @see [Effects](guide/signals#effects)\n *\n * @publicApi 20.0\n */\nexport function effect(\n  effectFn: (onCleanup: EffectCleanupRegisterFn) => void,\n  options?: CreateEffectOptions,\n): EffectRef {\n  ngDevMode &&\n    assertNotInReactiveContext(\n      effect,\n      'Call `effect` outside of a reactive context. For example, schedule the ' +\n        'effect inside the component constructor.',\n    );\n\n  if (ngDevMode && !options?.injector) {\n    assertInInjectionContext(effect);\n  }\n\n  if (ngDevMode && options?.allowSignalWrites !== undefined) {\n    console.warn(\n      `The 'allowSignalWrites' flag is deprecated and no longer impacts effect() (writes are always allowed)`,\n    );\n  }\n\n  const injector = options?.injector ?? inject(Injector);\n  let destroyRef = options?.manualCleanup !== true ? injector.get(DestroyRef) : null;\n\n  let node: EffectNode;\n\n  const viewContext = injector.get(ViewContext, null, {optional: true});\n  const notifier = injector.get(ChangeDetectionScheduler);\n  if (viewContext !== null) {\n    // This effect was created in the context of a view, and will be associated with the view.\n    node = createViewEffect(viewContext.view, notifier, effectFn);\n    if (destroyRef instanceof NodeInjectorDestroyRef && destroyRef._lView === viewContext.view) {\n      // The effect is being created in the same view as the `DestroyRef` references, so it will be\n      // automatically destroyed without the need for an explicit `DestroyRef` registration.\n      destroyRef = null;\n    }\n  } else {\n    // This effect was created outside the context of a view, and will be scheduled independently.\n    node = createRootEffect(effectFn, injector.get(EffectScheduler), notifier);\n  }\n  node.injector = injector;\n\n  if (destroyRef !== null) {\n    // If we need to register for cleanup, do that here.\n    node.onDestroyFns = [destroyRef.onDestroy(() => node.destroy())];\n  }\n\n  const effectRef = new EffectRefImpl(node);\n\n  if (ngDevMode) {\n    node.debugName = options?.debugName ?? '';\n    const prevInjectorProfilerContext = setInjectorProfilerContext({injector, token: null});\n    try {\n      emitEffectCreatedEvent(effectRef);\n    } finally {\n      setInjectorProfilerContext(prevInjectorProfilerContext);\n    }\n  }\n\n  return effectRef;\n}\n\nexport interface EffectNode extends BaseEffectNode, SchedulableEffect {\n  cleanupFns: EffectCleanupFn[] | undefined;\n  injector: Injector;\n  notifier: ChangeDetectionScheduler;\n\n  onDestroyFns: (() => void)[] | null;\n}\n\nexport interface ViewEffectNode extends EffectNode {\n  view: LView;\n}\n\nexport interface RootEffectNode extends EffectNode {\n  scheduler: EffectScheduler;\n}\n\nexport const EFFECT_NODE: Omit<EffectNode, 'fn' | 'destroy' | 'injector' | 'notifier'> =\n  /* @__PURE__ */ (() => ({\n    ...BASE_EFFECT_NODE,\n    cleanupFns: undefined,\n    zone: null,\n    onDestroyFns: null,\n    run(this: EffectNode): void {\n      if (ngDevMode && isInNotificationPhase()) {\n        throw new Error(`Schedulers cannot synchronously execute watches while scheduling.`);\n      }\n      // We clear `setIsRefreshingViews` so that `markForCheck()` within the body of an effect will\n      // cause CD to reach the component in question.\n      const prevRefreshingViews = setIsRefreshingViews(false);\n      try {\n        runEffect(this);\n      } finally {\n        setIsRefreshingViews(prevRefreshingViews);\n      }\n    },\n\n    cleanup(this: EffectNode): void {\n      if (!this.cleanupFns?.length) {\n        return;\n      }\n      const prevConsumer = setActiveConsumer(null);\n      try {\n        // Attempt to run the cleanup functions. Regardless of failure or success, we consider\n        // cleanup \"completed\" and clear the list for the next run of the effect. Note that an error\n        // from the cleanup function will still crash the current run of the effect.\n        while (this.cleanupFns.length) {\n          this.cleanupFns.pop()!();\n        }\n      } finally {\n        this.cleanupFns = [];\n        setActiveConsumer(prevConsumer);\n      }\n    },\n  }))();\n\nexport const ROOT_EFFECT_NODE: Omit<RootEffectNode, 'fn' | 'scheduler' | 'notifier' | 'injector'> =\n  /* @__PURE__ */ (() => ({\n    ...EFFECT_NODE,\n    consumerMarkedDirty(this: RootEffectNode) {\n      this.scheduler.schedule(this);\n      this.notifier.notify(NotificationSource.RootEffect);\n    },\n    destroy(this: RootEffectNode) {\n      consumerDestroy(this);\n\n      if (this.onDestroyFns !== null) {\n        for (const fn of this.onDestroyFns) {\n          fn();\n        }\n      }\n\n      this.cleanup();\n      this.scheduler.remove(this);\n    },\n  }))();\n\nexport const VIEW_EFFECT_NODE: Omit<ViewEffectNode, 'fn' | 'view' | 'injector' | 'notifier'> =\n  /* @__PURE__ */ (() => ({\n    ...EFFECT_NODE,\n    consumerMarkedDirty(this: ViewEffectNode): void {\n      this.view[FLAGS] |= LViewFlags.HasChildViewsToRefresh;\n      markAncestorsForTraversal(this.view);\n      this.notifier.notify(NotificationSource.ViewEffect);\n    },\n    destroy(this: ViewEffectNode): void {\n      consumerDestroy(this);\n\n      if (this.onDestroyFns !== null) {\n        for (const fn of this.onDestroyFns) {\n          fn();\n        }\n      }\n\n      this.cleanup();\n      this.view[EFFECTS]?.delete(this);\n    },\n  }))();\n\nexport function createViewEffect(\n  view: LView,\n  notifier: ChangeDetectionScheduler,\n  fn: (onCleanup: EffectCleanupRegisterFn) => void,\n): ViewEffectNode {\n  const node = Object.create(VIEW_EFFECT_NODE) as ViewEffectNode;\n  node.view = view;\n  node.zone = typeof Zone !== 'undefined' ? Zone.current : null;\n  node.notifier = notifier;\n  node.fn = createEffectFn(node, fn);\n\n  view[EFFECTS] ??= new Set();\n  view[EFFECTS].add(node);\n\n  node.consumerMarkedDirty(node);\n  return node;\n}\n\nexport function createRootEffect(\n  fn: (onCleanup: EffectCleanupRegisterFn) => void,\n  scheduler: EffectScheduler,\n  notifier: ChangeDetectionScheduler,\n): RootEffectNode {\n  const node = Object.create(ROOT_EFFECT_NODE) as RootEffectNode;\n  node.fn = createEffectFn(node, fn);\n  node.scheduler = scheduler;\n  node.notifier = notifier;\n  node.zone = typeof Zone !== 'undefined' ? Zone.current : null;\n  node.scheduler.add(node);\n  node.notifier.notify(NotificationSource.RootEffect);\n  return node;\n}\n\nfunction createEffectFn(node: EffectNode, fn: (onCleanup: EffectCleanupRegisterFn) => void) {\n  return () => {\n    fn((cleanupFn) => (node.cleanupFns ??= []).push(cleanupFn));\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {untracked as untrackedPrimitive} from '../../../primitives/signals';\n\n/**\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\n * can, optionally, return a value.\n * @see [Reading without tracking dependencies](guide/signals#reading-without-tracking-dependencies)\n */\nexport function untracked<T>(nonReactiveReadsFn: () => T): T {\n  return untrackedPrimitive(nonReactiveReadsFn);\n}\n"],"names":["Version","full","major","minor","patch","constructor","parts","split","slice","join","VERSION","ERROR_DETAILS_PAGE_BASE_URL","versionSubDomain","XSS_SECURITY_URL","RuntimeError","Error","code","message","formatRuntimeError","formatRuntimeErrorCode","Math","abs","fullCode","errorMessage","ngDevMode","addPeriodSeparator","match","separator","_global","globalThis","ngDevModeResetPerfCounters","locationString","location","toString","newCounters","hydratedNodes","hydratedComponents","dehydratedViewsRemoved","dehydratedViewsCleanupRuns","componentsSkippedHydration","deferBlocksWithIncrementalHydration","allowNgDevModeTrue","indexOf","global","Object","assign","initNgDevMode","keys","length","getClosureSafeProperty","objWithPropertyToExtract","key","fillProperties","target","source","hasOwnProperty","stringify","token","Array","isArray","map","name","overriddenName","result","newLineIndex","concatStringsWithSpace","before","after","truncateMiddle","str","maxLength","substring","halfLimit","round","__forward_ref__","forwardRef","forwardRefFn","resolveForwardRef","type","isForwardRef","fn","assertNumber","actual","msg","throwError","assertNumberInRange","minInclusive","maxInclusive","assertLessThanOrEqual","assertGreaterThanOrEqual","assertString","assertFunction","assertEqual","expected","assertNotEqual","assertSame","assertNotSame","assertLessThan","assertGreaterThan","assertNotDefined","assertDefined","comparison","assertDomNode","node","Node","assertElement","Element","assertIndexInRange","arr","index","maxLen","assertOneOf","value","validValues","JSON","assertNotReactive","getActiveConsumer","ɵɵdefineInjectable","opts","providedIn","factory","undefined","ɵɵdefineInjector","options","providers","imports","getInjectableDef","getOwnDefinition","NG_PROV_DEF","isInjectable","field","getInheritedInjectableDef","def","console","warn","getInjectorDef","NG_INJ_DEF","ɵprov","ɵinj","InjectionToken","_desc","ngMetadataName","__NG_ELEMENT_ID__","multi","_injectorProfilerContext","getInjectorProfilerContext","setInjectorProfilerContext","context","previous","injectorProfilerCallbacks","NOOP_PROFILER_REMOVAL","removeProfiler","profiler","profilerIdx","splice","setInjectorProfiler","injectorProfiler","includes","push","event","i","injectorProfilerCallback","emitProviderConfiguredEvent","eventProvider","isViewProvider","provide","provider","providerRecord","emitInjectorToCreateInstanceEvent","emitInstanceCreatedByInjectorEvent","instance","emitInjectEvent","flags","service","emitEffectCreatedEvent","effect","emitAfterRenderEffectPhaseCreatedEvent","effectPhase","runInInjectorProfilerContext","injector","callback","prevInjectContext","isEnvironmentProviders","ɵproviders","NG_COMP_DEF","ɵcmp","NG_DIR_DEF","ɵdir","NG_PIPE_DEF","ɵpipe","NG_MOD_DEF","ɵmod","NG_FACTORY_DEF","ɵfac","NG_ELEMENT_ID","NG_ENV_ID","__NG_ENV_ID__","getNgModuleDef","assertTypeDefined","getNgModuleDefOrThrow","ngModuleDef","getComponentDef","getDirectiveDefOrThrow","getDirectiveDef","getPipeDef","symbolType","isStandalone","standalone","renderStringify","String","stringifyForError","debugStringifyTypeForError","componentDef","debugInfo","stringifyTypeFromDebugInfo","filePath","lineNumber","className","NG_RUNTIME_ERROR_CODE","NG_RUNTIME_ERROR_MESSAGE","NG_TOKEN_PATH","cyclicDependencyError","path","createRuntimeError","cyclicDependencyErrorWithDetails","augmentRuntimeError","throwMixedMultiProviderError","throwInvalidProviderError","ngModuleType","providerDetail","v","ɵfromNgModule","throwProviderNotFoundError","injectorName","prependTokenToDependencyPath","error","currentPath","pathStr","unshift","tokenPath","errorCode","formatErrorMessage","getRuntimeErrorCode","text","pathDetails","sourceDetails","_injectImplementation","getInjectImplementation","setInjectImplementation","impl","injectRootLimpMode","notFoundValue","injectableDef","assertInjectImplementationNotEqual","_THROW_IF_NOT_FOUND","THROW_IF_NOT_FOUND","DI_DECORATOR_FLAG","RetrievingInjector","retrieve","convertToBitFlags","get","e","isNotFound","injectInjectorOnly","currentInjector","getCurrentInjector","convertToInjectOptions","optional","ɵɵinject","ɵɵinvalidFactoryDep","inject","host","self","skipSelf","injectArgs","types","args","arg","j","meta","flag","getInjectFlag","attachInjectFlag","decorator","prototype","getFactoryDef","throwNotFound","hasFactoryDef","arrayEquals","a","b","identityAccessor","valueA","valueB","flatten","list","flat","Number","POSITIVE_INFINITY","deepForEach","input","forEach","addToArray","removeFromArray","pop","newArray","size","arraySplice","array","count","arrayInsert2","value1","value2","end","previousEnd","keyValueArraySet","keyValueArray","keyValueArrayIndexOf","keyValueArrayGet","_arrayIndexOfSorted","shift","start","middle","current","EMPTY_OBJ","EMPTY_ARRAY","freeze","ENVIRONMENT_INITIALIZER","INJECTOR","INJECTOR_DEF_TYPES","NullInjector","makeEnvironmentProviders","provideEnvironmentInitializer","initializerFn","useValue","importProvidersFrom","sources","internalImportProvidersFrom","checkForStandaloneCmp","providersOut","dedup","Set","injectorTypesWithProviders","collectProviders","cmpDef","internalSource","walkProviderTree","processInjectorTypesWithProviders","typesWithProviders","visitor","ngModule","deepForEachProvider","validateProvider","container","parents","defType","injDef","defName","concat","isDuplicate","has","add","dependencies","deps","dep","importTypesWithProviders","imported","useFactory","defProviders","injectorType","containerType","isTypeProvider","isValueProvider","isFactoryProvider","isExistingProvider","classRef","useClass","USE_VALUE","useExisting","isClassProvider","INJECTOR_SCOPE","NOT_YET","CIRCULAR","NULL_INJECTOR","getNullInjector","EnvironmentInjector","R3Injector","parent","scopes","records","Map","_ngOnDestroyHooks","_onDestroyHooks","destroyed","_destroyed","injectorDefTypes","forEachSingleProvider","processProvider","set","makeRecord","record","destroy","assertNotDestroyed","prevConsumer","setActiveConsumer","ngOnDestroy","onDestroyHooks","hook","clear","onDestroy","removeOnDestroy","runInContext","previousInjector","setCurrentInjector","previousInjectImplementation","couldBeInjectableType","injectableDefInScope","injectableDefOrInjectorDefFactory","hydrate","nextInjector","resolveInjectorInitializers","initializers","initializer","tokens","providerToRecord","multiRecord","existing","hasOnDestroy","destroyCBIdx","Function","getUndecoratedInjectableFactory","paramLength","inheritedInjectableDef","providerToFactory","unwrappedProvider","_","hasDeps","runInInjectionContext","internalInjector","prevInjectorProfilerContext","prevInjector","isInInjectionContext","assertInInjectionContext","debugFn","HOST","TVIEW","FLAGS","PARENT","NEXT","T_HOST","HYDRATION","CLEANUP","CONTEXT","ENVIRONMENT","RENDERER","CHILD_HEAD","CHILD_TAIL","DECLARATION_VIEW","DECLARATION_COMPONENT_VIEW","DECLARATION_LCONTAINER","PREORDER_HOOK_FLAGS","QUERIES","ID","EMBEDDED_VIEW_INJECTOR","ON_DESTROY_HOOKS","EFFECTS_TO_SCHEDULE","EFFECTS","REACTIVE_TEMPLATE_CONSUMER","AFTER_RENDER_SEQUENCES_TO_ADD","ANIMATIONS","HEADER_OFFSET","TYPE","DEHYDRATED_VIEWS","NATIVE","VIEW_REFS","MOVED_VIEWS","CONTAINER_HEADER_OFFSET","isLView","isLContainer","isContentQueryHost","tNode","isComponentHost","componentOffset","isDirectiveHost","isComponentDef","template","isRootView","isProjectionTNode","hasI18n","lView","isDestroyed","assertTNodeForLView","assertTNodeForTView","assertTNodeCreationIndex","adjustedIndex","bindingStartIndex","tView","assertTNode","tData","data","assertTIcu","tIcu","currentCaseLViewIndex","assertComponentType","assertNgModuleType","assertHasParent","assertLContainer","assertLViewOrUndefined","assertLView","assertFirstCreatePass","errMessage","firstCreatePass","assertFirstUpdatePass","firstUpdatePass","assertDirectiveDef","obj","selectors","inputs","assertIndexInDeclRange","assertBetween","assertIndexInExpandoRange","expandoStartIndex","lower","upper","assertProjectionSlots","projection","assertParentView","assertNodeInjector","injectorIndex","SVG_NAMESPACE","MATH_ML_NAMESPACE","unwrapRNode","unwrapLView","getNativeByIndex","getNativeByTNode","getNativeByTNodeOrNull","getTNode","load","view","store","blueprint","getComponentLViewByIndex","nodeIndex","hostView","slotValue","isCreationMode","viewAttachedToChangeDetector","viewAttachedToContainer","getConstant","consts","resetPreOrderHookFlags","markViewForRefresh","markAncestorsForTraversal","walkUpViews","nestingLevel","currentView","requiresRefreshOrTraversal","dirty","updateAncestorTraversalFlagsOnAttach","changeDetectionScheduler","notify","getLViewParent","storeLViewOnDestroy","onDestroyCallback","removeLViewOnDestroy","getOrCreateLViewCleanup","getOrCreateTViewCleanup","cleanup","storeCleanupWithContext","cleanupFn","lCleanup","instructionState","lFrame","createLFrame","bindingsEnabled","skipHydrationRootTNode","CheckNoChangesMode","_checkNoChangesMode","_isRefreshingViews","getElementDepthCount","elementDepthCount","increaseElementDepthCount","decreaseElementDepthCount","getBindingsEnabled","isInSkipHydrationBlock","isSkipHydrationRootTNode","ɵɵenableBindings","enterSkipHydrationBlock","ɵɵdisableBindings","leaveSkipHydrationBlock","getLView","getTView","ɵɵrestoreView","viewToRestore","contextLView","ɵɵresetView","getCurrentTNode","currentTNode","getCurrentTNodePlaceholderOk","getCurrentParentTNode","isParent","setCurrentTNode","isCurrentTNodeParent","setCurrentTNodeAsNotParent","getContextLView","isInCheckNoChangesMode","Off","isExhaustiveCheckNoChanges","Exhaustive","setIsInCheckNoChangesMode","mode","isRefreshingViews","setIsRefreshingViews","prev","getBindingRoot","bindingRootIndex","getBindingIndex","bindingIndex","setBindingIndex","nextBindingIndex","incrementBindingIndex","isInI18nBlock","inI18n","setInI18nBlock","setBindingRootForHostBindings","currentDirectiveIndex","setCurrentDirectiveIndex","getCurrentDirectiveIndex","getCurrentDirectiveDef","getCurrentQueryIndex","currentQueryIndex","setCurrentQueryIndex","getDeclarationTNode","declTNode","enterDI","parentTNode","parentLView","allocLFrame","enterView","newView","newLFrame","selectedIndex","currentNamespace","firstChild","currentLFrame","childLFrame","child","leaveViewLight","oldLFrame","leaveDI","leaveView","nextContextImpl","level","getSelectedIndex","setSelectedIndex","getSelectedTNode","ɵɵnamespaceSVG","ɵɵnamespaceMathML","ɵɵnamespaceHTML","namespaceHTMLInternal","getNamespace","_wasLastNodeCreated","wasLastNodeCreated","lastNodeWasCreated","createInjector","additionalProviders","createInjectorWithoutInjectorInstances","Injector","NULL","create","DOCUMENT","DestroyRef","injectDestroyRef","NodeInjectorDestroyRef","_lView","SCHEDULE_IN_ROOT_ZONE_DEFAULT","PendingTasksInternal","taskId","pendingTasks","pendingTask","BehaviorSubject","hasPendingTasks","hasPendingTasksObservable","Observable","subscriber","next","complete","remove","delete","unsubscribe","EventEmitter_","Subject","__isAsync","destroyRef","isAsync","emit","subscribe","observerOrNext","nextFn","errorFn","completeFn","observer","bind","wrapInTimeout","sink","Subscription","setTimeout","EventEmitter","noop","scheduleCallbackWithRafRace","timeoutId","animationFrameId","cancelAnimationFrame","clearTimeout","requestAnimationFrame","scheduleCallbackWithMicrotask","queueMicrotask","AsyncStackTaggingZoneSpec","createTask","namePrefix","consoleAsyncStackTaggingImpl","onScheduleTask","delegate","_current","task","consoleTask","scheduleTask","onInvokeTask","_currentZone","targetZone","applyThis","applyArgs","ret","run","invokeTask","isAngularZoneProperty","angularZoneInstanceIdProperty","ngZoneInstanceId","NgZone","hasPendingMacrotasks","hasPendingMicrotasks","isStable","onUnstable","onMicrotaskEmpty","onStable","onError","enableLongStackTrace","shouldCoalesceEventChangeDetection","shouldCoalesceRunChangeDetection","scheduleInRootZone","Zone","assertZonePatched","_nesting","_outer","_inner","fork","callbackScheduled","forkInnerZoneWithAngularBehavior","isInAngularZone","assertInAngularZone","assertNotInAngularZone","runTask","zone","scheduleEventTask","EMPTY_PAYLOAD","cancelTask","runGuarded","runOutsideAngular","checkStable","delayChangeDetectionForEvents","isCheckStableRunning","scheduleCheckStable","updateMicroTaskStatus","root","delayChangeDetectionForEventsDelegate","instanceId","properties","shouldBeIgnoredByZone","onEnter","onLeave","onInvoke","invoke","isSchedulerTick","onHasTask","hasTaskState","hasTask","change","_hasPendingMicrotasks","microTask","macroTask","onHandleError","handleError","NoopNgZone","apply","hasApplyArgsData","ErrorHandler","_console","INTERNAL_APPLICATION_ERROR_HANDLER","userErrorHandler","errorHandlerEnvironmentInitializer","handler","globalErrorListeners","ngServerMode","window","defaultView","errorHandler","rejectionListener","reason","preventDefault","errorListener","cause","setupEventListeners","addEventListener","removeEventListener","provideBrowserGlobalErrorListeners","ɵunwrapWritableSignal","signal","initialValue","update","createSignal","equal","signalFn","SIGNAL","asReadonly","signalAsReadonlyFn","debugName","readonlyFn","assertNotInReactiveContext","extraContext","ViewContext","injectViewContext","ChangeDetectionScheduler","ZONELESS_ENABLED","PROVIDED_ZONELESS","SCHEDULE_IN_ROOT_ZONE","PendingTasks","internalPendingTasks","scheduler","removeTask","catch","finally","EffectScheduler","ZoneAwareEffectScheduler","dirtyEffectCount","queues","handle","enqueue","schedule","queue","flush","ranOneEffect","flushQueue","EffectRefImpl","effectFn","allowSignalWrites","manualCleanup","viewContext","notifier","createViewEffect","createRootEffect","onDestroyFns","effectRef","EFFECT_NODE","BASE_EFFECT_NODE","cleanupFns","isInNotificationPhase","prevRefreshingViews","runEffect","ROOT_EFFECT_NODE","consumerMarkedDirty","consumerDestroy","VIEW_EFFECT_NODE","createEffectFn","untracked","nonReactiveReadsFn","untrackedPrimitive"],"mappings":"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"}