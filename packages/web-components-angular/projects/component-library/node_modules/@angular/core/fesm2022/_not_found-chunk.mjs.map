{"version":3,"file":"_not_found-chunk.mjs","sources":["../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/primitives/di/src/injector.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/core/primitives/di/src/not_found.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Constructor, InjectionToken} from './injection_token';\nimport {NotFound, NOT_FOUND} from './not_found';\n\nexport interface Injector {\n  retrieve<T>(token: InjectionToken<T>, options?: unknown): T | NotFound;\n}\n\n/**\n * Current injector value used by `inject`.\n * - `undefined`: it is an error to call `inject`\n * - `null`: `inject` can be called but there is no injector (limp-mode).\n * - Injector instance: Use the injector for resolution.\n */\nlet _currentInjector: Injector | undefined | null = undefined;\n\nexport function getCurrentInjector(): Injector | undefined | null {\n  return _currentInjector;\n}\n\nexport function setCurrentInjector(\n  injector: Injector | null | undefined,\n): Injector | undefined | null {\n  const former = _currentInjector;\n  _currentInjector = injector;\n  return former;\n}\n\nexport function inject<T>(token: InjectionToken<T> | Constructor<T>): T;\nexport function inject<T>(\n  token: InjectionToken<T> | Constructor<T>,\n  options?: unknown,\n): T | NotFound {\n  const currentInjector = getCurrentInjector();\n  if (!currentInjector) {\n    throw new Error('Current injector is not set.');\n  }\n  if (!(token as InjectionToken<T>).ɵprov) {\n    throw new Error('Token is not an injectable');\n  }\n  return currentInjector.retrieve(token as InjectionToken<T>, options);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * Value returned if the key-value pair couldn't be found in the context\n * hierarchy.\n */\nexport const NOT_FOUND: unique symbol = Symbol('NotFound');\n\n/**\n * Error thrown when the key-value pair couldn't be found in the context\n * hierarchy. Context can be attached below.\n */\nexport class NotFoundError extends Error {\n  override readonly name: string = 'ɵNotFound';\n  constructor(message: string) {\n    super(message);\n  }\n}\n\n/**\n * Type guard for checking if an unknown value is a NotFound.\n */\nexport function isNotFound(e: unknown): e is NotFound {\n  return e === NOT_FOUND || (e as NotFoundError)?.name === 'ɵNotFound';\n}\n\n/**\n * Type union of NotFound and NotFoundError.\n */\nexport type NotFound = typeof NOT_FOUND | NotFoundError;\n"],"names":["_currentInjector","undefined","getCurrentInjector","setCurrentInjector","injector","former","inject","token","options","currentInjector","Error","ɵprov","retrieve","NOT_FOUND","Symbol","NotFoundError","name","constructor","message","isNotFound","e"],"mappings":";;;;;;AAqBA,IAAIA,gBAAgB,GAAgCC,SAAS;SAE7CC,kBAAkBA,GAAA;AAChC,EAAA,OAAOF,gBAAgB;AACzB;AAEM,SAAUG,kBAAkBA,CAChCC,QAAqC,EAAA;EAErC,MAAMC,MAAM,GAAGL,gBAAgB;AAC/BA,EAAAA,gBAAgB,GAAGI,QAAQ;AAC3B,EAAA,OAAOC,MAAM;AACf;AAGgB,SAAAC,MAAMA,CACpBC,KAAyC,EACzCC,OAAiB,EAAA;AAEjB,EAAA,MAAMC,eAAe,GAAGP,kBAAkB,EAAE;EAC5C,IAAI,CAACO,eAAe,EAAE;AACpB,IAAA,MAAM,IAAIC,KAAK,CAAC,8BAA8B,CAAC;AACjD;AACA,EAAA,IAAI,CAAEH,KAA2B,CAACI,KAAK,EAAE;AACvC,IAAA,MAAM,IAAID,KAAK,CAAC,4BAA4B,CAAC;AAC/C;AACA,EAAA,OAAOD,eAAe,CAACG,QAAQ,CAACL,KAA0B,EAAEC,OAAO,CAAC;AACtE;;MCpCaK,SAAS,GAAkBC,MAAM,CAAC,UAAU;AAMnD,MAAOC,aAAc,SAAQL,KAAK,CAAA;AACpBM,EAAAA,IAAI,GAAW,WAAW;EAC5CC,WAAAA,CAAYC,OAAe,EAAA;IACzB,KAAK,CAACA,OAAO,CAAC;AAChB;AACD;AAKK,SAAUC,UAAUA,CAACC,CAAU,EAAA;EACnC,OAAOA,CAAC,KAAKP,SAAS,IAAKO,CAAmB,EAAEJ,IAAI,KAAK,WAAW;AACtE;;;;"}